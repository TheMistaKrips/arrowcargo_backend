================================================================================
ИСХОДНЫЙ КОД ПРОЕКТА
Директория: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend
Всего файлов: 33
================================================================================


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
КАТЕГОРИЯ: Python (33 файлов)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\__init__.py                                                        ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\__init__.py ║
╚══════════════════════════════════════════════════════════════════════════════╝


────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\auth.py                                                            ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\auth.py     ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Аутентификация и авторизация
"""
from datetime import datetime, timedelta, timezone
from typing import Optional, Annotated
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
import secrets

from . import models, schemas
from .database import get_db
from .config import settings

# Контекст для хеширования паролей
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Схема OAuth2 для получения токена
oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="/api/auth/login",
    auto_error=False  # Не вызывать ошибку автоматически
)

ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES
REFRESH_TOKEN_EXPIRE_DAYS = settings.REFRESH_TOKEN_EXPIRE_DAYS

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Проверка пароля"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Хеширование пароля"""
    # Обрезаем пароль если он слишком длинный
    if len(password) > 72:
        password = password[:72]
    return pwd_context.hash(password)

def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
    """Получение пользователя по email"""
    return db.query(models.User).filter(models.User.email == email).first()

def get_user_by_id(db: Session, user_id: int) -> Optional[models.User]:
    """Получение пользователя по ID"""
    return db.query(models.User).filter(models.User.id == user_id).first()

def authenticate_user(db: Session, email: str, password: str) -> Optional[models.User]:
    """Аутентификация пользователя"""
    user = get_user_by_email(db, email)
    if not user:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Создание access токена"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({
        "exp": expire,
        "type": "access",
        "jti": secrets.token_urlsafe(32)  # Уникальный идентификатор токена
    })
    
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Создание refresh токена"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    
    to_encode.update({
        "exp": expire,
        "type": "refresh",
        "jti": secrets.token_urlsafe(32)
    })
    
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> Optional[dict]:
    """Проверка токена"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        return payload
    except JWTError:
        return None

async def get_current_user(
    token: Annotated[str, Depends(oauth2_scheme)],
    db: Session = Depends(get_db)
) -> models.User:
    """Получение текущего пользователя из токена"""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    payload = verify_token(token)
    if payload is None:
        raise credentials_exception
    
    user_id: int = payload.get("user_id")
    token_type: str = payload.get("type")
    
    if user_id is None or token_type != "access":
        raise credentials_exception
    
    user = get_user_by_id(db, user_id)
    if user is None:
        raise credentials_exception
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User is inactive"
        )
    
    return user

async def get_current_active_user(
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)]
) -> schemas.UserResponse:
    """Проверка активности пользователя"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User is inactive"
        )
    return current_user

def check_user_role(user: models.User, allowed_roles: list) -> bool:
    """Проверка роли пользователя"""
    if user.role not in allowed_roles:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Operation not allowed for {user.role} role"
        )
    return True

# Специальные зависимости для разных ролей
async def get_current_admin(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Только администраторы"""
    check_user_role(current_user, [models.UserRole.ADMIN])
    return current_user

async def get_current_driver(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Только водители"""
    check_user_role(current_user, [models.UserRole.DRIVER])
    return current_user

async def get_current_client(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Только клиенты"""
    check_user_role(current_user, [models.UserRole.CLIENT])
    return current_user

async def get_current_client_or_admin(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Клиенты или администраторы"""
    check_user_role(current_user, [models.UserRole.CLIENT, models.UserRole.ADMIN])
    return current_user

async def get_current_driver_or_admin(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Водители или администраторы"""
    check_user_role(current_user, [models.UserRole.DRIVER, models.UserRole.ADMIN])
    return current_user
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\config.py                                                          ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\config.py   ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Конфигурация приложения
"""
from pydantic_settings import BaseSettings
from typing import List
import os
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite:///./cargopro.db")
    
    # JWT
    SECRET_KEY: str = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
    ALGORITHM: str = os.getenv("ALGORITHM", "HS256")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30"))
    REFRESH_TOKEN_EXPIRE_DAYS: int = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS", "7"))
    
    # CORS
    ALLOWED_ORIGINS: List[str] = eval(os.getenv("ALLOWED_ORIGINS", '["http://localhost:3000", "http://localhost:8080"]'))
    
    # Server
    HOST: str = os.getenv("HOST", "0.0.0.0")
    PORT: int = int(os.getenv("PORT", "8000"))
    DEBUG: bool = os.getenv("DEBUG", "True").lower() == "true"
    
    # File upload
    UPLOAD_DIR: str = os.getenv("UPLOAD_DIR", "./uploads")
    MAX_FILE_SIZE_MB: int = int(os.getenv("MAX_FILE_SIZE_MB", "10"))
    
    # Redis
    REDIS_URL: str = os.getenv("REDIS_URL", "redis://localhost:6379/0")
    
    # Email
    SMTP_SERVER: str = os.getenv("SMTP_SERVER", "")
    SMTP_PORT: int = int(os.getenv("SMTP_PORT", "587"))
    SMTP_USERNAME: str = os.getenv("SMTP_USERNAME", "")
    SMTP_PASSWORD: str = os.getenv("SMTP_PASSWORD", "")
    EMAIL_FROM: str = os.getenv("EMAIL_FROM", "noreply@cargopro.com")
    
    # Payment
    STRIPE_SECRET_KEY: str = os.getenv("STRIPE_SECRET_KEY", "")
    STRIPE_PUBLIC_KEY: str = os.getenv("STRIPE_PUBLIC_KEY", "")
    
    # Test mode
    TEST_MODE: bool = os.getenv("TEST_MODE", "False").lower() == "true"
    
    class Config:
        env_file = ".env"

settings = Settings()

# Создаем директорию для загрузок
os.makedirs(settings.UPLOAD_DIR, exist_ok=True)
os.makedirs(os.path.join(settings.UPLOAD_DIR, "drivers"), exist_ok=True)
os.makedirs(os.path.join(settings.UPLOAD_DIR, "orders"), exist_ok=True)
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\crud.py                                                            ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\crud.py     ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Операции с базой данных (CRUD)
"""
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, desc, func
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
import random
import string

from . import models, schemas
from .auth import get_password_hash
from .utils import calculate_distance

# User CRUD
def create_user(db: Session, user: schemas.UserCreate) -> models.User:
    """Создание пользователя"""
    hashed_password = get_password_hash(user.password)
    db_user = models.User(
        email=user.email,
        phone=user.phone,
        full_name=user.full_name,
        role=user.role,
        hashed_password=hashed_password
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
    """Получение пользователя по email"""
    return db.query(models.User).filter(models.User.email == email).first()

def get_user_by_id(db: Session, user_id: int) -> Optional[models.User]:
    """Получение пользователя по ID"""
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_users(
    db: Session, 
    skip: int = 0, 
    limit: int = 100,
    role: Optional[str] = None,
    is_active: Optional[bool] = None
) -> List[models.User]:
    """Получение списка пользователей"""
    query = db.query(models.User)
    
    if role:
        query = query.filter(models.User.role == role)
    if is_active is not None:
        query = query.filter(models.User.is_active == is_active)
    
    return query.order_by(models.User.created_at.desc()).offset(skip).limit(limit).all()

def update_user(
    db: Session, 
    user_id: int, 
    user_update: schemas.UserUpdate
) -> Optional[models.User]:
    """Обновление пользователя"""
    user = get_user_by_id(db, user_id)
    if not user:
        return None
    
    update_data = user_update.model_dump(exclude_unset=True)
    
    if "password" in update_data and update_data["password"]:
        update_data["hashed_password"] = get_password_hash(update_data.pop("password"))
    
    for field, value in update_data.items():
        setattr(user, field, value)
    
    db.commit()
    db.refresh(user)
    return user

def delete_user(db: Session, user_id: int) -> bool:
    """Удаление пользователя"""
    user = get_user_by_id(db, user_id)
    if not user:
        return False
    
    db.delete(user)
    db.commit()
    return True

# Driver Profile CRUD
def create_driver_profile(
    db: Session, 
    profile: schemas.DriverProfileCreate, 
    user_id: int
) -> models.DriverProfile:
    """Создание профиля водителя"""
    db_profile = models.DriverProfile(
        user_id=user_id,
        **profile.model_dump()
    )
    db.add(db_profile)
    db.commit()
    db.refresh(db_profile)
    return db_profile

def get_driver_profile(db: Session, user_id: int) -> Optional[models.DriverProfile]:
    """Получение профиля водителя"""
    return db.query(models.DriverProfile).filter(models.DriverProfile.user_id == user_id).first()

def get_driver_profiles(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    verification_status: Optional[str] = None,
    is_online: Optional[bool] = None
) -> List[models.DriverProfile]:
    """Получение списка профилей водителей"""
    query = db.query(models.DriverProfile)
    
    if verification_status:
        query = query.filter(models.DriverProfile.verification_status == verification_status)
    if is_online is not None:
        query = query.filter(models.DriverProfile.is_online == is_online)
    
    return query.order_by(desc(models.DriverProfile.rating)).offset(skip).limit(limit).all()

def update_driver_profile(
    db: Session, 
    user_id: int, 
    profile_update: schemas.DriverProfileUpdate
) -> Optional[models.DriverProfile]:
    """Обновление профиля водителя"""
    profile = get_driver_profile(db, user_id)
    if not profile:
        return None
    
    update_data = profile_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(profile, field, value)
    
    db.commit()
    db.refresh(profile)
    return profile

def update_driver_location(
    db: Session,
    user_id: int,
    lat: float,
    lng: float
) -> Optional[models.DriverProfile]:
    """Обновление местоположения водителя"""
    profile = get_driver_profile(db, user_id)
    if not profile:
        return None
    
    profile.current_location_lat = lat
    profile.current_location_lng = lng
    profile.is_online = True
    
    db.commit()
    db.refresh(profile)
    return profile

def verify_driver_profile(
    db: Session,
    user_id: int,
    status: str,
    notes: Optional[str] = None
) -> Optional[models.DriverProfile]:
    """Верификация профиля водителя"""
    profile = get_driver_profile(db, user_id)
    if not profile:
        return None
    
    profile.verification_status = status
    
    # Если верифицирован, активируем пользователя
    if status == models.VerificationStatus.VERIFIED:
        user = get_user_by_id(db, user_id)
        if user:
            user.is_verified = True
    
    db.commit()
    db.refresh(profile)
    return profile

# Order CRUD
def generate_order_number() -> str:
    """Генерация номера заказа"""
    letters = ''.join(random.choices(string.ascii_uppercase, k=2))
    numbers = ''.join(random.choices(string.digits, k=6))
    return f"CP{letters}{numbers}"

def create_order(db: Session, order: schemas.OrderCreate, client_id: int) -> models.Order:
    """Создание заказа"""
    # Расчет расстояния
    distance = calculate_distance(
        order.from_lat, order.from_lng,
        order.to_lat, order.to_lng
    )
    
    db_order = models.Order(
        order_number=generate_order_number(),
        client_id=client_id,
        distance_km=distance,
        **order.model_dump()
    )
    db.add(db_order)
    db.commit()
    db.refresh(db_order)
    return db_order

def get_order(db: Session, order_id: int) -> Optional[models.Order]:
    """Получение заказа по ID"""
    return db.query(models.Order).filter(models.Order.id == order_id).first()

def get_order_by_number(db: Session, order_number: str) -> Optional[models.Order]:
    """Получение заказа по номеру"""
    return db.query(models.Order).filter(models.Order.order_number == order_number).first()

def get_orders(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    client_id: Optional[int] = None,
    driver_id: Optional[int] = None,
    status: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    cargo_type: Optional[str] = None
) -> List[models.Order]:
    """Получение списка заказов"""
    query = db.query(models.Order)
    
    if client_id:
        query = query.filter(models.Order.client_id == client_id)
    if driver_id:
        query = query.filter(models.Order.driver_id == driver_id)
    if status:
        query = query.filter(models.Order.status == status)
    if min_price:
        query = query.filter(models.Order.desired_price >= min_price)
    if max_price:
        query = query.filter(models.Order.desired_price <= max_price)
    if cargo_type:
        query = query.filter(models.Order.cargo_type == cargo_type)
    
    return query.order_by(desc(models.Order.created_at)).offset(skip).limit(limit).all()

def get_available_orders(
    db: Session,
    driver_id: Optional[int] = None,
    skip: int = 0,
    limit: int = 100
) -> List[models.Order]:
    """Получение доступных для заказа водителей"""
    query = db.query(models.Order).filter(
        models.Order.status.in_([models.OrderStatus.SEARCHING])
    )
    
    # Если указан водитель, можно добавить фильтры по его возможностям
    if driver_id:
        driver_profile = get_driver_profile(db, driver_id)
        if driver_profile:
            # Фильтр по грузоподъемности и объему
            query = query.filter(
                models.Order.cargo_weight <= driver_profile.carrying_capacity,
                models.Order.cargo_volume <= driver_profile.volume
            )
    
    return query.order_by(desc(models.Order.created_at)).offset(skip).limit(limit).all()

def update_order(
    db: Session, 
    order_id: int, 
    order_update: schemas.OrderUpdate
) -> Optional[models.Order]:
    """Обновление заказа"""
    order = get_order(db, order_id)
    if not order:
        return None
    
    update_data = order_update.model_dump(exclude_unset=True)
    
    # Если назначается водитель, меняем статус
    if "driver_id" in update_data and update_data["driver_id"]:
        order.status = models.OrderStatus.DRIVER_ASSIGNED
    
    # Если устанавливается финальная цена, рассчитываем комиссию
    if "final_price" in update_data and update_data["final_price"]:
        order.final_price = update_data["final_price"]
        order.platform_fee = order.final_price * 0.05  # 5% комиссия
        order.order_amount = order.final_price - order.platform_fee
    
    for field, value in update_data.items():
        if field != "final_price":  # Уже обработали
            setattr(order, field, value)
    
    db.commit()
    db.refresh(order)
    return order

def complete_order(db: Session, order_id: int) -> Optional[models.Order]:
    """Завершение заказа"""
    order = get_order(db, order_id)
    if not order:
        return None
    
    order.status = models.OrderStatus.COMPLETED
    order.completed_at = datetime.utcnow()
    
    # Обновляем статистику водителя
    if order.driver_id:
        profile = get_driver_profile(db, order.driver_id)
        if profile:
            profile.total_orders += 1
            if order.distance_km:
                profile.total_distance += order.distance_km
    
    db.commit()
    db.refresh(order)
    return order

def cancel_order(db: Session, order_id: int) -> Optional[models.Order]:
    """Отмена заказа"""
    order = get_order(db, order_id)
    if not order:
        return None
    
    order.status = models.OrderStatus.CANCELLED
    
    # Отменяем все ставки по этому заказу
    bids = db.query(models.Bid).filter(models.Bid.order_id == order_id).all()
    for bid in bids:
        bid.status = models.BidStatus.CANCELLED
    
    db.commit()
    db.refresh(order)
    return order

# Bid CRUD
def create_bid(
    db: Session, 
    bid: schemas.BidCreate, 
    order_id: int, 
    driver_id: int
) -> models.Bid:
    """Создание ставки"""
    # Проверяем, что заказ доступен для ставок
    order = get_order(db, order_id)
    if not order or order.status != models.OrderStatus.SEARCHING:
        raise ValueError("Order is not available for bidding")
    
    # Проверяем, что водитель уже не делал ставку
    existing_bid = db.query(models.Bid).filter(
        models.Bid.order_id == order_id,
        models.Bid.driver_id == driver_id
    ).first()
    
    if existing_bid:
        raise ValueError("You already placed a bid on this order")
    
    db_bid = models.Bid(
        order_id=order_id,
        driver_id=driver_id,
        **bid.model_dump()
    )
    db.add(db_bid)
    db.commit()
    db.refresh(db_bid)
    return db_bid

def get_bid(db: Session, bid_id: int) -> Optional[models.Bid]:
    """Получение ставки по ID"""
    return db.query(models.Bid).filter(models.Bid.id == bid_id).first()

def get_bids_by_order(db: Session, order_id: int) -> List[models.Bid]:
    """Получение ставок по заказу"""
    return db.query(models.Bid).filter(models.Bid.order_id == order_id).all()

def get_bids_by_driver(db: Session, driver_id: int) -> List[models.Bid]:
    """Получение ставок водителя"""
    return db.query(models.Bid).filter(models.Bid.driver_id == driver_id).all()

def accept_bid(db: Session, bid_id: int) -> Optional[models.Bid]:
    """Принятие ставки"""
    bid = get_bid(db, bid_id)
    if not bid:
        return None
    
    # Обновляем статус ставки
    bid.status = models.BidStatus.ACCEPTED
    
    # Обновляем заказ
    order = get_order(db, bid.order_id)
    if order:
        order.driver_id = bid.driver_id
        order.status = models.OrderStatus.DRIVER_ASSIGNED
        order.final_price = bid.proposed_price
        order.platform_fee = bid.proposed_price * 0.05
        order.order_amount = bid.proposed_price - order.platform_fee
    
    # Отклоняем все другие ставки по этому заказу
    other_bids = db.query(models.Bid).filter(
        and_(
            models.Bid.order_id == bid.order_id,
            models.Bid.id != bid_id
        )
    ).all()
    
    for other_bid in other_bids:
        other_bid.status = models.BidStatus.REJECTED
    
    db.commit()
    db.refresh(bid)
    return bid

def reject_bid(db: Session, bid_id: int) -> Optional[models.Bid]:
    """Отклонение ставки"""
    bid = get_bid(db, bid_id)
    if not bid:
        return None
    
    bid.status = models.BidStatus.REJECTED
    db.commit()
    db.refresh(bid)
    return bid

# Message CRUD
def create_message(
    db: Session, 
    message: schemas.MessageCreate, 
    order_id: int, 
    sender_id: int
) -> models.Message:
    """Создание сообщения"""
    db_message = models.Message(
        order_id=order_id,
        sender_id=sender_id,
        **message.model_dump()
    )
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    return db_message

def get_messages_by_order(
    db: Session, 
    order_id: int, 
    skip: int = 0, 
    limit: int = 100
) -> List[models.Message]:
    """Получение сообщений по заказу"""
    return db.query(models.Message)\
        .filter(models.Message.order_id == order_id)\
        .order_by(models.Message.timestamp.asc())\
        .offset(skip)\
        .limit(limit)\
        .all()

def mark_messages_as_read(
    db: Session,
    order_id: int,
    user_id: int
) -> int:
    """Пометка сообщений как прочитанных"""
    result = db.query(models.Message)\
        .filter(
            models.Message.order_id == order_id,
            models.Message.sender_id != user_id,
            models.Message.is_read == False
        )\
        .update({"is_read": True})
    
    db.commit()
    return result

# Location CRUD
def create_location_update(
    db: Session, 
    location: schemas.LocationCreate, 
    driver_id: int
) -> models.LocationUpdate:
    """Создание обновления местоположения"""
    db_location = models.LocationUpdate(
        driver_id=driver_id,
        **location.model_dump()
    )
    db.add(db_location)
    db.commit()
    db.refresh(db_location)
    return db_location

def get_locations_by_driver(
    db: Session, 
    driver_id: int, 
    order_id: Optional[int] = None,
    limit: int = 100
) -> List[models.LocationUpdate]:
    """Получение обновлений местоположения водителя"""
    query = db.query(models.LocationUpdate)\
        .filter(models.LocationUpdate.driver_id == driver_id)
    
    if order_id:
        query = query.filter(models.LocationUpdate.order_id == order_id)
    
    return query\
        .order_by(desc(models.LocationUpdate.timestamp))\
        .limit(limit)\
        .all()

# Payment CRUD
def create_payment(
    db: Session,
    payment: schemas.PaymentCreate,
    user_id: int
) -> models.Payment:
    """Создание платежа"""
    db_payment = models.Payment(
        user_id=user_id,
        **payment.model_dump()
    )
    db.add(db_payment)
    db.commit()
    db.refresh(db_payment)
    return db_payment

def get_payment(db: Session, payment_id: int) -> Optional[models.Payment]:
    """Получение платежа по ID"""
    return db.query(models.Payment).filter(models.Payment.id == payment_id).first()

def update_payment_status(
    db: Session,
    payment_id: int,
    status: str,
    payment_id_external: Optional[str] = None
) -> Optional[models.Payment]:
    """Обновление статуса платежа"""
    payment = get_payment(db, payment_id)
    if not payment:
        return None
    
    payment.status = status
    if payment_id_external:
        payment.payment_id = payment_id_external
    
    if status == models.PaymentStatus.COMPLETED:
        payment.completed_at = datetime.utcnow()
        
        # Обновляем баланс пользователя
        user = get_user_by_id(db, payment.user_id)
        if user:
            user.balance += payment.amount
        
        # Обновляем статус заказа
        if payment.order_id:
            order = get_order(db, payment.order_id)
            if order:
                order.payment_status = models.PaymentStatus.COMPLETED
                order.status = models.OrderStatus.PAID
    
    db.commit()
    db.refresh(payment)
    return payment

# Statistics
def get_system_stats(db: Session) -> Dict[str, Any]:
    """Получение системной статистики"""
    stats = {}
    
    # Пользователи
    stats["total_users"] = db.query(func.count(models.User.id)).scalar()
    stats["total_drivers"] = db.query(func.count(models.User.id))\
        .filter(models.User.role == models.UserRole.DRIVER)\
        .scalar()
    stats["total_clients"] = db.query(func.count(models.User.id))\
        .filter(models.User.role == models.UserRole.CLIENT)\
        .scalar()
    
    # Заказы
    stats["total_orders"] = db.query(func.count(models.Order.id)).scalar()
    stats["active_orders"] = db.query(func.count(models.Order.id))\
        .filter(
            models.Order.status.in_([
                models.OrderStatus.SEARCHING,
                models.OrderStatus.DRIVER_ASSIGNED,
                models.OrderStatus.LOADING,
                models.OrderStatus.EN_ROUTE
            ])
        )\
        .scalar()
    
    # Выручка
    stats["total_revenue"] = db.query(func.coalesce(func.sum(models.Order.platform_fee), 0)).scalar() or 0
    
    # Ожидающие верификации
    stats["pending_verifications"] = db.query(func.count(models.DriverProfile.id))\
        .filter(models.DriverProfile.verification_status == models.VerificationStatus.PENDING)\
        .scalar()
    
    # За последние 7 дней
    week_ago = datetime.utcnow() - timedelta(days=7)
    
    stats["new_users_week"] = db.query(func.count(models.User.id))\
        .filter(models.User.created_at >= week_ago)\
        .scalar()
    
    stats["new_orders_week"] = db.query(func.count(models.Order.id))\
        .filter(models.Order.created_at >= week_ago)\
        .scalar()
    
    stats["revenue_week"] = db.query(func.coalesce(func.sum(models.Order.platform_fee), 0))\
        .filter(
            models.Order.created_at >= week_ago,
            models.Order.payment_status == models.PaymentStatus.COMPLETED
        )\
        .scalar() or 0
    
    return stats
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\database.py                                                        ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\database.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Подключение к базе данных
"""
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

# Создаем движок базы данных
if settings.DATABASE_URL.startswith("sqlite"):
    engine = create_engine(
        settings.DATABASE_URL, connect_args={"check_same_thread": False}
    )
else:
    engine = create_engine(settings.DATABASE_URL)

# Создаем фабрику сессий
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Базовый класс для моделей
Base = declarative_base()

# Dependency для получения сессии базы данных
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\dependencies.py                                                    ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\dependencies.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Зависимости для Dependency Injection
"""
from fastapi import Depends, HTTPException, status, Query, Header
from sqlalchemy.orm import Session
from typing import Optional
import jwt
from .config import settings
from .database import get_db
from .auth import get_current_user, get_current_admin, get_current_driver, get_current_client
from . import crud

# Зависимости для WebSocket аутентификации
async def get_websocket_user(
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """Получение пользователя для WebSocket соединения"""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token is required"
        )
    
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: int = payload.get("user_id")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )
        
        user = crud.get_user_by_id(db, user_id)
        if user is None or not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found or inactive"
            )
        
        return user
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )

async def get_websocket_driver(
    user = Depends(get_websocket_user)
):
    """Получение водителя для WebSocket соединения"""
    if user.role != "driver":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only drivers can access this endpoint"
        )
    return user

async def get_websocket_admin(
    user = Depends(get_websocket_user)
):
    """Получение администратора для WebSocket соединения"""
    if user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can access this endpoint"
        )
    return user

# Зависимости для проверки разрешений
async def check_order_access(
    order_id: int,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Проверка доступа к заказу"""
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Order not found"
        )
    
    # Администраторы имеют доступ ко всему
    if current_user.role == "admin":
        return order
    
    # Клиенты имеют доступ к своим заказам
    if current_user.role == "client" and order.client_id == current_user.id:
        return order
    
    # Водители имеют доступ к назначенным заказам
    if current_user.role == "driver" and order.driver_id == current_user.id:
        return order
    
    # Водители также имеют доступ к заказам, на которые они сделали ставки
    if current_user.role == "driver":
        bid = db.query(crud.models.Bid).filter(
            crud.models.Bid.order_id == order_id,
            crud.models.Bid.driver_id == current_user.id
        ).first()
        if bid:
            return order
    
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
        detail="You don't have access to this order"
    )

async def check_driver_verified(
    current_user = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """Проверка верификации водителя"""
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Driver profile not found"
        )
    
    if profile.verification_status != "verified":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Driver profile is not verified"
        )
    
    return current_user

# Зависимости для пагинации
class PaginationParams:
    def __init__(
        self,
        skip: int = Query(0, ge=0, description="Количество пропущенных записей"),
        limit: int = Query(100, ge=1, le=1000, description="Количество записей"),
        sort_by: str = Query("created_at", description="Поле для сортировки"),
        sort_desc: bool = Query(True, description="Сортировка по убыванию")
    ):
        self.skip = skip
        self.limit = limit
        self.sort_by = sort_by
        self.sort_desc = sort_desc

# Зависимости для фильтрации заказов
class OrderFilterParams:
    def __init__(
        self,
        status: Optional[str] = Query(None, description="Статус заказа"),
        min_price: Optional[float] = Query(None, ge=0, description="Минимальная цена"),
        max_price: Optional[float] = Query(None, ge=0, description="Максимальная цена"),
        cargo_type: Optional[str] = Query(None, description="Тип груза"),
        date_from: Optional[str] = Query(None, description="Дата от (YYYY-MM-DD)"),
        date_to: Optional[str] = Query(None, description="Дата до (YYYY-MM-DD)")
    ):
        self.status = status
        self.min_price = min_price
        self.max_price = max_price
        self.cargo_type = cargo_type
        self.date_from = date_from
        self.date_to = date_to

# Зависимости для API ключей (для интеграции)
async def verify_api_key(
    x_api_key: Optional[str] = Header(None)
):
    """Проверка API ключа для интеграций"""
    # В реальном приложении ключи должны храниться в базе данных
    valid_keys = {
        "mobile_app_key": "mobile-app-integration",
        "admin_panel_key": "admin-panel-integration",
        "website_key": "website-integration"
    }
    
    if not x_api_key or x_api_key not in valid_keys:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )
    
    return valid_keys[x_api_key]

# Зависимость для rate limiting (упрощенная версия)
class RateLimiter:
    def __init__(self):
        # В реальном приложении использовать Redis
        self.requests = {}
    
    async def __call__(self, user_id: int = Depends(get_current_user)):
        import time
        current_time = time.time()
        
        if user_id not in self.requests:
            self.requests[user_id] = []
        
        # Удаляем старые запросы (старше 1 минуты)
        self.requests[user_id] = [
            req_time for req_time in self.requests[user_id]
            if current_time - req_time < 60
        ]
        
        # Проверяем лимит (60 запросов в минуту)
        if len(self.requests[user_id]) >= 60:
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Too many requests"
            )
        
        self.requests[user_id].append(current_time)
        return user_id

# Создаем экземпляр rate limiter
rate_limiter = RateLimiter()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\file_storage.py                                                    ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\file_storage.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Работа с файловым хранилищем
"""
import os
import uuid
from pathlib import Path
from typing import Optional, Tuple
from fastapi import UploadFile, HTTPException
import shutil
from PIL import Image
import magic

from .config import settings
from .utils import is_allowed_file

class FileStorage:
    def __init__(self):
        self.base_dir = Path(settings.UPLOAD_DIR)
        self.max_size = settings.MAX_FILE_SIZE_MB * 1024 * 1024  # Конвертируем в байты
        
        # Разрешенные типы файлов
        self.allowed_extensions = {
            '.jpg', '.jpeg', '.png', '.gif',  # Изображения
            '.pdf', '.doc', '.docx',          # Документы
        }
        
        # MIME типы
        self.allowed_mime_types = {
            'image/jpeg', 'image/png', 'image/gif',
            'application/pdf', 'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        }
    
    def _generate_filename(self, original_filename: str) -> str:
        """Генерация уникального имени файла"""
        ext = Path(original_filename).suffix.lower()
        unique_id = uuid.uuid4().hex
        return f"{unique_id}{ext}"
    
    def _get_mime_type(self, file_path: str) -> str:
        """Определение MIME типа файла"""
        mime = magic.Magic(mime=True)
        return mime.from_file(file_path)
    
    def validate_file(self, file: UploadFile) -> Tuple[bool, str]:
        """Валидация файла"""
        # Проверка размера
        file.file.seek(0, 2)  # Перемещаемся в конец файла
        file_size = file.file.tell()
        file.file.seek(0)  # Возвращаемся в начало
        
        if file_size > self.max_size:
            return False, f"File size exceeds maximum allowed size ({settings.MAX_FILE_SIZE_MB}MB)"
        
        # Проверка расширения
        if not is_allowed_file(file.filename, self.allowed_extensions):
            return False, f"File type not allowed. Allowed types: {', '.join(self.allowed_extensions)}"
        
        # Сохраняем временный файл для проверки MIME типа
        temp_path = self.base_dir / f"temp_{uuid.uuid4()}.tmp"
        try:
            with open(temp_path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)
            
            # Проверка MIME типа
            mime_type = self._get_mime_type(str(temp_path))
            if mime_type not in self.allowed_mime_types:
                return False, f"MIME type {mime_type} not allowed"
            
            # Для изображений дополнительная проверка
            if mime_type.startswith('image/'):
                try:
                    with Image.open(temp_path) as img:
                        img.verify()  # Проверка целостности изображения
                except Exception as e:
                    return False, f"Invalid image file: {str(e)}"
        
        finally:
            # Удаляем временный файл
            if temp_path.exists():
                temp_path.unlink()
            
            # Возвращаем указатель файла в начало
            file.file.seek(0)
        
        return True, "File is valid"
    
    async def save_file(self, file: UploadFile, subdirectory: str, user_id: int) -> str:
        """
        Сохранение файла
        Возвращает относительный путь к файлу
        """
        # Валидация
        is_valid, message = self.validate_file(file)
        if not is_valid:
            raise HTTPException(status_code=400, detail=message)
        
        # Создание директории
        user_dir = self.base_dir / subdirectory / str(user_id)
        user_dir.mkdir(parents=True, exist_ok=True)
        
        # Генерация имени файла
        filename = self._generate_filename(file.filename)
        file_path = user_dir / filename
        
        # Сохранение файла
        try:
            with open(file_path, "wb") as buffer:
                # Для больших файлов читаем частями
                while chunk := await file.read(1024 * 1024):  # 1MB chunks
                    buffer.write(chunk)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Error saving file: {str(e)}")
        
        # Возвращаем относительный путь
        relative_path = file_path.relative_to(self.base_dir)
        return str(relative_path)
    
    def get_file_path(self, relative_path: str) -> Optional[Path]:
        """Получение полного пути к файлу"""
        file_path = self.base_dir / relative_path
        if file_path.exists() and file_path.is_file():
            return file_path
        return None
    
    def delete_file(self, relative_path: str) -> bool:
        """Удаление файла"""
        file_path = self.get_file_path(relative_path)
        if file_path:
            try:
                file_path.unlink()
                return True
            except:
                return False
        return False
    
    def save_driver_document(
        self,
        file: UploadFile,
        user_id: int,
        document_type: str
    ) -> str:
        """Сохранение документа водителя"""
        return self.save_file(file, f"drivers/{document_type}", user_id)
    
    def save_order_image(
        self,
        file: UploadFile,
        user_id: int,
        order_id: int
    ) -> str:
        """Сохранение изображения груза"""
        return self.save_file(file, f"orders/{order_id}/images", user_id)

# Глобальный экземпляр хранилища
file_storage = FileStorage()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\init.py                                                            ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\init.py     ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
CargoPro Backend Application
"""
__version__ = "1.0.0"
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\main.py                                                            ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\main.py     ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Основной файл приложения FastAPI
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.staticfiles import StaticFiles
import logging
import os

from .database import engine, Base
from .config import settings
from .routes import (
    auth_router,
    users_router,
    drivers_router,
    orders_router,
    bids_router,
    chat_router,
    track_router,
    admin_router,
    health_router,
    integration_router
)

# Настройка логирования
logging.basicConfig(
    level=logging.INFO if not settings.DEBUG else logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Создание таблиц базы данных
try:
    Base.metadata.create_all(bind=engine)
    logger.info("Database tables created successfully")
except Exception as e:
    logger.error(f"Error creating database tables: {e}")

# Создание FastAPI приложения
app = FastAPI(
    title="CargoPro Backend API",
    description="""
    🚚 Backend для платформы грузоперевозок CargoPro
    
    ## Основные возможности:
    
    ### Для клиентов:
    * 📦 Создание и управление заказами
    * 💬 Чат с водителями
    * 📍 Отслеживание груза в реальном времени
    * 💳 Оплата заказов
    
    ### Для водителей:
    * 🚗 Просмотр доступных заказов
    * 💰 Размещение ставок
    * 📍 Отправка геолокации
    * 📱 Мобильное приложение
    
    ### Для администраторов:
    * 👥 Управление пользователями
    * ✅ Верификация водителей
    * 📊 Аналитика и статистика
    * ⚙️ Системные настройки
    
    ## Интеграция:
    * 🌐 Основной сайт
    * 📱 Мобильное приложение
    * 🛠️ Админ-панель
    """,
    version="1.0.0",
    docs_url="/api/docs" if settings.DEBUG else None,
    redoc_url="/api/redoc" if settings.DEBUG else None,
    openapi_url="/api/openapi.json" if settings.DEBUG else None,
)

# Настройка CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Middleware для сжатия ответов
app.add_middleware(GZipMiddleware, minimum_size=1000)

# Подключение статических файлов (для загруженных файлов)
app.mount("/uploads", StaticFiles(directory=settings.UPLOAD_DIR), name="uploads")

# Подключение роутеров
app.include_router(auth_router)
app.include_router(users_router)
app.include_router(drivers_router)
app.include_router(orders_router)
app.include_router(bids_router)
app.include_router(chat_router)
app.include_router(track_router)
app.include_router(admin_router)
app.include_router(health_router)
app.include_router(integration_router)

# Основные эндпоинты
@app.get("/")
async def root():
    """
    Корневой эндпоинт
    """
    return {
        "message": "🚚 Добро пожаловать в CargoPro API",
        "version": "1.0.0",
        "docs": "/api/docs" if settings.DEBUG else None,
        "status": "operational",
        "services": {
            "authentication": "active",
            "orders": "active",
            "tracking": "active",
            "chat": "active",
            "payments": "active"
        }
    }

@app.get("/api")
async def api_info():
    """
    Информация о API
    """
    return {
        "name": "CargoPro API",
        "version": "1.0.0",
        "description": "API для платформы грузоперевозок CargoPro",
        "endpoints": {
            "auth": "/api/auth",
            "users": "/api/users",
            "drivers": "/api/drivers",
            "orders": "/api/orders",
            "bids": "/api/bids",
            "admin": "/api/admin",
            "health": "/health",
            "integration": "/api/integration"
        },
        "websockets": {
            "chat": "/ws/chat/{order_id}",
            "tracking": "/ws/track/{driver_id}",
            "notifications": "/ws/notifications"
        }
    }

# Middleware для логирования запросов
@app.middleware("http")
async def log_requests(request, call_next):
    """
    Middleware для логирования HTTP запросов
    """
    logger.info(f"Request: {request.method} {request.url.path}")
    response = await call_next(request)
    logger.info(f"Response: {response.status_code}")
    return response

# Обработка ошибок
@app.exception_handler(404)
async def not_found_exception_handler(request, exc):
    """
    Обработка 404 ошибок
    """
    return {
        "error": "Not Found",
        "message": "Запрошенный ресурс не найден",
        "path": request.url.path
    }

@app.exception_handler(500)
async def internal_server_error_handler(request, exc):
    """
    Обработка 500 ошибок
    """
    logger.error(f"Internal Server Error: {exc}")
    return {
        "error": "Internal Server Error",
        "message": "Внутренняя ошибка сервера",
        "request_id": request.headers.get("X-Request-ID", "unknown")
    }

# Запуск приложения (для разработки)
if __name__ == "__main__":
    import uvicorn
    
    logger.info(f"🚀 Starting CargoPro Backend on {settings.HOST}:{settings.PORT}")
    logger.info(f"📊 API Documentation: http://{settings.HOST}:{settings.PORT}/api/docs")
    logger.info(f"🔧 Debug mode: {settings.DEBUG}")
    
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level="info"
    )
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\models.py                                                          ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\models.py   ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Модели базы данных
"""
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, ForeignKey, Enum, Text, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum
from .database import Base

class UserRole(str, enum.Enum):
    CLIENT = "client"
    DRIVER = "driver"
    ADMIN = "admin"

class VerificationStatus(str, enum.Enum):
    PENDING = "pending"
    VERIFIED = "verified"
    REJECTED = "rejected"

class OrderStatus(str, enum.Enum):
    DRAFT = "draft"              # Черновик
    SEARCHING = "searching"      # Поиск водителя
    DRIVER_ASSIGNED = "driver_assigned"  # Водитель назначен
    LOADING = "loading"          # Погрузка
    EN_ROUTE = "en_route"        # В пути
    UNLOADING = "unloading"      # Разгрузка
    COMPLETED = "completed"      # Завершен
    CANCELLED = "cancelled"      # Отменен
    PAID = "paid"                # Оплачен

class BidStatus(str, enum.Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    REJECTED = "rejected"
    CANCELLED = "cancelled"

class PaymentStatus(str, enum.Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    phone = Column(String, unique=True, index=True, nullable=False)
    role = Column(Enum(UserRole), default=UserRole.CLIENT, nullable=False)
    is_active = Column(Boolean, default=True)
    is_verified = Column(Boolean, default=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=True)
    balance = Column(Float, default=0.0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    driver_profile = relationship("DriverProfile", back_populates="user", uselist=False, cascade="all, delete-orphan")
    orders_as_client = relationship("Order", foreign_keys="Order.client_id", back_populates="client")
    orders_as_driver = relationship("Order", foreign_keys="Order.driver_id", back_populates="driver")
    bids = relationship("Bid", back_populates="driver", cascade="all, delete-orphan")
    sent_messages = relationship("Message", foreign_keys="Message.sender_id", back_populates="sender")
    location_updates = relationship("LocationUpdate", back_populates="driver")
    payments = relationship("Payment", back_populates="user")

class DriverProfile(Base):
    __tablename__ = "driver_profiles"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), unique=True, nullable=False)
    vehicle_type = Column(String, nullable=False)
    vehicle_model = Column(String, nullable=True)
    vehicle_number = Column(String, nullable=False)
    carrying_capacity = Column(Float, nullable=False)  # в тоннах
    volume = Column(Float, nullable=False)  # в м³
    license_path = Column(String, nullable=True)
    passport_path = Column(String, nullable=True)
    vehicle_registration_path = Column(String, nullable=True)
    insurance_path = Column(String, nullable=True)
    verification_status = Column(Enum(VerificationStatus), default=VerificationStatus.PENDING)
    rating = Column(Float, default=0.0)
    total_orders = Column(Integer, default=0)
    total_distance = Column(Float, default=0.0)
    is_online = Column(Boolean, default=False)
    current_location_lat = Column(Float, nullable=True)
    current_location_lng = Column(Float, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="driver_profile")

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    order_number = Column(String, unique=True, index=True, nullable=False)
    client_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    driver_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    status = Column(Enum(OrderStatus), default=OrderStatus.DRAFT, nullable=False)
    
    # Address information
    from_address = Column(String, nullable=False)
    from_lat = Column(Float, nullable=False)
    from_lng = Column(Float, nullable=False)
    to_address = Column(String, nullable=False)
    to_lat = Column(Float, nullable=False)
    to_lng = Column(Float, nullable=False)
    distance_km = Column(Float, nullable=True)
    
    # Cargo details
    cargo_description = Column(String, nullable=False)
    cargo_weight = Column(Float, nullable=False)  # в тоннах
    cargo_volume = Column(Float, nullable=False)  # в м³
    cargo_type = Column(String, nullable=False)
    cargo_images = Column(JSON, nullable=True)  # Пути к изображениям груза
    
    # Price information
    desired_price = Column(Float, nullable=False)
    final_price = Column(Float, nullable=True)
    platform_fee = Column(Float, nullable=True)  # 5% комиссия
    order_amount = Column(Float, nullable=True)  # Сумма заказа (финальная цена - комиссия)
    payment_status = Column(Enum(PaymentStatus), default=PaymentStatus.PENDING)
    
    # Dates
    pickup_date = Column(DateTime, nullable=True)
    delivery_date = Column(DateTime, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    client = relationship("User", foreign_keys=[client_id], back_populates="orders_as_client")
    driver = relationship("User", foreign_keys=[driver_id], back_populates="orders_as_driver")
    bids = relationship("Bid", back_populates="order", cascade="all, delete-orphan")
    messages = relationship("Message", back_populates="order", cascade="all, delete-orphan")
    location_updates = relationship("LocationUpdate", back_populates="order", cascade="all, delete-orphan")
    payment = relationship("Payment", back_populates="order", uselist=False, cascade="all, delete-orphan")

class Bid(Base):
    __tablename__ = "bids"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id", ondelete="CASCADE"), nullable=False)
    driver_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    proposed_price = Column(Float, nullable=False)
    message = Column(String, nullable=True)
    status = Column(Enum(BidStatus), default=BidStatus.PENDING, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    order = relationship("Order", back_populates="bids")
    driver = relationship("User", back_populates="bids")

class Message(Base):
    __tablename__ = "messages"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id", ondelete="CASCADE"), nullable=False)
    sender_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    content = Column(Text, nullable=False)
    is_read = Column(Boolean, default=False)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    order = relationship("Order", back_populates="messages")
    sender = relationship("User", foreign_keys=[sender_id], back_populates="sent_messages")

class LocationUpdate(Base):
    __tablename__ = "location_updates"
    
    id = Column(Integer, primary_key=True, index=True)
    driver_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    order_id = Column(Integer, ForeignKey("orders.id", ondelete="CASCADE"), nullable=True)
    lat = Column(Float, nullable=False)
    lng = Column(Float, nullable=False)
    accuracy = Column(Float, nullable=True)
    speed = Column(Float, nullable=True)
    heading = Column(Float, nullable=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    driver = relationship("User", back_populates="location_updates")
    order = relationship("Order", back_populates="location_updates")

class Payment(Base):
    __tablename__ = "payments"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    order_id = Column(Integer, ForeignKey("orders.id"), nullable=True, unique=True)
    amount = Column(Float, nullable=False)
    currency = Column(String, default="RUB")
    status = Column(Enum(PaymentStatus), default=PaymentStatus.PENDING)
    payment_method = Column(String, nullable=True)
    payment_id = Column(String, nullable=True)  # ID платежа в платежной системе
    description = Column(String, nullable=True)
    # ИЗМЕНИТЬ НА:
    payment_metadata = Column(JSON, nullable=True)  # <-- ИСПРАВЛЕНО
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="payments")
    order = relationship("Order", back_populates="payment")

class Notification(Base):
    __tablename__ = "notifications"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    title = Column(String, nullable=False)
    message = Column(String, nullable=False)
    type = Column(String, nullable=False)  # order, payment, system, etc.
    data = Column(JSON, nullable=True)
    is_read = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    user = relationship("User")  # УБИРАЕМ `me` из этой строки
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\notifications.py                                                   ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\notifications.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Система уведомлений
"""
from typing import Dict, List, Optional
from datetime import datetime
import asyncio
import logging
from enum import Enum

from . import crud, schemas
from .websocket_manager import manager

logger = logging.getLogger(__name__)

class NotificationType(Enum):
    """Типы уведомлений"""
    # Для мобильного приложения водителей
    NEW_ORDER_AVAILABLE = "new_order_available"
    BID_ACCEPTED = "bid_accepted"
    BID_REJECTED = "bid_rejected"
    ORDER_ASSIGNED = "order_assigned"
    ORDER_UPDATED = "order_updated"
    ORDER_COMPLETED = "order_completed"
    ORDER_CANCELLED = "order_cancelled"
    
    # Для админ-панели
    NEW_DRIVER_REGISTERED = "new_driver_registered"
    NEW_ORDER_CREATED = "new_order_created"
    PAYMENT_RECEIVED = "payment_received"
    VERIFICATION_REQUIRED = "verification_required"
    
    # Для основного сайта
    DRIVER_ASSIGNED = "driver_assigned"
    ORDER_IN_PROGRESS = "order_in_progress"
    ORDER_DELIVERED = "order_delivered"
    PAYMENT_SUCCESS = "payment_success"
    PAYMENT_FAILED = "payment_failed"

class NotificationService:
    def __init__(self):
        self.notification_templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, Dict[str, str]]:
        """Загрузка шаблонов уведомлений"""
        return {
            NotificationType.NEW_ORDER_AVAILABLE.value: {
                "title": "Новый заказ доступен",
                "message": "Появился новый заказ по вашему маршруту"
            },
            NotificationType.BID_ACCEPTED.value: {
                "title": "Ваша ставка принята",
                "message": "Поздравляем! Ваша ставка на заказ была принята"
            },
            NotificationType.BID_REJECTED.value: {
                "title": "Ваша ставка отклонена",
                "message": "К сожалению, ваша ставка на заказ была отклонена"
            },
            NotificationType.ORDER_ASSIGNED.value: {
                "title": "Заказ назначен",
                "message": "Вам назначен новый заказ"
            },
            NotificationType.ORDER_UPDATED.value: {
                "title": "Заказ обновлен",
                "message": "В заказе произошли изменения"
            },
            NotificationType.ORDER_COMPLETED.value: {
                "title": "Заказ завершен",
                "message": "Заказ успешно завершен"
            },
            NotificationType.ORDER_CANCELLED.value: {
                "title": "Заказ отменен",
                "message": "Заказ был отменен"
            },
            NotificationType.NEW_DRIVER_REGISTERED.value: {
                "title": "Новый водитель",
                "message": "Зарегистрирован новый водитель"
            },
            NotificationType.NEW_ORDER_CREATED.value: {
                "title": "Новый заказ",
                "message": "Создан новый заказ на перевозку"
            },
            NotificationType.PAYMENT_RECEIVED.value: {
                "title": "Получен платеж",
                "message": "Поступила оплата за заказ"
            },
            NotificationType.VERIFICATION_REQUIRED.value: {
                "title": "Требуется верификация",
                "message": "Новый водитель ожидает верификации"
            },
            NotificationType.DRIVER_ASSIGNED.value: {
                "title": "Водитель назначен",
                "message": "На ваш заказ назначен водитель"
            },
            NotificationType.ORDER_IN_PROGRESS.value: {
                "title": "Заказ в процессе",
                "message": "Ваш заказ выполняется"
            },
            NotificationType.ORDER_DELIVERED.value: {
                "title": "Заказ доставлен",
                "message": "Ваш заказ успешно доставлен"
            },
            NotificationType.PAYMENT_SUCCESS.value: {
                "title": "Оплата успешна",
                "message": "Оплата за заказ прошла успешно"
            },
            NotificationType.PAYMENT_FAILED.value: {
                "title": "Ошибка оплаты",
                "message": "При оплате заказа произошла ошибка"
            }
        }
    
    def _get_template(self, notification_type: str) -> Dict[str, str]:
        """Получение шаблона уведомления"""
        return self.notification_templates.get(notification_type, {
            "title": "Уведомление",
            "message": "Новое уведомление"
        })
    
    async def send_notification(
        self,
        db,
        user_id: int,
        notification_type: str,
        data: Optional[Dict] = None
    ) -> schemas.NotificationResponse:
        """Отправка уведомления пользователю"""
        template = self._get_template(notification_type)
        
        # Создаем уведомление в базе данных
        notification = crud.models.Notification(
            user_id=user_id,
            title=template["title"],
            message=template["message"],
            type=notification_type,
            data=data or {}
        )
        
        db.add(notification)
        db.commit()
        db.refresh(notification)
        
        # Отправляем через WebSocket
        try:
            await manager.send_to_user(user_id, {
                "type": "notification",
                "data": {
                    "id": notification.id,
                    "title": notification.title,
                    "message": notification.message,
                    "type": notification.type,
                    "data": notification.data,
                    "is_read": notification.is_read,
                    "created_at": notification.created_at.isoformat()
                }
            })
        except Exception as e:
            logger.error(f"Error sending notification via WebSocket: {e}")
        
        return schemas.NotificationResponse.model_validate(notification)
    
    async def send_bulk_notifications(
        self,
        db,
        user_ids: List[int],
        notification_type: str,
        data: Optional[Dict] = None
    ) -> List[schemas.NotificationResponse]:
        """Массовая отправка уведомлений"""
        notifications = []
        for user_id in user_ids:
            try:
                notification = await self.send_notification(db, user_id, notification_type, data)
                notifications.append(notification)
            except Exception as e:
                logger.error(f"Error sending notification to user {user_id}: {e}")
        
        return notifications
    
    async def notify_new_order(self, db, order_id: int):
        """Уведомление о новом заказе"""
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        # Получаем водителей поблизости (упрощенная версия)
        # В реальном приложении здесь должен быть поиск по геолокации
        drivers = crud.get_driver_profiles(db, verification_status="verified", is_online=True)
        
        for driver_profile in drivers[:50]:  # Ограничиваем количество
            await self.send_notification(
                db,
                driver_profile.user_id,
                NotificationType.NEW_ORDER_AVAILABLE.value,
                {
                    "order_id": order.id,
                    "order_number": order.order_number,
                    "from_address": order.from_address,
                    "to_address": order.to_address,
                    "price": order.desired_price,
                    "distance": order.distance_km
                }
            )
        
        # Уведомление администраторов
        admins = crud.get_users(db, role="admin", is_active=True)
        for admin in admins:
            await self.send_notification(
                db,
                admin.id,
                NotificationType.NEW_ORDER_CREATED.value,
                {
                    "order_id": order.id,
                    "order_number": order.order_number,
                    "client_id": order.client_id,
                    "price": order.desired_price
                }
            )
    
    async def notify_bid_accepted(self, db, bid_id: int):
        """Уведомление о принятии ставки"""
        bid = crud.get_bid(db, bid_id)
        if not bid:
            return
        
        # Водителю
        await self.send_notification(
            db,
            bid.driver_id,
            NotificationType.BID_ACCEPTED.value,
            {
                "bid_id": bid.id,
                "order_id": bid.order_id,
                "proposed_price": bid.proposed_price
            }
        )
        
        # Клиенту
        order = crud.get_order(db, bid.order_id)
        if order:
            await self.send_notification(
                db,
                order.client_id,
                NotificationType.DRIVER_ASSIGNED.value,
                {
                    "order_id": order.id,
                    "driver_id": bid.driver_id,
                    "driver_name": bid.driver.full_name if bid.driver else None
                }
            )
    
    async def notify_order_completed(self, db, order_id: int):
        """Уведомление о завершении заказа"""
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        # Клиенту
        await self.send_notification(
            db,
            order.client_id,
            NotificationType.ORDER_DELIVERED.value,
            {
                "order_id": order.id,
                "order_number": order.order_number,
                "final_price": order.final_price
            }
        )
        
        # Водителю
        if order.driver_id:
            await self.send_notification(
                db,
                order.driver_id,
                NotificationType.ORDER_COMPLETED.value,
                {
                    "order_id": order.id,
                    "order_number": order.order_number,
                    "order_amount": order.order_amount
                }
            )
    
    async def notify_payment_success(self, db, payment_id: int):
        """Уведомление об успешной оплате"""
        payment = crud.get_payment(db, payment_id)
        if not payment:
            return
        
        # Клиенту
        await self.send_notification(
            db,
            payment.user_id,
            NotificationType.PAYMENT_SUCCESS.value,
            {
                "payment_id": payment.id,
                "amount": payment.amount,
                "order_id": payment.order_id
            }
        )
        
        # Администраторам
        admins = crud.get_users(db, role="admin", is_active=True)
        for admin in admins:
            await self.send_notification(
                db,
                admin.id,
                NotificationType.PAYMENT_RECEIVED.value,
                {
                    "payment_id": payment.id,
                    "user_id": payment.user_id,
                    "amount": payment.amount
                }
            )

# Глобальный экземпляр сервиса уведомлений
notification_service = NotificationService()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\payment.py                                                         ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\payment.py  ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Платежная система (симуляция)
"""
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import uuid
import logging
from enum import Enum

from . import schemas, crud
from .config import settings

logger = logging.getLogger(__name__)

class PaymentMethod(Enum):
    """Методы оплаты"""
    CARD = "card"
    SBP = "sbp"
    YOOMONEY = "yoomoney"
    PAYPAL = "paypal"

class PaymentGateway:
    """Платежный шлюз (симуляция)"""
    
    def __init__(self):
        self.transactions: Dict[str, Dict] = {}
    
    def create_payment(
        self,
        amount: float,
        currency: str = "RUB",
        description: str = "",
        metadata: Optional[Dict] = None
    ) -> Tuple[bool, str, Optional[str]]:
        """
        Создание платежа
        Возвращает: (успех, сообщение, payment_id)
        """
        try:
            # Генерируем ID платежа
            payment_id = f"pay_{uuid.uuid4().hex[:16]}"
            
            # В реальном приложении здесь интеграция с платежным шлюзом
            # (Stripe, YooKassa, CloudPayments и т.д.)
            
            # Сохраняем транзакцию
            self.transactions[payment_id] = {
                "payment_id": payment_id,
                "amount": amount,
                "currency": currency,
                "description": description,
                "metadata": metadata or {},
                "status": "pending",
                "created_at": datetime.utcnow().isoformat()
            }
            
            logger.info(f"Payment created: {payment_id}, amount: {amount} {currency}")
            
            return True, "Payment created successfully", payment_id
            
        except Exception as e:
            logger.error(f"Error creating payment: {e}")
            return False, f"Error creating payment: {str(e)}", None
    
    def confirm_payment(self, payment_id: str) -> Tuple[bool, str]:
        """Подтверждение платежа (симуляция)"""
        if payment_id not in self.transactions:
            return False, "Payment not found"
        
        transaction = self.transactions[payment_id]
        
        # В реальном приложении здесь проверка статуса в платежном шлюзе
        # Для симуляции всегда успех
        transaction["status"] = "succeeded"
        transaction["confirmed_at"] = datetime.utcnow().isoformat()
        
        logger.info(f"Payment confirmed: {payment_id}")
        return True, "Payment confirmed successfully"
    
    def refund_payment(self, payment_id: str, amount: Optional[float] = None) -> Tuple[bool, str]:
        """Возврат платежа (симуляция)"""
        if payment_id not in self.transactions:
            return False, "Payment not found"
        
        transaction = self.transactions[payment_id]
        
        if transaction["status"] != "succeeded":
            return False, "Payment is not succeeded"
        
        refund_amount = amount or transaction["amount"]
        
        # Создаем запись о возврате
        refund_id = f"ref_{uuid.uuid4().hex[:16]}"
        
        logger.info(f"Payment refunded: {payment_id}, amount: {refund_amount}")
        return True, f"Refund created: {refund_id}"
    
    def get_payment_status(self, payment_id: str) -> Optional[str]:
        """Получение статуса платежа"""
        if payment_id in self.transactions:
            return self.transactions[payment_id]["status"]
        return None

class PaymentService:
    """Сервис оплаты"""
    
    def __init__(self):
        self.gateway = PaymentGateway()
    
    async def create_order_payment(
        self,
        db,
        order_id: int,
        user_id: int,
        payment_method: str
    ) -> Tuple[bool, str, Optional[schemas.PaymentResponse]]:
        """Создание платежа для заказа"""
        try:
            # Получаем заказ
            order = crud.get_order(db, order_id)
            if not order:
                return False, "Order not found", None
            
            # Проверяем, что заказ принадлежит пользователю
            if order.client_id != user_id:
                return False, "Order does not belong to user", None
            
            # Проверяем, что заказ еще не оплачен
            if order.payment_status == schemas.PaymentStatus.COMPLETED:
                return False, "Order already paid", None
            
            # Проверяем финальную цену
            if not order.final_price:
                return False, "Order price is not set", None
            
            # Создаем платеж в базе данных
            payment_create = schemas.PaymentCreate(
                amount=order.final_price,
                order_id=order_id,
                payment_method=payment_method,
                description=f"Оплата заказа #{order.order_number}"
            )
            
            payment = crud.create_payment(db, payment_create, user_id)
            
            # Создаем платеж в платежном шлюзе
            success, message, gateway_payment_id = self.gateway.create_payment(
                amount=order.final_price,
                currency="RUB",
                description=f"Оплата заказа #{order.order_number}",
                metadata={
                    "order_id": order_id,
                    "order_number": order.order_number,
                    "user_id": user_id
                }
            )
            
            if success and gateway_payment_id:
                # Обновляем платеж с ID из шлюза
                payment = crud.update_payment_status(
                    db,
                    payment.id,
                    schemas.PaymentStatus.PROCESSING.value,
                    gateway_payment_id
                )
                
                # Для симуляции сразу подтверждаем платеж
                if settings.TEST_MODE:
                    self.gateway.confirm_payment(gateway_payment_id)
                    payment = crud.update_payment_status(
                        db,
                        payment.id,
                        schemas.PaymentStatus.COMPLETED.value
                    )
                
                logger.info(f"Payment created for order {order_id}: {gateway_payment_id}")
                return True, "Payment created successfully", schemas.PaymentResponse.model_validate(payment)
            else:
                # Если ошибка в шлюзе, обновляем статус
                payment = crud.update_payment_status(
                    db,
                    payment.id,
                    schemas.PaymentStatus.FAILED.value
                )
                return False, f"Payment gateway error: {message}", None
                
        except Exception as e:
            logger.error(f"Error creating payment for order {order_id}: {e}")
            return False, f"Error: {str(e)}", None
    
    async def process_payment_webhook(
        self,
        db,
        payment_id: str,
        status: str,
        metadata: Optional[Dict] = None
    ) -> Tuple[bool, str]:
        """Обработка вебхука от платежного шлюза"""
        try:
            # Находим платеж по payment_id из шлюза
            payment = db.query(crud.models.Payment).filter(
                crud.models.Payment.payment_id == payment_id
            ).first()
            
            if not payment:
                return False, "Payment not found"
            
            # Обновляем статус платежа
            payment_status = self._map_gateway_status(status)
            if not payment_status:
                return False, f"Unknown status: {status}"
            
            payment = crud.update_payment_status(db, payment.id, payment_status)
            
            logger.info(f"Payment webhook processed: {payment_id} -> {status}")
            return True, "Webhook processed successfully"
            
        except Exception as e:
            logger.error(f"Error processing payment webhook: {e}")
            return False, f"Error: {str(e)}"
    
    def _map_gateway_status(self, gateway_status: str) -> Optional[str]:
        """Маппинг статусов платежного шлюза на наши статусы"""
        status_map = {
            "succeeded": schemas.PaymentStatus.COMPLETED.value,
            "pending": schemas.PaymentStatus.PENDING.value,
            "processing": schemas.PaymentStatus.PROCESSING.value,
            "failed": schemas.PaymentStatus.FAILED.value,
            "refunded": schemas.PaymentStatus.REFUNDED.value,
        }
        return status_map.get(gateway_status.lower())
    
    async def create_payout(
        self,
        db,
        driver_id: int,
        amount: float,
        description: str = ""
    ) -> Tuple[bool, str, Optional[str]]:
        """Создание выплаты водителю"""
        try:
            # Проверяем баланс водителя
            driver = crud.get_user_by_id(db, driver_id)
            if not driver:
                return False, "Driver not found", None
            
            if driver.balance < amount:
                return False, "Insufficient balance", None
            
            # Создаем выплату в шлюзе
            success, message, payout_id = self.gateway.create_payment(
                amount=amount,
                currency="RUB",
                description=description or f"Выплата водителю #{driver_id}",
                metadata={
                    "driver_id": driver_id,
                    "type": "payout"
                }
            )
            
            if success:
                # Списание с баланса водителя
                driver.balance -= amount
                db.commit()
                
                logger.info(f"Payout created for driver {driver_id}: {amount} RUB")
                return True, "Payout created successfully", payout_id
            else:
                return False, message, None
                
        except Exception as e:
            logger.error(f"Error creating payout for driver {driver_id}: {e}")
            return False, f"Error: {str(e)}", None
    
    def get_supported_payment_methods(self) -> List[Dict]:
        """Получение списка поддерживаемых методов оплаты"""
        return [
            {
                "id": PaymentMethod.CARD.value,
                "name": "Банковская карта",
                "description": "Оплата картой Visa/Mastercard",
                "min_amount": 10.0,
                "max_amount": 100000.0,
                "currency": "RUB"
            },
            {
                "id": PaymentMethod.SBP.value,
                "name": "Система быстрых платежей (СБП)",
                "description": "Оплата через СБП по номеру телефона",
                "min_amount": 1.0,
                "max_amount": 100000.0,
                "currency": "RUB"
            },
            {
                "id": PaymentMethod.YOOMONEY.value,
                "name": "ЮMoney",
                "description": "Оплата через кошелек ЮMoney",
                "min_amount": 10.0,
                "max_amount": 75000.0,
                "currency": "RUB"
            }
        ]

# Глобальный экземпляр платежного сервиса
payment_service = PaymentService()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\__init__.py                                                 ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\__init__.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Инициализация роутеров
"""
from .auth import router as auth_router
from .users import router as users_router
from .drivers import router as drivers_router
from .orders import router as orders_router
from .bids import router as bids_router
from .chat import router as chat_router
from .track import router as track_router
from .admin import router as admin_router
from .health import router as health_router
from .integration import router as integration_router

__all__ = [
    "auth_router",
    "users_router",
    "drivers_router",
    "orders_router",
    "bids_router",
    "chat_router",
    "track_router",
    "admin_router",
    "health_router",
    "integration_router"
]
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\admin.py                                                    ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\admin.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для административных функций
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
import logging
from datetime import datetime, timedelta

from .. import schemas, crud, models
from ..auth import get_current_admin
from ..database import get_db
from ..dependencies import PaginationParams
from ..notifications import notification_service

router = APIRouter(prefix="/api/admin", tags=["admin"])
logger = logging.getLogger(__name__)

@router.get("/stats", response_model=schemas.AdminStats)
async def get_admin_stats(
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение статистики для админ-панели
    """
    stats = crud.get_system_stats(db)
    
    return schemas.AdminStats(
        total_users=stats["total_users"],
        total_drivers=stats["total_drivers"],
        total_clients=stats["total_clients"],
        total_orders=stats["total_orders"],
        total_revenue=stats["total_revenue"],
        pending_verifications=stats["pending_verifications"],
        active_orders=stats["active_orders"]
    )

@router.get("/stats/detailed")
async def get_detailed_stats(
    period: str = Query("7d", description="Период: 1d, 7d, 30d"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение детальной статистики
    """
    # Определяем период
    if period == "1d":
        days = 1
    elif period == "30d":
        days = 30
    else:  # 7d по умолчанию
        days = 7
    
    start_date = datetime.utcnow() - timedelta(days=days)
    
    # Статистика пользователей
    new_users = db.query(models.User).filter(
        models.User.created_at >= start_date
    ).count()
    
    new_drivers = db.query(models.User).filter(
        models.User.role == models.UserRole.DRIVER,
        models.User.created_at >= start_date
    ).count()
    
    new_clients = db.query(models.User).filter(
        models.User.role == models.UserRole.CLIENT,
        models.User.created_at >= start_date
    ).count()
    
    # Статистика заказов
    new_orders = db.query(models.Order).filter(
        models.Order.created_at >= start_date
    ).count()
    
    completed_orders = db.query(models.Order).filter(
        models.Order.status == models.OrderStatus.COMPLETED,
        models.Order.updated_at >= start_date
    ).count()
    
    cancelled_orders = db.query(models.Order).filter(
        models.Order.status == models.OrderStatus.CANCELLED,
        models.Order.updated_at >= start_date
    ).count()
    
    # Финансовая статистика
    revenue = db.query(models.Order).filter(
        models.Order.status.in_([models.OrderStatus.COMPLETED, models.OrderStatus.PAID]),
        models.Order.updated_at >= start_date
    ).all()
    
    total_revenue = sum(order.platform_fee or 0 for order in revenue)
    total_order_amount = sum(order.final_price or 0 for order in revenue)
    
    # Статистика по дням
    daily_stats = []
    for i in range(days):
        day = start_date + timedelta(days=i)
        next_day = day + timedelta(days=1)
        
        daily_orders = db.query(models.Order).filter(
            models.Order.created_at >= day,
            models.Order.created_at < next_day
        ).count()
        
        daily_revenue = db.query(models.Order).filter(
            models.Order.status.in_([models.OrderStatus.COMPLETED, models.OrderStatus.PAID]),
            models.Order.updated_at >= day,
            models.Order.updated_at < next_day
        ).all()
        
        daily_total_revenue = sum(order.platform_fee or 0 for order in daily_revenue)
        
        daily_stats.append({
            "date": day.strftime("%Y-%m-%d"),
            "orders": daily_orders,
            "revenue": daily_total_revenue
        })
    
    return {
        "period": period,
        "start_date": start_date.isoformat(),
        "end_date": datetime.utcnow().isoformat(),
        "users": {
            "new_users": new_users,
            "new_drivers": new_drivers,
            "new_clients": new_clients,
            "total_users": stats["total_users"]
        },
        "orders": {
            "new_orders": new_orders,
            "completed_orders": completed_orders,
            "cancelled_orders": cancelled_orders,
            "active_orders": stats["active_orders"],
            "total_orders": stats["total_orders"]
        },
        "financial": {
            "total_revenue": total_revenue,
            "total_order_amount": total_order_amount,
            "avg_order_value": total_order_amount / len(revenue) if revenue else 0,
            "platform_fee_percentage": 5.0  # 5% комиссия
        },
        "daily_stats": daily_stats
    }

@router.get("/verifications/pending")
async def get_pending_verifications(
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение списка водителей, ожидающих верификации
    """
    profiles = crud.get_driver_profiles(
        db,
        skip=pagination.skip,
        limit=pagination.limit,
        verification_status=models.VerificationStatus.PENDING.value
    )
    
    result = []
    for profile in profiles:
        result.append({
            "user": schemas.UserResponse.model_validate(profile.user),
            "profile": schemas.DriverProfileResponse.model_validate(profile),
            "documents": {
                "license": bool(profile.license_path),
                "passport": bool(profile.passport_path),
                "vehicle_registration": bool(profile.vehicle_registration_path),
                "insurance": bool(profile.insurance_path)
            },
            "days_waiting": (datetime.utcnow() - profile.created_at).days
        })
    
    return result

@router.post("/verifications/{driver_id}")
async def verify_driver(
    driver_id: int,
    verification: schemas.VerificationRequest,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Верификация профиля водителя
    """
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Профиль водителя не найден"
        )
    
    if profile.verification_status != models.VerificationStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Профиль водителя уже верифицирован или отклонен"
        )
    
    # Обновление статуса верификации
    profile.verification_status = verification.status
    db.commit()
    db.refresh(profile)
    
    # Обновление статуса пользователя
    user = crud.get_user_by_id(db, driver_id)
    if user:
        user.is_verified = (verification.status == models.VerificationStatus.VERIFIED)
        db.commit()
    
    # Отправка уведомления водителю
    background_tasks.add_task(
        notify_driver_about_verification,
        db,
        driver_id,
        verification.status,
        verification.notes
    )
    
    logger.info(f"Driver {driver_id} verification updated to {verification.status} by admin {current_user.email}")
    
    return {
        "message": f"Статус верификации обновлен на {verification.status.value}",
        "driver_id": driver_id,
        "status": verification.status.value,
        "verified_by": current_user.email
    }

@router.get("/recent-activity")
async def get_recent_activity(
    limit: int = Query(50, ge=1, le=200, description="Количество записей"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение недавней активности в системе
    """
    activities = []
    
    # Недавние заказы
    recent_orders = db.query(models.Order)\
        .order_by(models.Order.created_at.desc())\
        .limit(limit // 3)\
        .all()
    
    for order in recent_orders:
        activities.append({
            "type": "order_created",
            "timestamp": order.created_at,
            "data": {
                "order_id": order.id,
                "order_number": order.order_number,
                "client_id": order.client_id,
                "client_email": order.client.email,
                "status": order.status.value,
                "price": order.desired_price
            }
        })
    
    # Недавние регистрации
    recent_users = db.query(models.User)\
        .order_by(models.User.created_at.desc())\
        .limit(limit // 3)\
        .all()
    
    for user in recent_users:
        activities.append({
            "type": "user_registered",
            "timestamp": user.created_at,
            "data": {
                "user_id": user.id,
                "email": user.email,
                "role": user.role.value,
                "phone": user.phone
            }
        })
    
    # Недавние платежи
    recent_payments = db.query(models.Payment)\
        .order_by(models.Payment.created_at.desc())\
        .limit(limit // 3)\
        .all()
    
    for payment in recent_payments:
        activities.append({
            "type": "payment_processed",
            "timestamp": payment.created_at,
            "data": {
                "payment_id": payment.id,
                "user_id": payment.user_id,
                "user_email": payment.user.email,
                "amount": payment.amount,
                "status": payment.status.value,
                "order_id": payment.order_id
            }
        })
    
    # Сортировка по времени
    activities.sort(key=lambda x: x["timestamp"], reverse=True)
    
    # Ограничение количества
    activities = activities[:limit]
    
    return activities

@router.get("/financial/transactions")
async def get_financial_transactions(
    start_date: Optional[str] = Query(None, description="Дата начала (YYYY-MM-DD)"),
    end_date: Optional[str] = Query(None, description="Дата окончания (YYYY-MM-DD)"),
    status: Optional[str] = Query(None, description="Статус платежа"),
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение финансовых транзакций
    """
    query = db.query(models.Payment)
    
    # Фильтрация по дате
    if start_date:
        try:
            start = datetime.strptime(start_date, "%Y-%m-%d")
            query = query.filter(models.Payment.created_at >= start)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Неверный формат даты начала"
            )
    
    if end_date:
        try:
            end = datetime.strptime(end_date, "%Y-%m-%d") + timedelta(days=1)
            query = query.filter(models.Payment.created_at < end)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Неверный формат даты окончания"
            )
    
    # Фильтрация по статусу
    if status:
        query = query.filter(models.Payment.status == status)
    
    # Получение транзакций
    payments = query.order_by(models.Payment.created_at.desc())\
                   .offset(pagination.skip)\
                   .limit(pagination.limit)\
                   .all()
    
    # Расчет статистики
    total_amount = sum(p.amount for p in payments)
    completed_amount = sum(p.amount for p in payments if p.status == models.PaymentStatus.COMPLETED)
    pending_amount = sum(p.amount for p in payments if p.status == models.PaymentStatus.PENDING)
    
    return {
        "transactions": payments,
        "statistics": {
            "total_count": len(payments),
            "total_amount": total_amount,
            "completed_amount": completed_amount,
            "pending_amount": pending_amount,
            "completed_count": len([p for p in payments if p.status == models.PaymentStatus.COMPLETED]),
            "pending_count": len([p for p in payments if p.status == models.PaymentStatus.PENDING])
        }
    }

@router.get("/orders/analytics")
async def get_orders_analytics(
    period: str = Query("30d", description="Период: 7d, 30d, 90d"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Аналитика по заказам
    """
    # Определяем период
    if period == "7d":
        days = 7
    elif period == "90d":
        days = 90
    else:  # 30d по умолчанию
        days = 30
    
    start_date = datetime.utcnow() - timedelta(days=days)
    
    # Получаем все заказы за период
    orders = db.query(models.Order).filter(
        models.Order.created_at >= start_date
    ).all()
    
    if not orders:
        return {
            "period": period,
            "total_orders": 0,
            "analytics": {}
        }
    
    # Аналитика по статусам
    status_counts = {}
    for status in models.OrderStatus:
        status_counts[status.value] = len([o for o in orders if o.status == status])
    
    # Аналитика по типам груза
    cargo_types = {}
    for order in orders:
        cargo_type = order.cargo_type
        if cargo_type not in cargo_types:
            cargo_types[cargo_type] = 0
        cargo_types[cargo_type] += 1
    
    # Аналитика по ценам
    prices = [o.final_price or o.desired_price for o in orders if o.final_price or o.desired_price]
    avg_price = sum(prices) / len(prices) if prices else 0
    min_price = min(prices) if prices else 0
    max_price = max(prices) if prices else 0
    
    # Аналитика по расстояниям
    distances = [o.distance_km for o in orders if o.distance_km]
    avg_distance = sum(distances) / len(distances) if distances else 0
    
    # Топ клиентов
    client_orders = {}
    for order in orders:
        client_id = order.client_id
        if client_id not in client_orders:
            client_orders[client_id] = 0
        client_orders[client_id] += 1
    
    top_clients = sorted(client_orders.items(), key=lambda x: x[1], reverse=True)[:10]
    top_clients_details = []
    for client_id, order_count in top_clients:
        client = crud.get_user_by_id(db, client_id)
        if client:
            top_clients_details.append({
                "client_id": client_id,
                "email": client.email,
                "full_name": client.full_name,
                "order_count": order_count
            })
    
    # Топ водителей
    driver_orders = {}
    for order in orders:
        if order.driver_id:
            driver_id = order.driver_id
            if driver_id not in driver_orders:
                driver_orders[driver_id] = 0
            driver_orders[driver_id] += 1
    
    top_drivers = sorted(driver_orders.items(), key=lambda x: x[1], reverse=True)[:10]
    top_drivers_details = []
    for driver_id, order_count in top_drivers:
        driver = crud.get_user_by_id(db, driver_id)
        driver_profile = crud.get_driver_profile(db, driver_id)
        if driver:
            top_drivers_details.append({
                "driver_id": driver_id,
                "email": driver.email,
                "full_name": driver.full_name,
                "vehicle_number": driver_profile.vehicle_number if driver_profile else None,
                "order_count": order_count
            })
    
    return {
        "period": period,
        "total_orders": len(orders),
        "analytics": {
            "by_status": status_counts,
            "by_cargo_type": cargo_types,
            "price_statistics": {
                "average": round(avg_price, 2),
                "minimum": round(min_price, 2),
                "maximum": round(max_price, 2),
                "total_revenue": sum([o.platform_fee or 0 for o in orders])
            },
            "distance_statistics": {
                "average_km": round(avg_distance, 2),
                "total_km": sum(distances)
            },
            "top_clients": top_clients_details,
            "top_drivers": top_drivers_details
        }
    }

@router.post("/system/announcement")
async def create_system_announcement(
    announcement: dict,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Создание системного объявления
    """
    title = announcement.get("title", "")
    message = announcement.get("message", "")
    target = announcement.get("target", "all")  # all, clients, drivers
    
    if not title or not message:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Заголовок и сообщение обязательны"
        )
    
    # Определяем целевых пользователей
    if target == "clients":
        users = crud.get_users(db, role=models.UserRole.CLIENT.value, is_active=True)
    elif target == "drivers":
        users = crud.get_users(db, role=models.UserRole.DRIVER.value, is_active=True)
    else:  # all
        users = crud.get_users(db, is_active=True)
    
    # Отправляем уведомления
    user_ids = [user.id for user in users]
    
    background_tasks.add_task(
        send_bulk_notifications,
        db,
        user_ids,
        "system_announcement",
        {"title": title, "message": message, "from_admin": current_user.email}
    )
    
    logger.info(f"System announcement created by {current_user.email}: {title}")
    
    return {
        "message": "Объявление отправлено",
        "recipients_count": len(user_ids),
        "target": target,
        "title": title
    }

@router.get("/system/logs")
async def get_system_logs(
    level: Optional[str] = Query(None, description="Уровень логирования: INFO, WARNING, ERROR"),
    search: Optional[str] = Query(None, description="Поиск по сообщению"),
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение системных логов (симуляция - в реальном приложении нужно использовать ELK или подобное)
    """
    # В реальном приложении здесь должен быть запрос к системе логирования
    # Для примера возвращаем mock данные
    
    mock_logs = [
        {
            "timestamp": datetime.utcnow().isoformat(),
            "level": "INFO",
            "message": "Система запущена",
            "source": "system"
        },
        {
            "timestamp": (datetime.utcnow() - timedelta(hours=1)).isoformat(),
            "level": "INFO",
            "message": "Новый пользователь зарегистрирован",
            "source": "auth",
            "user_id": 1
        },
        {
            "timestamp": (datetime.utcnow() - timedelta(hours=2)).isoformat(),
            "level": "WARNING",
            "message": "Попытка входа с неверным паролем",
            "source": "auth",
            "user_email": "test@example.com"
        },
        {
            "timestamp": (datetime.utcnow() - timedelta(hours=3)).isoformat(),
            "level": "ERROR",
            "message": "Ошибка при обработке платежа",
            "source": "payment",
            "payment_id": 123
        }
    ]
    
    # Фильтрация
    if level:
        mock_logs = [log for log in mock_logs if log["level"] == level]
    
    if search:
        mock_logs = [log for log in mock_logs if search.lower() in log["message"].lower()]
    
    # Пагинация
    total = len(mock_logs)
    logs = mock_logs[pagination.skip:pagination.skip + pagination.limit]
    
    return {
        "logs": logs,
        "total": total,
        "page": pagination.skip // pagination.limit + 1,
        "pages": (total + pagination.limit - 1) // pagination.limit
    }

# Вспомогательные функции
async def notify_driver_about_verification(
    db: Session,
    driver_id: int,
    status: str,
    notes: Optional[str] = None
):
    """Уведомление водителя о результате верификации"""
    try:
        notification_type = "driver_verified" if status == models.VerificationStatus.VERIFIED else "driver_rejected"
        
        await notification_service.send_notification(
            db,
            driver_id,
            notification_type,
            {
                "status": status,
                "notes": notes,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
    except Exception as e:
        logger.error(f"Error notifying driver about verification: {e}")

async def send_bulk_notifications(
    db: Session,
    user_ids: List[int],
    notification_type: str,
    data: dict
):
    """Массовая отправка уведомлений"""
    try:
        await notification_service.send_bulk_notifications(
            db,
            user_ids,
            notification_type,
            data
        )
        logger.info(f"Bulk notifications sent to {len(user_ids)} users: {notification_type}")
    except Exception as e:
        logger.error(f"Error sending bulk notifications: {e}")
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\auth.py                                                     ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\auth.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для аутентификации
"""
from datetime import timedelta
from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
import logging

from .. import schemas, crud
from ..auth import (
    authenticate_user, create_access_token, create_refresh_token,
    verify_token, get_current_user, ACCESS_TOKEN_EXPIRE_MINUTES,
    get_password_hash
)
from ..database import get_db
from ..notifications import notification_service

router = APIRouter(prefix="/api/auth", tags=["authentication"])
logger = logging.getLogger(__name__)

@router.post("/register", response_model=schemas.UserResponse)
async def register(
    user: schemas.UserCreate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    Регистрация нового пользователя
    """
    # Проверка существования пользователя
    db_user = crud.get_user_by_email(db, email=user.email)
    if db_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email уже зарегистрирован"
        )
    
    # Проверка номера телефона
    db_user_by_phone = db.query(crud.models.User).filter(
        crud.models.User.phone == user.phone
    ).first()
    
    if db_user_by_phone:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Номер телефона уже зарегистрирован"
        )
    
    # Обрезаем пароль если слишком длинный
    if len(user.password) > 72:
        user.password = user.password[:72]
    
    try:
        # Создание пользователя
        created_user = crud.create_user(db=db, user=user)
        
        # Если это водитель, отправляем уведомление администраторам
        if user.role == schemas.UserRole.DRIVER:
            background_tasks.add_task(
                notify_admins_about_new_driver,
                db,
                created_user.id
            )
        
        logger.info(f"User registered: {created_user.email}, role: {created_user.role}")
        
        return created_user
        
    except Exception as e:
        logger.error(f"Error during registration: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка регистрации: {str(e)}"
        )

@router.post("/login", response_model=schemas.Token)
async def login(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    db: Session = Depends(get_db)
):
    """
    Вход в систему
    """
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный email или пароль",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Пользователь неактивен"
        )
    
    # Создание токенов
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"user_id": user.id, "email": user.email, "role": user.role.value},
        expires_delta=access_token_expires
    )
    refresh_token = create_refresh_token(
        data={"user_id": user.id, "email": user.email, "role": user.role.value}
    )
    
    logger.info(f"User logged in: {user.email}, role: {user.role}")
    
    return schemas.Token(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        user=schemas.UserResponse.model_validate(user)
    )

@router.post("/refresh", response_model=schemas.Token)
async def refresh_token(
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Обновление access токена с помощью refresh токена
    """
    refresh_token = data.get("refresh_token")
    if not refresh_token:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Refresh token is required"
        )
    
    payload = verify_token(refresh_token)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный refresh токен"
        )
    
    token_type = payload.get("type")
    if token_type != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный тип токена"
        )
    
    user_id = payload.get("user_id")
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Пользователь не найден"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Пользователь неактивен"
        )
    
    # Создание новых токенов
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"user_id": user.id, "email": user.email, "role": user.role.value},
        expires_delta=access_token_expires
    )
    new_refresh_token = create_refresh_token(
        data={"user_id": user.id, "email": user.email, "role": user.role.value}
    )
    
    logger.info(f"Token refreshed for user: {user.email}")
    
    return schemas.Token(
        access_token=access_token,
        refresh_token=new_refresh_token,
        token_type="bearer",
        user=schemas.UserResponse.model_validate(user)
    )

@router.get("/me", response_model=schemas.UserResponse)
async def get_current_user_info(
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)]
):
    """
    Получение информации о текущем пользователе
    """
    return current_user

@router.post("/change-password")
async def change_password(
    password_data: schemas.UserUpdate,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    Смена пароля
    """
    if not password_data.password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Новый пароль не указан"
        )
    
    # Обновляем пароль
    hashed_password = get_password_hash(password_data.password)
    current_user.hashed_password = hashed_password
    db.commit()
    
    logger.info(f"Password changed for user: {current_user.email}")
    
    return {"message": "Пароль успешно изменен"}

@router.post("/reset-password-request")
async def reset_password_request(
    data: dict,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    Запрос на сброс пароля
    """
    email = data.get("email")
    if not email:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email is required"
        )
    
    user = crud.get_user_by_email(db, email)
    if not user:
        # Для безопасности не раскрываем, существует ли пользователь
        return {"message": "Если пользователь с таким email существует, инструкции отправлены на почту"}
    
    # Генерируем токен сброса пароля
    reset_token = create_access_token(
        data={"user_id": user.id, "purpose": "password_reset"},
        expires_delta=timedelta(hours=1)
    )
    
    # В реальном приложении здесь отправка email
    # background_tasks.add_task(send_password_reset_email, user.email, reset_token)
    
    logger.info(f"Password reset requested for user: {user.email}")
    
    return {"message": "Если пользователь с таким email существует, инструкции отправлены на почту"}

@router.post("/reset-password")
async def reset_password(
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Сброс пароля с использованием токена
    """
    token = data.get("token")
    new_password = data.get("new_password")
    
    if not token or not new_password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Token and new password are required"
        )
    
    payload = verify_token(token)
    if not payload or payload.get("purpose") != "password_reset":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Неверный или просроченный токен"
        )
    
    user_id = payload.get("user_id")
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    # Обновляем пароль
    hashed_password = get_password_hash(new_password)
    user.hashed_password = hashed_password
    db.commit()
    
    logger.info(f"Password reset for user: {user.email}")
    
    return {"message": "Пароль успешно изменен"}

# Вспомогательные функции
async def notify_admins_about_new_driver(db: Session, driver_id: int):
    """
    Уведомление администраторов о новом водителе
    """
    try:
        admins = crud.get_users(db, role="admin", is_active=True)
        for admin in admins:
            await notification_service.send_notification(
                db,
                admin.id,
                "new_driver_registered",
                {"driver_id": driver_id}
            )
    except Exception as e:
        logger.error(f"Error notifying admins about new driver: {e}")
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\bids.py                                                     ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\bids.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для работы со ставками
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List
import logging

from .. import schemas, crud, models
from ..auth import get_current_active_user, get_current_driver, get_current_client_or_admin
from ..database import get_db
from ..dependencies import PaginationParams
from ..notifications import notification_service

router = APIRouter(prefix="/api/bids", tags=["bids"])
logger = logging.getLogger(__name__)

@router.post("/order/{order_id}", response_model=schemas.BidResponse)
async def create_bid(
    order_id: int,
    bid: schemas.BidCreate,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Создание ставки на заказ
    """
    # Проверка верификации водителя
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile or profile.verification_status != models.VerificationStatus.VERIFIED:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Профиль водителя не верифицирован"
        )
    
    # Проверка заказа
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка статуса заказа
    if order.status != models.OrderStatus.SEARCHING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Заказ не доступен для ставок"
        )
    
    # Проверка, не делает ли водитель ставку на свой же заказ
    if order.client_id == current_user.id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Нельзя делать ставку на свой собственный заказ"
        )
    
    # Проверка, не делал ли уже водитель ставку на этот заказ
    existing_bid = db.query(models.Bid).filter(
        models.Bid.order_id == order_id,
        models.Bid.driver_id == current_user.id
    ).first()
    
    if existing_bid:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Вы уже сделали ставку на этот заказ"
        )
    
    # Проверка, подходит ли водитель по параметрам груза
    if (order.cargo_weight > profile.carrying_capacity or 
        order.cargo_volume > profile.volume):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Ваш транспорт не подходит для этого груза. "
                  f"Требуется: до {order.cargo_weight}т, {order.cargo_volume}м³. "
                  f"Ваши возможности: {profile.carrying_capacity}т, {profile.volume}м³"
        )
    
    try:
        # Создаем ставку
        created_bid = crud.create_bid(db, bid, order_id, current_user.id)
        
        # Уведомляем клиента о новой ставке
        background_tasks.add_task(
            notify_client_about_new_bid,
            db,
            order_id,
            created_bid.id
        )
        
        logger.info(f"Bid created: ID {created_bid.id} for order {order_id} by driver {current_user.email}")
        
        return created_bid
        
    except ValueError as e:
        logger.error(f"Error creating bid: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error creating bid: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка при создании ставки: {str(e)}"
        )

@router.get("/order/{order_id}", response_model=List[schemas.BidResponse])
async def get_order_bids(
    order_id: int,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Получение списка ставок для заказа
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    has_access = False
    
    if current_user.role == models.UserRole.ADMIN:
        has_access = True
    elif current_user.role == models.UserRole.CLIENT and order.client_id == current_user.id:
        has_access = True
    elif current_user.role == models.UserRole.DRIVER and order.driver_id == current_user.id:
        has_access = True
    
    if not has_access:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к ставкам запрещен"
        )
    
    # Получаем ставки
    bids = crud.get_bids_by_order(db, order_id)
    
    # Если это водитель, показываем только его ставки
    if current_user.role == models.UserRole.DRIVER and order.client_id != current_user.id:
        bids = [bid for bid in bids if bid.driver_id == current_user.id]
    
    return bids

@router.get("/my", response_model=List[schemas.BidResponse])
async def get_my_bids(
    pagination: PaginationParams = Depends(),
    status: str = Query(None, description="Фильтр по статусу"),
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Получение списка ставок текущего водителя
    """
    query = db.query(models.Bid).filter(
        models.Bid.driver_id == current_user.id
    )
    
    if status:
        query = query.filter(models.Bid.status == status)
    
    bids = query.order_by(models.Bid.created_at.desc())\
               .offset(pagination.skip)\
               .limit(pagination.limit)\
               .all()
    
    return bids

@router.get("/{bid_id}", response_model=schemas.BidResponse)
async def get_bid(
    bid_id: int,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Получение информации о ставке
    """
    bid = crud.get_bid(db, bid_id)
    if not bid:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ставка не найдена"
        )
    
    # Проверка прав доступа
    has_access = False
    
    if current_user.role == models.UserRole.ADMIN:
        has_access = True
    elif current_user.role == models.UserRole.CLIENT and bid.order.client_id == current_user.id:
        has_access = True
    elif current_user.role == models.UserRole.DRIVER and bid.driver_id == current_user.id:
        has_access = True
    
    if not has_access:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к ставке запрещен"
        )
    
    return bid

@router.post("/{bid_id}/accept", response_model=schemas.BidResponse)
async def accept_bid(
    bid_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_client_or_admin),
    db: Session = Depends(get_db)
):
    """
    Принятие ставки (для клиента или администратора)
    """
    bid = crud.get_bid(db, bid_id)
    if not bid:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ставка не найдена"
        )
    
    order = crud.get_order(db, bid.order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Только владелец заказа может принимать ставки"
        )
    
    if bid.status != models.BidStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Невозможно принять эту ставку"
        )
    
    if order.status != models.OrderStatus.SEARCHING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Заказ не доступен для принятия ставок"
        )
    
    try:
        # Принимаем ставку
        accepted_bid = crud.accept_bid(db, bid_id)
        
        if not accepted_bid:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Ошибка при принятии ставки"
            )
        
        # Уведомляем водителя о принятии ставки
        background_tasks.add_task(
            notification_service.notify_bid_accepted,
            db,
            bid_id
        )
        
        logger.info(f"Bid accepted: ID {bid_id} for order {order.id}")
        
        return accepted_bid
        
    except Exception as e:
        logger.error(f"Error accepting bid: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка при принятии ставки: {str(e)}"
        )

@router.post("/{bid_id}/reject")
async def reject_bid(
    bid_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_client_or_admin),
    db: Session = Depends(get_db)
):
    """
    Отклонение ставки (для клиента или администратора)
    """
    bid = crud.get_bid(db, bid_id)
    if not bid:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ставка не найдена"
        )
    
    order = crud.get_order(db, bid.order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Только владелец заказа может отклонять ставки"
        )
    
    if bid.status != models.BidStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Невозможно отклонить эту ставку"
        )
    
    # Отклоняем ставку
    rejected_bid = crud.reject_bid(db, bid_id)
    
    # Уведомляем водителя об отклонении ставки
    background_tasks.add_task(
        notify_driver_about_bid_rejection,
        db,
        bid_id
    )
    
    logger.info(f"Bid rejected: ID {bid_id} by user {current_user.email}")
    
    return {"message": "Ставка отклонена", "bid": rejected_bid}

@router.post("/{bid_id}/cancel")
async def cancel_bid(
    bid_id: int,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Отмена ставки (для водителя)
    """
    bid = crud.get_bid(db, bid_id)
    if not bid:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ставка не найдена"
        )
    
    if bid.driver_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Только автор ставки может ее отменить"
        )
    
    if bid.status != models.BidStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Невозможно отменить эту ставку"
        )
    
    # Отменяем ставку
    bid.status = models.BidStatus.CANCELLED
    db.commit()
    db.refresh(bid)
    
    logger.info(f"Bid cancelled: ID {bid_id} by driver {current_user.email}")
    
    return {"message": "Ставка отменена", "bid": bid}

@router.get("/stats/my")
async def get_my_bids_stats(
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Получение статистики по ставкам текущего водителя
    """
    bids = crud.get_bids_by_driver(db, current_user.id)
    
    total_bids = len(bids)
    accepted_bids = len([b for b in bids if b.status == models.BidStatus.ACCEPTED])
    pending_bids = len([b for b in bids if b.status == models.BidStatus.PENDING])
    rejected_bids = len([b for b in bids if b.status == models.BidStatus.REJECTED])
    
    # Рассчитываем успешность ставок
    success_rate = (accepted_bids / total_bids * 100) if total_bids > 0 else 0
    
    # Средняя предложенная цена
    accepted_prices = [b.proposed_price for b in bids if b.status == models.BidStatus.ACCEPTED]
    avg_accepted_price = sum(accepted_prices) / len(accepted_prices) if accepted_prices else 0
    
    stats = {
        "total_bids": total_bids,
        "accepted_bids": accepted_bids,
        "pending_bids": pending_bids,
        "rejected_bids": rejected_bids,
        "success_rate": round(success_rate, 2),
        "avg_accepted_price": round(avg_accepted_price, 2),
        "total_earnings": sum(accepted_prices) if accepted_prices else 0
    }
    
    return stats

@router.get("/order/{order_id}/best")
async def get_best_bids(
    order_id: int,
    limit: int = Query(5, ge=1, le=20, description="Количество лучших ставок"),
    current_user: schemas.UserResponse = Depends(get_current_client_or_admin),
    db: Session = Depends(get_db)
):
    """
    Получение лучших ставок для заказа (по цене и рейтингу водителя)
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к ставкам запрещен"
        )
    
    # Получаем все ставки для заказа
    bids = crud.get_bids_by_order(db, order_id)
    
    if not bids:
        return {"bids": [], "count": 0}
    
    # Фильтруем только pending ставки
    pending_bids = [b for b in bids if b.status == models.BidStatus.PENDING]
    
    if not pending_bids:
        return {"bids": [], "count": 0}
    
    # Получаем информацию о водителях
    best_bids = []
    for bid in pending_bids:
        driver_profile = crud.get_driver_profile(db, bid.driver_id)
        if driver_profile:
            # Рассчитываем скоринг ставки (ниже цена + выше рейтинг = лучше)
            price_score = 1 / bid.proposed_price  # Чем ниже цена, тем выше скоринг
            rating_score = driver_profile.rating / 5.0  # Нормализованный рейтинг
            
            # Комбинированный скоринг (70% цена, 30% рейтинг)
            total_score = price_score * 0.7 + rating_score * 0.3
            
            best_bids.append({
                "bid": schemas.BidResponse.model_validate(bid),
                "driver_rating": driver_profile.rating,
                "driver_total_orders": driver_profile.total_orders,
                "driver_verification_status": driver_profile.verification_status.value,
                "score": total_score
            })
    
    # Сортируем по скорингу
    best_bids.sort(key=lambda x: x["score"], reverse=True)
    
    # Ограничиваем количество
    best_bids = best_bids[:limit]
    
    return {
        "bids": best_bids,
        "count": len(best_bids),
        "order_price": order.desired_price,
        "cheapest_bid": min([b["bid"].proposed_price for b in best_bids]) if best_bids else None,
        "avg_bid": sum([b["bid"].proposed_price for b in best_bids]) / len(best_bids) if best_bids else None
    }

# Вспомогательные функции
async def notify_client_about_new_bid(db: Session, order_id: int, bid_id: int):
    """Уведомление клиента о новой ставке"""
    try:
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        bid = crud.get_bid(db, bid_id)
        if not bid:
            return
        
        await notification_service.send_notification(
            db,
            order.client_id,
            "new_bid_received",
            {
                "order_id": order_id,
                "order_number": order.order_number,
                "bid_id": bid_id,
                "driver_id": bid.driver_id,
                "proposed_price": bid.proposed_price,
                "driver_name": bid.driver.full_name if bid.driver else None
            }
        )
    except Exception as e:
        logger.error(f"Error notifying client about new bid: {e}")

async def notify_driver_about_bid_rejection(db: Session, bid_id: int):
    """Уведомление водителя об отклонении ставки"""
    try:
        bid = crud.get_bid(db, bid_id)
        if not bid or not bid.driver_id:
            return
        
        await notification_service.send_notification(
            db,
            bid.driver_id,
            "bid_rejected",
            {
                "bid_id": bid_id,
                "order_id": bid.order_id,
                "proposed_price": bid.proposed_price
            }
        )
    except Exception as e:
        logger.error(f"Error notifying driver about bid rejection: {e}")
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\chat.py                                                     ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\chat.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для чата (WebSocket)
"""
from typing import Annotated
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, HTTPException, status
from sqlalchemy.orm import Session
import json
import logging
from datetime import datetime

from .. import crud, schemas, models
from ..auth import verify_token, get_current_user
from ..database import get_db
from ..websocket_manager import manager
from ..notifications import notification_service

router = APIRouter()
logger = logging.getLogger(__name__)

@router.websocket("/ws/chat/{order_id}")
async def websocket_chat_endpoint(
    websocket: WebSocket,
    order_id: int,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint для чата заказа
    """
    # Верификация токена
    payload = verify_token(token)
    if not payload:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    user_id = payload.get("user_id")
    if not user_id:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # Получение пользователя и заказа
    user = crud.get_user_by_id(db, user_id)
    order = crud.get_order(db, order_id)
    
    if not user or not user.is_active:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    if not order:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Order not found")
        return
    
    # Проверка прав доступа к чату
    is_authorized = (
        user.id == order.client_id or 
        user.id == order.driver_id or
        user.role == models.UserRole.ADMIN
    )
    
    if not is_authorized:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Not authorized")
        return
    
    # Подключение к чату
    await manager.connect_chat(websocket, order_id, user_id)
    
    try:
        # Отправляем историю сообщений
        messages = crud.get_messages_by_order(db, order_id, limit=50)
        for message in reversed(messages):  # От старых к новым
            await websocket.send_json({
                "type": "chat_history",
                "data": {
                    "id": message.id,
                    "order_id": message.order_id,
                    "sender_id": message.sender_id,
                    "sender_email": message.sender.email,
                    "sender_name": message.sender.full_name,
                    "sender_role": message.sender.role.value,
                    "content": message.content,
                    "is_read": message.is_read,
                    "timestamp": message.timestamp.isoformat()
                }
            })
        
        # Отправляем уведомление о подключении
        await manager.broadcast_chat_message(order_id, {
            "type": "user_connected",
            "data": {
                "user_id": user_id,
                "user_email": user.email,
                "user_name": user.full_name,
                "user_role": user.role.value,
                "timestamp": datetime.utcnow().isoformat()
            }
        }, exclude_user_id=user_id)
        
        # Основной цикл обработки сообщений
        while True:
            # Получение сообщения от клиента
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            # Проверка типа сообщения
            if message_data.get("type") != "chat_message":
                continue
            
            content = message_data.get("content", "").strip()
            if not content:
                continue
            
            # Сохранение сообщения в базу данных
            message_create = schemas.MessageCreate(content=content)
            message = crud.create_message(db, message_create, order_id, user_id)
            
            # Подготовка сообщения для трансляции
            broadcast_message = {
                "type": "chat_message",
                "data": {
                    "id": message.id,
                    "order_id": message.order_id,
                    "sender_id": message.sender_id,
                    "sender_email": user.email,
                    "sender_name": user.full_name,
                    "sender_role": user.role.value,
                    "content": message.content,
                    "is_read": message.is_read,
                    "timestamp": message.timestamp.isoformat()
                }
            }
            
            # Трансляция сообщения всем участникам чата
            await manager.broadcast_chat_message(order_id, broadcast_message)
            
            # Отправка уведомления другим участникам чата
            other_user_id = order.client_id if user_id != order.client_id else (order.driver_id or 0)
            if other_user_id:
                try:
                    await notification_service.send_notification(
                        db,
                        other_user_id,
                        "chat_message",
                        {
                            "order_id": order_id,
                            "order_number": order.order_number,
                            "sender_id": user_id,
                            "sender_name": user.full_name,
                            "message": content[:100] + ("..." if len(content) > 100 else "")
                        }
                    )
                except Exception as e:
                    logger.error(f"Error sending chat notification: {e}")
            
            logger.info(f"Chat message sent: order {order_id}, user {user.email}")
            
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected: order {order_id}, user {user.email}")
        manager.disconnect_chat(websocket, order_id, user_id)
        
        # Отправляем уведомление об отключении
        try:
            await manager.broadcast_chat_message(order_id, {
                "type": "user_disconnected",
                "data": {
                    "user_id": user_id,
                    "user_email": user.email,
                    "user_name": user.full_name,
                    "user_role": user.role.value,
                    "timestamp": datetime.utcnow().isoformat()
                }
            }, exclude_user_id=user_id)
        except:
            pass
            
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        manager.disconnect_chat(websocket, order_id, user_id)
        try:
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        except:
            pass

@router.get("/chat/{order_id}/messages", response_model=list[schemas.MessageResponse])
async def get_chat_messages(
    order_id: int,
    skip: int = 0,
    limit: int = 100,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    Получение истории сообщений чата (HTTP endpoint)
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    is_authorized = (
        current_user.id == order.client_id or 
        current_user.id == order.driver_id or
        current_user.role == models.UserRole.ADMIN
    )
    
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к чату запрещен"
        )
    
    # Получение сообщений
    messages = crud.get_messages_by_order(db, order_id, skip, limit)
    
    # Помечаем сообщения как прочитанные
    if messages:
        crud.mark_messages_as_read(db, order_id, current_user.id)
    
    return messages

@router.post("/chat/{order_id}/mark-read")
async def mark_chat_as_read(
    order_id: int,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    Пометка всех сообщений чата как прочитанных
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    is_authorized = (
        current_user.id == order.client_id or 
        current_user.id == order.driver_id or
        current_user.role == models.UserRole.ADMIN
    )
    
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к чату запрещен"
        )
    
    # Помечаем сообщения как прочитанные
    updated_count = crud.mark_messages_as_read(db, order_id, current_user.id)
    
    return {"message": f"Отмечено {updated_count} сообщений как прочитанные"}

@router.get("/chat/unread-count")
async def get_unread_chat_count(
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    Получение количества непрочитанных сообщений
    """
    # Получаем все заказы пользователя
    if current_user.role == models.UserRole.CLIENT:
        orders = crud.get_orders(db, client_id=current_user.id)
    elif current_user.role == models.UserRole.DRIVER:
        orders = crud.get_orders(db, driver_id=current_user.id)
    else:  # Admin
        orders = []
    
    total_unread = 0
    orders_with_unread = []
    
    for order in orders:
        unread_count = db.query(models.Message).filter(
            models.Message.order_id == order.id,
            models.Message.sender_id != current_user.id,
            models.Message.is_read == False
        ).count()
        
        if unread_count > 0:
            total_unread += unread_count
            orders_with_unread.append({
                "order_id": order.id,
                "order_number": order.order_number,
                "unread_count": unread_count,
                "last_message": db.query(models.Message)
                    .filter(models.Message.order_id == order.id)
                    .order_by(models.Message.timestamp.desc())
                    .first()
            })
    
    return {
        "total_unread": total_unread,
        "orders_with_unread": orders_with_unread,
        "user_id": current_user.id
    }

@router.websocket("/ws/notifications")
async def websocket_notifications_endpoint(
    websocket: WebSocket,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint для получения уведомлений в реальном времени
    """
    # Верификация токена
    payload = verify_token(token)
    if not payload:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    user_id = payload.get("user_id")
    if not user_id:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # Получение пользователя
    user = crud.get_user_by_id(db, user_id)
    if not user or not user.is_active:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # Подключение пользователя
    await manager.connect_user(websocket, user_id)
    
    try:
        # Отправляем непрочитанные уведомления
        notifications = db.query(models.Notification).filter(
            models.Notification.user_id == user_id,
            models.Notification.is_read == False
        ).order_by(models.Notification.created_at.desc()).limit(20).all()
        
        for notification in notifications:
            await websocket.send_json({
                "type": "notification",
                "data": {
                    "id": notification.id,
                    "title": notification.title,
                    "message": notification.message,
                    "type": notification.type,
                    "data": notification.data,
                    "is_read": notification.is_read,
                    "created_at": notification.created_at.isoformat()
                }
            })
        
        # Основной цикл (поддержание соединения)
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            # Обработка команд от клиента
            if message_data.get("type") == "mark_as_read":
                notification_id = message_data.get("notification_id")
                if notification_id:
                    notification = db.query(models.Notification).filter(
                        models.Notification.id == notification_id,
                        models.Notification.user_id == user_id
                    ).first()
                    
                    if notification:
                        notification.is_read = True
                        db.commit()
                        
                        await websocket.send_json({
                            "type": "notification_marked_read",
                            "data": {"notification_id": notification_id}
                        })
            
            elif message_data.get("type") == "mark_all_as_read":
                db.query(models.Notification).filter(
                    models.Notification.user_id == user_id,
                    models.Notification.is_read == False
                ).update({"is_read": True})
                db.commit()
                
                await websocket.send_json({
                    "type": "all_notifications_marked_read",
                    "data": {"user_id": user_id}
                })
            
    except WebSocketDisconnect:
        logger.info(f"Notification WebSocket disconnected: user {user.email}")
        manager.disconnect_user(websocket, user_id)
        
    except Exception as e:
        logger.error(f"Notification WebSocket error: {e}")
        manager.disconnect_user(websocket, user_id)
        try:
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        except:
            pass
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\drivers.py                                                  ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\drivers.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для работы с водителями
"""
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Query, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
import logging

from .. import schemas, crud, models
from ..auth import get_current_active_user, get_current_driver, get_current_admin, get_current_driver_or_admin
from ..database import get_db
from ..dependencies import PaginationParams
from ..file_storage import file_storage
from ..notifications import notification_service

router = APIRouter(prefix="/api/drivers", tags=["drivers"])
logger = logging.getLogger(__name__)

@router.post("/profile", response_model=schemas.DriverProfileResponse)
async def create_driver_profile(
    profile: schemas.DriverProfileCreate,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Создание профиля водителя
    """
    # Проверка существования профиля
    existing_profile = crud.get_driver_profile(db, current_user.id)
    if existing_profile:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Профиль уже существует"
        )
    
    # Создание профиля
    created_profile = crud.create_driver_profile(db, profile, current_user.id)
    
    # Отправляем уведомление администраторам
    admins = crud.get_users(db, role="admin", is_active=True)
    for admin in admins:
        await notification_service.send_notification(
            db,
            admin.id,
            "verification_required",
            {"driver_id": current_user.id, "driver_name": current_user.full_name}
        )
    
    logger.info(f"Driver profile created for user: {current_user.email}")
    
    return created_profile

@router.get("/profile", response_model=schemas.DriverProfileResponse)
async def get_my_driver_profile(
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Получение профиля текущего водителя
    """
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Профиль не найден"
        )
    
    return profile

@router.put("/profile", response_model=schemas.DriverProfileResponse)
async def update_driver_profile(
    profile_update: schemas.DriverProfileUpdate,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Обновление профиля водителя
    """
    profile = crud.update_driver_profile(db, current_user.id, profile_update)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Профиль не найден"
        )
    
    logger.info(f"Driver profile updated for user: {current_user.email}")
    
    return profile

@router.post("/profile/online")
async def set_driver_online(
    lat: float = Query(..., ge=-90, le=90, description="Широта"),
    lng: float = Query(..., ge=-180, le=180, description="Долгота"),
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Установка статуса "онлайн" для водителя
    """
    profile = crud.update_driver_location(db, current_user.id, lat, lng)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Профиль не найден"
        )
    
    profile.is_online = True
    db.commit()
    db.refresh(profile)
    
    logger.info(f"Driver set online: {current_user.email} at ({lat}, {lng})")
    
    return {"message": "Водитель в сети", "location": {"lat": lat, "lng": lng}}

@router.post("/profile/offline")
async def set_driver_offline(
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Установка статуса "офлайн" для водителя
    """
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Профиль не найден"
        )
    
    profile.is_online = False
    db.commit()
    db.refresh(profile)
    
    logger.info(f"Driver set offline: {current_user.email}")
    
    return {"message": "Водитель не в сети"}

@router.get("/nearby")
async def get_nearby_drivers(
    lat: float = Query(..., ge=-90, le=90, description="Широта"),
    lng: float = Query(..., ge=-180, le=180, description="Долгота"),
    radius_km: float = Query(50, ge=1, le=500, description="Радиус поиска в км"),
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Поиск водителей поблизости (упрощенная версия)
    """
    # В реальном приложении здесь должен быть поиск по геолокации
    # Для упрощения возвращаем онлайн водителей
    
    drivers = crud.get_driver_profiles(db, is_online=True, limit=20)
    
    # Фильтруем по расстоянию (упрощенно)
    nearby_drivers = []
    for driver in drivers:
        if driver.current_location_lat and driver.current_location_lng:
            distance = crud.utils.calculate_distance(
                lat, lng,
                driver.current_location_lat, driver.current_location_lng
            )
            if distance <= radius_km:
                nearby_drivers.append({
                    "driver": schemas.DriverProfileResponse.model_validate(driver),
                    "distance_km": round(distance, 2),
                    "user": schemas.UserResponse.model_validate(driver.user)
                })
    
    return {"drivers": nearby_drivers, "count": len(nearby_drivers)}

@router.get("/", response_model=List[schemas.DriverWithProfile])
async def get_drivers(
    pagination: PaginationParams = Depends(),
    verification_status: Optional[str] = Query(None, description="Статус верификации"),
    is_online: Optional[bool] = Query(None, description="Статус онлайн"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение списка водителей (только для администраторов)
    """
    profiles = crud.get_driver_profiles(
        db,
        skip=pagination.skip,
        limit=pagination.limit,
        verification_status=verification_status,
        is_online=is_online
    )
    
    # Формируем ответ с информацией о пользователе
    result = []
    for profile in profiles:
        result.append({
            "user": schemas.UserResponse.model_validate(profile.user),
            "profile": schemas.DriverProfileResponse.model_validate(profile)
        })
    
    return result

@router.get("/{driver_id}/profile", response_model=schemas.DriverWithProfile)
async def get_driver_profile_by_id(
    driver_id: int,
    current_user: schemas.UserResponse = Depends(get_current_driver_or_admin),
    db: Session = Depends(get_db)
):
    """
    Получение профиля водителя по ID
    """
    # Проверка прав доступа
    if current_user.role == "driver" and current_user.id != driver_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ запрещен"
        )
    
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Профиль не найден"
        )
    
    return {
        "user": schemas.UserResponse.model_validate(profile.user),
        "profile": schemas.DriverProfileResponse.model_validate(profile)
    }

@router.post("/upload-document")
async def upload_document(
    document_type: str = Query(..., description="Тип документа: license, passport, vehicle_registration, insurance"),
    file: UploadFile = File(...),
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Загрузка документа водителя
    """
    # Проверка типа документа
    allowed_types = ["license", "passport", "vehicle_registration", "insurance"]
    if document_type not in allowed_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Недопустимый тип документа. Допустимые: {', '.join(allowed_types)}"
        )
    
    # Сохранение файла
    try:
        file_path = await file_storage.save_driver_document(file, current_user.id, document_type)
        
        # Обновление профиля водителя
        profile = crud.get_driver_profile(db, current_user.id)
        if profile:
            if document_type == "license":
                profile.license_path = file_path
            elif document_type == "passport":
                profile.passport_path = file_path
            elif document_type == "vehicle_registration":
                profile.vehicle_registration_path = file_path
            elif document_type == "insurance":
                profile.insurance_path = file_path
            
            db.commit()
        
        logger.info(f"Document uploaded: {document_type} for user: {current_user.email}")
        
        return {
            "message": "Документ успешно загружен",
            "document_type": document_type,
            "file_path": file_path,
            "filename": file.filename
        }
        
    except Exception as e:
        logger.error(f"Error uploading document: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка при загрузке документа: {str(e)}"
        )

@router.get("/stats/{driver_id}")
async def get_driver_stats(
    driver_id: int,
    current_user: schemas.UserResponse = Depends(get_current_driver_or_admin),
    db: Session = Depends(get_db)
):
    """
    Получение статистики водителя
    """
    # Проверка прав доступа
    if current_user.role == "driver" and current_user.id != driver_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ запрещен"
        )
    
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Профиль не найден"
        )
    
    # Получаем заказы водителя
    orders = crud.get_orders(db, driver_id=driver_id)
    
    # Рассчитываем статистику
    completed_orders = [o for o in orders if o.status == models.OrderStatus.COMPLETED]
    cancelled_orders = [o for o in orders if o.status == models.OrderStatus.CANCELLED]
    active_orders = [o for o in orders if o.status in [
        models.OrderStatus.DRIVER_ASSIGNED,
        models.OrderStatus.LOADING,
        models.OrderStatus.EN_ROUTE,
        models.OrderStatus.UNLOADING
    ]]
    
    total_earnings = sum(o.order_amount or 0 for o in completed_orders)
    avg_rating = profile.rating
    acceptance_rate = len(completed_orders) / max(len(orders), 1) * 100
    
    stats = {
        "total_orders": len(orders),
        "completed_orders": len(completed_orders),
        "cancelled_orders": len(cancelled_orders),
        "active_orders": len(active_orders),
        "total_earnings": total_earnings,
        "average_rating": avg_rating,
        "acceptance_rate": round(acceptance_rate, 2),
        "total_distance": profile.total_distance,
        "verification_status": profile.verification_status.value
    }
    
    return stats

@router.post("/search")
async def search_drivers(
    query: str = Query(..., description="Поисковый запрос (имя, email, телефон, номер машины)"),
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Поиск водителей (только для администраторов)
    """
    profiles = db.query(crud.models.DriverProfile).join(crud.models.User).filter(
        (crud.models.User.email.ilike(f"%{query}%")) |
        (crud.models.User.phone.ilike(f"%{query}%")) |
        (crud.models.User.full_name.ilike(f"%{query}%")) |
        (crud.models.DriverProfile.vehicle_number.ilike(f"%{query}%")) |
        (crud.models.DriverProfile.vehicle_model.ilike(f"%{query}%"))
    ).order_by(crud.models.DriverProfile.created_at.desc())\
     .offset(pagination.skip)\
     .limit(pagination.limit)\
     .all()
    
    result = []
    for profile in profiles:
        result.append({
            "user": schemas.UserResponse.model_validate(profile.user),
            "profile": schemas.DriverProfileResponse.model_validate(profile)
        })
    
    return result
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\health.py                                                   ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\health.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для проверки здоровья системы
"""
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
import logging
from datetime import datetime
import psutil
import os
import sys

from ..database import get_db
from .. import crud

router = APIRouter(tags=["health"])
logger = logging.getLogger(__name__)

@router.get("/health")
async def health_check():
    """
    Базовая проверка здоровья API
    """
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "service": "CargoPro Backend",
        "version": "1.0.0"
    }

@router.get("/health/detailed")
async def detailed_health_check(db: Session = Depends(get_db)):
    """
    Детальная проверка здоровья системы
    """
    checks = {
        "api": {"status": "healthy", "message": "API доступен"},
        "database": {"status": "unknown", "message": "Не проверено"},
        "memory": {"status": "unknown", "message": "Не проверено"},
        "disk": {"status": "unknown", "message": "Не проверено"}
    }
    
    # Проверка базы данных
    try:
        db.execute("SELECT 1")
        checks["database"]["status"] = "healthy"
        checks["database"]["message"] = "База данных доступна"
        
        # Проверка количества таблиц (для SQLite)
        try:
            result = db.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()
            table_count = len(result)
            checks["database"]["tables"] = table_count
        except:
            checks["database"]["tables"] = "unknown"
        
    except Exception as e:
        checks["database"]["status"] = "unhealthy"
        checks["database"]["message"] = f"Ошибка базы данных: {str(e)}"
    
    # Проверка памяти
    try:
        memory = psutil.virtual_memory()
        checks["memory"]["status"] = "healthy" if memory.percent < 90 else "warning"
        checks["memory"]["message"] = f"Использовано {memory.percent}% памяти"
        checks["memory"]["details"] = {
            "total_gb": round(memory.total / (1024**3), 2),
            "available_gb": round(memory.available / (1024**3), 2),
            "percent_used": memory.percent
        }
    except Exception as e:
        checks["memory"]["status"] = "unhealthy"
        checks["memory"]["message"] = f"Ошибка проверки памяти: {str(e)}"
    
    # Проверка диска
    try:
        disk = psutil.disk_usage('/')
        checks["disk"]["status"] = "healthy" if disk.percent < 90 else "warning"
        checks["disk"]["message"] = f"Использовано {disk.percent}% диска"
        checks["disk"]["details"] = {
            "total_gb": round(disk.total / (1024**3), 2),
            "free_gb": round(disk.free / (1024**3), 2),
            "percent_used": disk.percent
        }
    except Exception as e:
        checks["disk"]["status"] = "unhealthy"
        checks["disk"]["message"] = f"Ошибка проверки диска: {str(e)}"
    
    # Определение общего статуса
    all_healthy = all(check["status"] in ["healthy", "warning"] for check in checks.values())
    overall_status = "healthy" if all_healthy else "unhealthy"
    
    # Проверка есть ли предупреждения
    has_warnings = any(check["status"] == "warning" for check in checks.values())
    
    return {
        "status": overall_status,
        "has_warnings": has_warnings,
        "timestamp": datetime.utcnow().isoformat(),
        "checks": checks,
        "system_info": {
            "python_version": sys.version,
            "platform": sys.platform,
            "cpu_count": psutil.cpu_count() if hasattr(psutil, 'cpu_count') else "unknown"
        }
    }

@router.get("/health/database")
async def database_health_check(db: Session = Depends(get_db)):
    """
    Проверка здоровья базы данных
    """
    try:
        # Проверка соединения
        db.execute("SELECT 1")
        
        # Получение статистики
        stats = {
            "connection": "ok",
            "tables": {},
            "statistics": {}
        }
        
        # Количество записей в основных таблицах
        tables = ["users", "orders", "bids", "messages", "payments"]
        for table in tables:
            try:
                count = db.execute(f"SELECT COUNT(*) FROM {table}").scalar()
                stats["tables"][table] = count
            except:
                stats["tables"][table] = "error"
        
        # Статистика пользователей
        try:
            user_stats = crud.get_system_stats(db)
            stats["statistics"]["users"] = user_stats
        except:
            stats["statistics"]["users"] = "error"
        
        return {
            "status": "healthy",
            "database": "connected",
            "details": stats,
            "timestamp": datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        return {
            "status": "unhealthy",
            "database": "disconnected",
            "error": str(e),
            "timestamp": datetime.utcnow().isoformat()
        }

@router.get("/health/endpoints")
async def endpoints_health_check():
    """
    Проверка доступности основных эндпоинтов
    """
    endpoints = [
        {"name": "API Documentation", "path": "/api/docs", "method": "GET"},
        {"name": "Authentication", "path": "/api/auth/login", "method": "POST"},
        {"name": "User Profile", "path": "/api/users/me", "method": "GET"},
        {"name": "Orders List", "path": "/api/orders", "method": "GET"},
        {"name": "Admin Statistics", "path": "/api/admin/stats", "method": "GET"}
    ]
    
    return {
        "status": "healthy",
        "endpoints": endpoints,
        "timestamp": datetime.utcnow().isoformat(),
        "note": "Эта проверка только перечисляет основные эндпоинты. Для реальной проверки нужны тестовые запросы."
    }

@router.get("/metrics")
async def system_metrics():
    """
    Метрики системы для мониторинга
    """
    try:
        # Системные метрики
        cpu_percent = psutil.cpu_percent(interval=0.1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        # Сетевые метрики
        net_io = psutil.net_io_counters()
        
        # Метрики процесса
        process = psutil.Process()
        process_memory = process.memory_info()
        
        metrics = {
            "timestamp": datetime.utcnow().isoformat(),
            "system": {
                "cpu": {
                    "percent": cpu_percent,
                    "cores": psutil.cpu_count(),
                    "cores_logical": psutil.cpu_count(logical=True)
                },
                "memory": {
                    "total_bytes": memory.total,
                    "available_bytes": memory.available,
                    "used_bytes": memory.used,
                    "percent": memory.percent
                },
                "disk": {
                    "total_bytes": disk.total,
                    "free_bytes": disk.free,
                    "used_bytes": disk.used,
                    "percent": disk.percent
                },
                "network": {
                    "bytes_sent": net_io.bytes_sent,
                    "bytes_recv": net_io.bytes_recv,
                    "packets_sent": net_io.packets_sent,
                    "packets_recv": net_io.packets_recv
                }
            },
            "process": {
                "pid": process.pid,
                "name": process.name(),
                "memory_rss_bytes": process_memory.rss,
                "memory_vms_bytes": process_memory.vms,
                "cpu_percent": process.cpu_percent(),
                "threads": process.num_threads()
            }
        }
        
        return metrics
    except Exception as e:
        return {
            "timestamp": datetime.utcnow().isoformat(),
            "error": str(e),
            "status": "partial"
        }

@router.get("/version")
async def version_info():
    """
    Информация о версии приложения
    """
    return {
        "service": "CargoPro Backend",
        "version": "1.0.0",
        "environment": os.getenv("ENVIRONMENT", "development"),
        "build_date": "2024-01-01",
        "api_version": "v1",
        "features": [
            "authentication",
            "order_management",
            "driver_tracking",
            "real_time_chat",
            "payment_processing",
            "admin_panel"
        ]
    }
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\integration.py                                              ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\integration.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для интеграции с внешними сервисами
"""
from fastapi import APIRouter, Depends, HTTPException, status, Header, Query
from sqlalchemy.orm import Session
from typing import Optional
import logging

from .. import schemas, crud, models
from ..auth import get_current_active_user, get_current_admin
from ..database import get_db
from ..dependencies import verify_api_key
from ..payment import payment_service

router = APIRouter(prefix="/api/integration", tags=["integration"])
logger = logging.getLogger(__name__)

# Публичные эндпоинты для интеграции
@router.get("/public/order/{order_number}/status")
async def get_order_status_public(
    order_number: str,
    db: Session = Depends(get_db)
):
    """
    Публичный эндпоинт для получения статуса заказа по номеру
    (для интеграции с внешними системами)
    """
    order = crud.get_order_by_number(db, order_number)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Возвращаем ограниченную информацию для публичного доступа
    return {
        "order_number": order.order_number,
        "status": order.status.value,
        "from_address": order.from_address,
        "to_address": order.to_address,
        "cargo_type": order.cargo_type,
        "created_at": order.created_at.isoformat(),
        "updated_at": order.updated_at.isoformat() if order.updated_at else None,
        "estimated_delivery": order.delivery_date.isoformat() if order.delivery_date else None
    }

@router.get("/mobile/driver/{driver_id}/dashboard")
async def get_mobile_driver_dashboard(
    driver_id: int,
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """
    Дашборд для мобильного приложения водителя
    """
    if api_key != "mobile_app_key":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid API key for this endpoint"
        )
    
    driver = crud.get_user_by_id(db, driver_id)
    if not driver or driver.role != models.UserRole.DRIVER:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Водитель не найден"
        )
    
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Профиль водителя не найден"
        )
    
    # Активные заказы
    active_orders = crud.get_orders(
        db,
        driver_id=driver_id,
        status=models.OrderStatus.DRIVER_ASSIGNED.value
    )
    
    # Доступные заказы
    available_orders = crud.get_available_orders(db, driver_id=driver_id, limit=20)
    
    # Статистика
    stats = {
        "total_orders": profile.total_orders,
        "total_distance": profile.total_distance,
        "rating": profile.rating,
        "balance": driver.balance,
        "is_online": profile.is_online,
        "verification_status": profile.verification_status.value
    }
    
    # Уведомления
    notifications = db.query(models.Notification).filter(
        models.Notification.user_id == driver_id,
        models.Notification.is_read == False
    ).order_by(models.Notification.created_at.desc()).limit(10).all()
    
    return {
        "driver": {
            "id": driver.id,
            "name": driver.full_name,
            "email": driver.email,
            "phone": driver.phone,
            "vehicle": {
                "type": profile.vehicle_type,
                "model": profile.vehicle_model,
                "number": profile.vehicle_number,
                "capacity": profile.carrying_capacity,
                "volume": profile.volume
            }
        },
        "stats": stats,
        "active_orders": [
            {
                "id": order.id,
                "order_number": order.order_number,
                "from_address": order.from_address,
                "to_address": order.to_address,
                "status": order.status.value,
                "price": order.final_price or order.desired_price,
                "pickup_date": order.pickup_date.isoformat() if order.pickup_date else None
            }
            for order in active_orders
        ],
        "available_orders": [
            {
                "id": order.id,
                "order_number": order.order_number,
                "from_address": order.from_address,
                "to_address": order.to_address,
                "distance": order.distance_km,
                "price": order.desired_price,
                "cargo": {
                    "type": order.cargo_type,
                    "weight": order.cargo_weight,
                    "volume": order.cargo_volume,
                    "description": order.cargo_description
                },
                "created_at": order.created_at.isoformat()
            }
            for order in available_orders
        ],
        "notifications": [
            {
                "id": n.id,
                "title": n.title,
                "message": n.message,
                "type": n.type,
                "created_at": n.created_at.isoformat()
            }
            for n in notifications
        ]
    }

@router.get("/admin/dashboard")
async def get_admin_dashboard(
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """
    Дашборд для админ-панели
    """
    if api_key != "admin_panel_key":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid API key for this endpoint"
        )
    
    stats = crud.get_system_stats(db)
    
    # Последние заказы
    recent_orders = db.query(models.Order)\
        .order_by(models.Order.created_at.desc())\
        .limit(10)\
        .all()
    
    # Последние регистрации
    recent_users = db.query(models.User)\
        .order_by(models.User.created_at.desc())\
        .limit(10)\
        .all()
    
    # Ожидающие верификации
    pending_verifications = db.query(models.DriverProfile)\
        .filter(models.DriverProfile.verification_status == models.VerificationStatus.PENDING)\
        .order_by(models.DriverProfile.created_at.desc())\
        .limit(10)\
        .all()
    
    return {
        "stats": stats,
        "recent_orders": [
            {
                "id": order.id,
                "order_number": order.order_number,
                "client_email": order.client.email,
                "status": order.status.value,
                "price": order.final_price or order.desired_price,
                "created_at": order.created_at.isoformat()
            }
            for order in recent_orders
        ],
        "recent_users": [
            {
                "id": user.id,
                "email": user.email,
                "role": user.role.value,
                "created_at": user.created_at.isoformat()
            }
            for user in recent_users
        ],
        "pending_verifications": [
            {
                "driver_id": profile.user_id,
                "driver_email": profile.user.email,
                "vehicle_number": profile.vehicle_number,
                "created_at": profile.created_at.isoformat(),
                "documents": {
                    "license": bool(profile.license_path),
                    "passport": bool(profile.passport_path),
                    "registration": bool(profile.vehicle_registration_path)
                }
            }
            for profile in pending_verifications
        ]
    }

@router.get("/website/order-tracking/{order_number}")
async def get_website_order_tracking(
    order_number: str,
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """
    Отслеживание заказа для основного сайта
    """
    if api_key != "website_key":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid API key for this endpoint"
        )
    
    order = crud.get_order_by_number(db, order_number)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Информация о заказе
    order_info = {
        "order_number": order.order_number,
        "status": order.status.value,
        "status_description": get_status_description(order.status),
        "from_address": order.from_address,
        "to_address": order.to_address,
        "cargo_type": order.cargo_type,
        "cargo_weight": order.cargo_weight,
        "cargo_volume": order.cargo_volume,
        "created_at": order.created_at.isoformat(),
        "pickup_date": order.pickup_date.isoformat() if order.pickup_date else None,
        "delivery_date": order.delivery_date.isoformat() if order.delivery_date else None,
        "distance": order.distance_km
    }
    
    # Информация о водителе (если назначен)
    driver_info = None
    if order.driver_id:
        driver = crud.get_user_by_id(db, order.driver_id)
        driver_profile = crud.get_driver_profile(db, order.driver_id)
        
        if driver and driver_profile:
            driver_info = {
                "name": driver.full_name,
                "phone": driver.phone,
                "vehicle": {
                    "type": driver_profile.vehicle_type,
                    "model": driver_profile.vehicle_model,
                    "number": driver_profile.vehicle_number
                },
                "rating": driver_profile.rating,
                "total_orders": driver_profile.total_orders
            }
    
    # Текущее местоположение водителя (если есть)
    current_location = None
    if order.driver_id:
        location = db.query(models.LocationUpdate)\
            .filter(models.LocationUpdate.driver_id == order.driver_id)\
            .order_by(models.LocationUpdate.timestamp.desc())\
            .first()
        
        if location:
            current_location = {
                "lat": location.lat,
                "lng": location.lng,
                "timestamp": location.timestamp.isoformat(),
                "accuracy": location.accuracy
            }
    
    # История статусов
    status_history = [
        {
            "status": "created",
            "timestamp": order.created_at.isoformat(),
            "description": "Заказ создан"
        }
    ]
    
    if order.pickup_date:
        status_history.append({
            "status": "pickup_scheduled",
            "timestamp": order.pickup_date.isoformat(),
            "description": "Запланирована погрузка"
        })
    
    if order.delivery_date:
        status_history.append({
            "status": "delivery_scheduled",
            "timestamp": order.delivery_date.isoformat(),
            "description": "Запланирована доставка"
        })
    
    if order.completed_at:
        status_history.append({
            "status": "completed",
            "timestamp": order.completed_at.isoformat(),
            "description": "Заказ завершен"
        })
    
    return {
        "order": order_info,
        "driver": driver_info,
        "current_location": current_location,
        "status_history": status_history,
        "estimated_progress": calculate_order_progress(order)
    }

@router.post("/payment/webhook")
async def payment_webhook(
    webhook_data: dict,
    x_webhook_signature: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """
    Вебхук для обработки платежей от внешних платежных систем
    """
    # В реальном приложении здесь должна быть проверка подписи
    logger.info(f"Payment webhook received: {webhook_data}")
    
    try:
        # Извлекаем данные из вебхука
        payment_id = webhook_data.get("payment_id")
        status = webhook_data.get("status")
        metadata = webhook_data.get("metadata", {})
        
        if not payment_id or not status:
            return {"status": "error", "message": "Missing required fields"}
        
        # Обработка вебхука
        success, message = await payment_service.process_payment_webhook(
            db, payment_id, status, metadata
        )
        
        if success:
            return {"status": "success", "message": message}
        else:
            return {"status": "error", "message": message}
            
    except Exception as e:
        logger.error(f"Error processing payment webhook: {e}")
        return {"status": "error", "message": str(e)}

@router.get("/payment/methods")
async def get_payment_methods_integration(
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """
    Получение доступных методов оплаты для интеграции
    """
    methods = payment_service.get_supported_payment_methods()
    
    return {
        "methods": methods,
        "currency": "RUB",
        "platform_fee_percent": 5.0
    }

# Вспомогательные функции
def get_status_description(status: models.OrderStatus) -> str:
    """Получение описания статуса заказа"""
    descriptions = {
        models.OrderStatus.DRAFT: "Черновик",
        models.OrderStatus.SEARCHING: "Поиск водителя",
        models.OrderStatus.DRIVER_ASSIGNED: "Водитель назначен",
        models.OrderStatus.LOADING: "Погрузка",
        models.OrderStatus.EN_ROUTE: "В пути",
        models.OrderStatus.UNLOADING: "Разгрузка",
        models.OrderStatus.COMPLETED: "Завершен",
        models.OrderStatus.CANCELLED: "Отменен",
        models.OrderStatus.PAID: "Оплачен"
    }
    return descriptions.get(status, "Неизвестный статус")

def calculate_order_progress(order: models.Order) -> float:
    """Расчет прогресса выполнения заказа"""
    progress_map = {
        models.OrderStatus.DRAFT: 0,
        models.OrderStatus.SEARCHING: 10,
        models.OrderStatus.DRIVER_ASSIGNED: 30,
        models.OrderStatus.LOADING: 50,
        models.OrderStatus.EN_ROUTE: 75,
        models.OrderStatus.UNLOADING: 90,
        models.OrderStatus.COMPLETED: 100,
        models.OrderStatus.CANCELLED: 0,
        models.OrderStatus.PAID: 100
    }
    return progress_map.get(order.status, 0)
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\orders.py                                                   ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\orders.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для работы с заказами
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query, UploadFile, File, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
import logging
from datetime import datetime

from .. import schemas, crud, models
from ..auth import get_current_active_user, get_current_client, get_current_admin, get_current_client_or_admin, get_current_driver
from ..database import get_db
from ..dependencies import PaginationParams, OrderFilterParams
from ..file_storage import file_storage
from ..notifications import notification_service
from ..payment import payment_service

router = APIRouter(prefix="/api/orders", tags=["orders"])
logger = logging.getLogger(__name__)

@router.post("/", response_model=schemas.OrderResponse)
async def create_order(
    order: schemas.OrderCreate,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_client),
    db: Session = Depends(get_db)
):
    """
    Создание нового заказа
    """
    try:
        created_order = crud.create_order(db, order, current_user.id)
        
        # Уведомление администраторов о новом заказе
        background_tasks.add_task(
            notify_admins_about_new_order,
            db,
            created_order.id
        )
        
        logger.info(f"Order created: {created_order.order_number} by user: {current_user.email}")
        
        return created_order
        
    except Exception as e:
        logger.error(f"Error creating order: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка при создании заказа: {str(e)}"
        )

@router.get("/", response_model=List[schemas.OrderResponse])
async def get_my_orders(
    pagination: PaginationParams = Depends(),
    filters: OrderFilterParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Получение списка заказов текущего пользователя
    """
    if current_user.role == models.UserRole.CLIENT:
        orders = crud.get_orders(
            db,
            skip=pagination.skip,
            limit=pagination.limit,
            client_id=current_user.id,
            status=filters.status,
            min_price=filters.min_price,
            max_price=filters.max_price,
            cargo_type=filters.cargo_type
        )
    elif current_user.role == models.UserRole.DRIVER:
        orders = crud.get_orders(
            db,
            skip=pagination.skip,
            limit=pagination.limit,
            driver_id=current_user.id,
            status=filters.status,
            min_price=filters.min_price,
            max_price=filters.max_price,
            cargo_type=filters.cargo_type
        )
    else:  # Admin
        orders = crud.get_orders(
            db,
            skip=pagination.skip,
            limit=pagination.limit,
            status=filters.status,
            min_price=filters.min_price,
            max_price=filters.max_price,
            cargo_type=filters.cargo_type
        )
    
    return orders

@router.get("/available", response_model=List[schemas.OrderResponse])
async def get_available_orders(
    pagination: PaginationParams = Depends(),
    filters: OrderFilterParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Получение списка доступных заказов (для водителей)
    """
    if current_user.role != models.UserRole.DRIVER:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Только водители могут просматривать доступные заказы"
        )
    
    # Проверка верификации водителя
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile or profile.verification_status != models.VerificationStatus.VERIFIED:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Профиль водителя не верифицирован"
        )
    
    orders = crud.get_available_orders(
        db,
        driver_id=current_user.id,
        skip=pagination.skip,
        limit=pagination.limit
    )
    
    # Применяем дополнительные фильтры
    if filters.status:
        orders = [o for o in orders if o.status == filters.status]
    if filters.min_price:
        orders = [o for o in orders if o.desired_price >= filters.min_price]
    if filters.max_price:
        orders = [o for o in orders if o.desired_price <= filters.max_price]
    if filters.cargo_type:
        orders = [o for o in orders if o.cargo_type == filters.cargo_type]
    
    return orders

@router.get("/{order_id}", response_model=schemas.OrderWithRelations)
async def get_order(
    order_id: int,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Получение информации о заказе
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    has_access = False
    
    if current_user.role == models.UserRole.ADMIN:
        has_access = True
    elif current_user.role == models.UserRole.CLIENT and order.client_id == current_user.id:
        has_access = True
    elif current_user.role == models.UserRole.DRIVER and order.driver_id == current_user.id:
        has_access = True
    elif current_user.role == models.UserRole.DRIVER:
        # Проверяем, делал ли водитель ставку на этот заказ
        bid = db.query(models.Bid).filter(
            models.Bid.order_id == order_id,
            models.Bid.driver_id == current_user.id
        ).first()
        has_access = bool(bid)
    
    if not has_access:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к заказу запрещен"
        )
    
    return order

@router.put("/{order_id}", response_model=schemas.OrderResponse)
async def update_order(
    order_id: int,
    order_update: schemas.OrderUpdate,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Обновление заказа
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к заказу запрещен"
        )
    
    # Только администратор может назначать водителя или устанавливать финальную цену
    if current_user.role != models.UserRole.ADMIN:
        if "driver_id" in order_update.model_dump(exclude_unset=True):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Только администратор может назначать водителя"
            )
        if "final_price" in order_update.model_dump(exclude_unset=True):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Только администратор может устанавливать финальную цену"
            )
    
    updated_order = crud.update_order(db, order_id, order_update)
    
    # Если изменился статус, отправляем уведомления
    if order_update.status and order_update.status != order.status:
        background_tasks.add_task(
            notify_order_status_change,
            db,
            order_id,
            order.status,
            order_update.status
        )
    
    logger.info(f"Order updated: {updated_order.order_number}")
    
    return updated_order

@router.post("/{order_id}/publish")
async def publish_order(
    order_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_client),
    db: Session = Depends(get_db)
):
    """
    Публикация заказа (перевод в статус поиска водителя)
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    if order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к заказу запрещен"
        )
    
    if order.status != models.OrderStatus.DRAFT:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Заказ уже опубликован"
        )
    
    # Публикуем заказ
    order.status = models.OrderStatus.SEARCHING
    db.commit()
    db.refresh(order)
    
    # Уведомляем водителей о новом заказе
    background_tasks.add_task(
        notification_service.notify_new_order,
        db,
        order_id
    )
    
    logger.info(f"Order published: {order.order_number}")
    
    return {"message": "Заказ опубликован", "order": order}

@router.post("/{order_id}/cancel")
async def cancel_order(
    order_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Отмена заказа
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к заказу запрещен"
        )
    
    if current_user.role == models.UserRole.DRIVER and order.driver_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к заказу запрещен"
        )
    
    if order.status in [models.OrderStatus.COMPLETED, models.OrderStatus.CANCELLED]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Невозможно отменить завершенный или уже отмененный заказ"
        )
    
    # Отменяем заказ
    cancelled_order = crud.cancel_order(db, order_id)
    
    # Отправляем уведомления
    background_tasks.add_task(
        notify_order_cancelled,
        db,
        order_id,
        current_user.id
    )
    
    logger.info(f"Order cancelled: {order.order_number} by user: {current_user.email}")
    
    return {"message": "Заказ отменен", "order": cancelled_order}

@router.post("/{order_id}/complete")
async def complete_order(
    order_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Завершение заказа (для водителей)
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    if order.driver_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к заказу запрещен"
        )
    
    if order.status not in [models.OrderStatus.EN_ROUTE, models.OrderStatus.UNLOADING]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Невозможно завершить заказ в текущем статусе"
        )
    
    # Завершаем заказ
    completed_order = crud.complete_order(db, order_id)
    
    # Отправляем уведомления
    background_tasks.add_task(
        notification_service.notify_order_completed,
        db,
        order_id
    )
    
    logger.info(f"Order completed: {order.order_number} by driver: {current_user.email}")
    
    return {"message": "Заказ завершен", "order": completed_order}

@router.post("/{order_id}/upload-image")
async def upload_order_image(
    order_id: int,
    file: UploadFile = File(...),
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Загрузка изображения для заказа
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к заказу запрещен"
        )
    
    if current_user.role == models.UserRole.DRIVER and order.driver_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ к заказу запрещен"
        )
    
    try:
        # Сохраняем файл
        file_path = await file_storage.save_order_image(file, current_user.id, order_id)
        
        # Обновляем информацию о заказе
        if not order.cargo_images:
            order.cargo_images = []
        
        order.cargo_images.append(file_path)
        db.commit()
        
        logger.info(f"Image uploaded for order: {order.order_number}")
        
        return {
            "message": "Изображение успешно загружено",
            "file_path": file_path,
            "order_id": order_id
        }
        
    except Exception as e:
        logger.error(f"Error uploading image: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка при загрузке изображения: {str(e)}"
        )

@router.post("/calculate-price")
async def calculate_order_price(
    request: schemas.PriceCalculationRequest,
    current_user: schemas.UserResponse = Depends(get_current_active_user)
):
    """
    Расчет стоимости перевозки
    """
    try:
        # Расчет расстояния
        distance_km = crud.utils.calculate_distance(
            request.from_lat, request.from_lng,
            request.to_lat, request.to_lng
        )
        
        # Расчет цены
        final_price, platform_fee, driver_amount = crud.utils.calculate_price(
            distance_km, request.weight, request.volume
        )
        
        # Базовые расчеты для информации
        base_price = distance_km * 15.0
        weight_multiplier = request.weight * 10.0
        volume_multiplier = request.volume * 5.0
        
        # Предлагаемая цена (желаемая цена клиента)
        suggested_price = final_price * 1.1  # +10% для торга
        
        result = schemas.PriceCalculation(
            distance_km=round(distance_km, 2),
            base_price=round(base_price, 2),
            weight_multiplier=round(weight_multiplier, 2),
            volume_multiplier=round(volume_multiplier, 2),
            suggested_price=round(suggested_price, 2),
            platform_fee=round(platform_fee, 2),
            driver_amount=round(driver_amount, 2)
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Error calculating price: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка при расчете стоимости: {str(e)}"
        )

@router.get("/{order_number}/track")
async def track_order_by_number(
    order_number: str,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Отслеживание заказа по номеру (публичный доступ)
    """
    order = crud.get_order_by_number(db, order_number)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Для публичного отслеживания возвращаем ограниченную информацию
    response = {
        "order_number": order.order_number,
        "status": order.status.value,
        "from_address": order.from_address,
        "to_address": order.to_address,
        "cargo_type": order.cargo_type,
        "created_at": order.created_at,
        "updated_at": order.updated_at
    }
    
    # Если пользователь авторизован и имеет доступ, добавляем больше информации
    if current_user:
        has_access = False
        if current_user.role == models.UserRole.ADMIN:
            has_access = True
        elif current_user.role == models.UserRole.CLIENT and order.client_id == current_user.id:
            has_access = True
        elif current_user.role == models.UserRole.DRIVER and order.driver_id == current_user.id:
            has_access = True
        
        if has_access:
            response.update({
                "driver_id": order.driver_id,
                "client_id": order.client_id,
                "final_price": order.final_price,
                "distance_km": order.distance_km,
                "pickup_date": order.pickup_date,
                "delivery_date": order.delivery_date
            })
    
    return response

# Вспомогательные функции
async def notify_admins_about_new_order(db: Session, order_id: int):
    """Уведомление администраторов о новом заказе"""
    try:
        admins = crud.get_users(db, role="admin", is_active=True)
        for admin in admins:
            await notification_service.send_notification(
                db,
                admin.id,
                "new_order_created",
                {"order_id": order_id}
            )
    except Exception as e:
        logger.error(f"Error notifying admins about new order: {e}")

async def notify_order_status_change(
    db: Session,
    order_id: int,
    old_status: str,
    new_status: str
):
    """Уведомление об изменении статуса заказа"""
    try:
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        # Уведомляем клиента
        await notification_service.send_notification(
            db,
            order.client_id,
            "order_updated",
            {
                "order_id": order_id,
                "order_number": order.order_number,
                "old_status": old_status,
                "new_status": new_status
            }
        )
        
        # Уведомляем водителя, если он назначен
        if order.driver_id:
            await notification_service.send_notification(
                db,
                order.driver_id,
                "order_updated",
                {
                    "order_id": order_id,
                    "order_number": order.order_number,
                    "old_status": old_status,
                    "new_status": new_status
                }
            )
    except Exception as e:
        logger.error(f"Error notifying about order status change: {e}")

async def notify_order_cancelled(
    db: Session,
    order_id: int,
    cancelled_by_user_id: int
):
    """Уведомление об отмене заказа"""
    try:
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        # Уведомляем всех участников
        participants = [order.client_id]
        if order.driver_id:
            participants.append(order.driver_id)
        
        for user_id in participants:
            if user_id != cancelled_by_user_id:  # Не уведомляем того, кто отменил
                await notification_service.send_notification(
                    db,
                    user_id,
                    "order_cancelled",
                    {
                        "order_id": order_id,
                        "order_number": order.order_number,
                        "cancelled_by": cancelled_by_user_id
                    }
                )
    except Exception as e:
        logger.error(f"Error notifying about order cancellation: {e}")
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\track.py                                                    ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\track.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для отслеживания местоположения (WebSocket)
"""
from typing import Annotated
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, HTTPException, status
from sqlalchemy.orm import Session
import json
import logging
from datetime import datetime, timedelta

from .. import crud, schemas, models
from ..auth import verify_token, get_current_user
from ..database import get_db
from ..websocket_manager import manager
from ..utils import validate_coordinates

router = APIRouter()
logger = logging.getLogger(__name__)

@router.websocket("/ws/track/driver")
async def websocket_track_driver_endpoint(
    websocket: WebSocket,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint для водителей для отправки местоположения
    """
    # Верификация токена
    payload = verify_token(token)
    if not payload:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    user_id = payload.get("user_id")
    user_role = payload.get("role")
    
    if not user_id or user_role != models.UserRole.DRIVER.value:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # Получение пользователя и профиля водителя
    user = crud.get_user_by_id(db, user_id)
    if not user or not user.is_active:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    profile = crud.get_driver_profile(db, user_id)
    if not profile or profile.verification_status != models.VerificationStatus.VERIFIED:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Driver not verified")
        return
    
    # Подключение водителя к трекингу
    await manager.connect_driver_tracking(websocket, user_id)
    
    try:
        # Основной цикл получения местоположения
        while True:
            data = await websocket.receive_text()
            location_data = json.loads(data)
            
            # Проверка типа сообщения
            if location_data.get("type") != "location_update":
                continue
            
            lat = location_data.get("lat")
            lng = location_data.get("lng")
            
            # Валидация координат
            if not validate_coordinates(lat, lng):
                await websocket.send_json({
                    "type": "error",
                    "message": "Неверные координаты"
                })
                continue
            
            accuracy = location_data.get("accuracy")
            speed = location_data.get("speed")
            heading = location_data.get("heading")
            
            # Получение активного заказа водителя
            order = db.query(models.Order).filter(
                models.Order.driver_id == user_id,
                models.Order.status.in_([
                    models.OrderStatus.DRIVER_ASSIGNED,
                    models.OrderStatus.LOADING,
                    models.OrderStatus.EN_ROUTE,
                    models.OrderStatus.UNLOADING
                ])
            ).order_by(models.Order.updated_at.desc()).first()
            
            order_id = order.id if order else None
            
            # Сохранение местоположения в базу данных
            location_create = schemas.LocationCreate(
                lat=lat,
                lng=lng,
                order_id=order_id,
                accuracy=accuracy,
                speed=speed,
                heading=heading
            )
            
            location = crud.create_location_update(db, location_create, user_id)
            
            # Обновление текущего местоположения в профиле водителя
            profile.current_location_lat = lat
            profile.current_location_lng = lng
            profile.is_online = True
            db.commit()
            
            # Подготовка данных для трансляции
            broadcast_data = {
                "driver_id": user_id,
                "driver_name": user.full_name,
                "vehicle_number": profile.vehicle_number,
                "order_id": order_id,
                "order_number": order.order_number if order else None,
                "lat": lat,
                "lng": lng,
                "accuracy": accuracy,
                "speed": speed,
                "heading": heading,
                "timestamp": datetime.utcnow().isoformat()
            }
            
            # Трансляция местоположения всем подписчикам
            await manager.broadcast_location(user_id, broadcast_data)
            
            # Подтверждение получения местоположения
            await websocket.send_json({
                "type": "location_received",
                "data": {
                    "timestamp": datetime.utcnow().isoformat(),
                    "location_id": location.id
                }
            })
            
            logger.debug(f"Location update from driver {user.email}: ({lat}, {lng})")
            
    except WebSocketDisconnect:
        logger.info(f"Driver tracking WebSocket disconnected: driver {user.email}")
        manager.disconnect_driver_tracking(user_id)
        
    except Exception as e:
        logger.error(f"Driver tracking WebSocket error: {e}")
        manager.disconnect_driver_tracking(user_id)
        try:
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        except:
            pass

@router.websocket("/ws/track/subscribe/{driver_id}")
async def websocket_track_subscribe_endpoint(
    websocket: WebSocket,
    driver_id: int,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint для подписки на отслеживание водителя
    """
    # Верификация токена
    payload = verify_token(token)
    if not payload:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    user_id = payload.get("user_id")
    user_role = payload.get("role")
    
    if not user_id:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # Получение пользователя
    user = crud.get_user_by_id(db, user_id)
    if not user or not user.is_active:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # Проверка прав доступа
    if user.role == models.UserRole.ADMIN:
        # Администраторы могут отслеживать любого водителя
        await manager.connect_admin(websocket, user_id)
        
    elif user.role == models.UserRole.CLIENT:
        # Клиенты могут отслеживать только водителей своих активных заказов
        active_order = db.query(models.Order).filter(
            models.Order.client_id == user_id,
            models.Order.driver_id == driver_id,
            models.Order.status.in_([
                models.OrderStatus.DRIVER_ASSIGNED,
                models.OrderStatus.LOADING,
                models.OrderStatus.EN_ROUTE,
                models.OrderStatus.UNLOADING
            ])
        ).first()
        
        if not active_order:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Not authorized")
            return
        
        await manager.connect_tracking_subscriber(websocket, driver_id, user_id)
        
    else:
        # Водители не могут отслеживать других водителей
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Not authorized")
        return
    
    try:
        # Получение водителя
        driver = crud.get_user_by_id(db, driver_id)
        driver_profile = crud.get_driver_profile(db, driver_id)
        
        if not driver or not driver_profile:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Driver not found")
            return
        
        # Отправка информации о водителе
        await websocket.send_json({
            "type": "driver_info",
            "data": {
                "driver_id": driver_id,
                "driver_name": driver.full_name,
                "driver_email": driver.email,
                "vehicle_type": driver_profile.vehicle_type,
                "vehicle_model": driver_profile.vehicle_model,
                "vehicle_number": driver_profile.vehicle_number,
                "phone": driver.phone,
                "rating": driver_profile.rating,
                "is_online": driver_profile.is_online
            }
        })
        
        # Отправка последнего известного местоположения
        last_location = db.query(models.LocationUpdate).filter(
            models.LocationUpdate.driver_id == driver_id
        ).order_by(models.LocationUpdate.timestamp.desc()).first()
        
        if last_location:
            await websocket.send_json({
                "type": "location_update",
                "data": {
                    "driver_id": driver_id,
                    "lat": last_location.lat,
                    "lng": last_location.lng,
                    "accuracy": last_location.accuracy,
                    "speed": last_location.speed,
                    "heading": last_location.heading,
                    "order_id": last_location.order_id,
                    "timestamp": last_location.timestamp.isoformat()
                }
            })
        
        # Получение истории маршрута для активного заказа
        if user.role == models.UserRole.CLIENT:
            active_order = db.query(models.Order).filter(
                models.Order.client_id == user_id,
                models.Order.driver_id == driver_id,
                models.Order.status.in_([
                    models.OrderStatus.DRIVER_ASSIGNED,
                    models.OrderStatus.LOADING,
                    models.OrderStatus.EN_ROUTE,
                    models.OrderStatus.UNLOADING
                ])
            ).first()
            
            if active_order:
                route_history = crud.get_locations_by_driver(
                    db, driver_id, active_order.id, limit=100
                )
                
                if route_history:
                    await websocket.send_json({
                        "type": "route_history",
                        "data": {
                            "order_id": active_order.id,
                            "route": [
                                {
                                    "lat": loc.lat,
                                    "lng": loc.lng,
                                    "timestamp": loc.timestamp.isoformat()
                                }
                                for loc in reversed(route_history)  # От старых к новым
                            ]
                        }
                    })
        
        # Основной цикл (поддержание соединения)
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            # Обработка команд от клиента
            if message_data.get("type") == "request_history":
                hours = message_data.get("hours", 24)
                from_time = datetime.utcnow() - timedelta(hours=hours)
                
                locations = db.query(models.LocationUpdate).filter(
                    models.LocationUpdate.driver_id == driver_id,
                    models.LocationUpdate.timestamp >= from_time
                ).order_by(models.LocationUpdate.timestamp.asc()).all()
                
                await websocket.send_json({
                    "type": "location_history",
                    "data": {
                        "driver_id": driver_id,
                        "locations": [
                            {
                                "lat": loc.lat,
                                "lng": loc.lng,
                                "timestamp": loc.timestamp.isoformat(),
                                "order_id": loc.order_id
                            }
                            for loc in locations
                        ]
                    }
                })
            
    except WebSocketDisconnect:
        logger.info(f"Tracking subscriber WebSocket disconnected: user {user.email}")
        if user.role == models.UserRole.ADMIN:
            manager.disconnect_admin(websocket, user_id)
        else:
            manager.disconnect_tracking_subscriber(websocket, driver_id, user_id)
            
    except Exception as e:
        logger.error(f"Tracking subscriber WebSocket error: {e}")
        if user.role == models.UserRole.ADMIN:
            manager.disconnect_admin(websocket, user_id)
        else:
            manager.disconnect_tracking_subscriber(websocket, driver_id, user_id)
        try:
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        except:
            pass

@router.get("/track/driver/{driver_id}/locations")
async def get_driver_locations(
    driver_id: int,
    hours: int = Query(24, ge=1, le=168, description="Количество часов истории"),
    limit: int = Query(100, ge=1, le=1000, description="Лимит записей"),
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    Получение истории местоположения водителя (HTTP endpoint)
    """
    # Проверка прав доступа
    if current_user.role == models.UserRole.CLIENT:
        # Клиенты могут видеть только водителей своих активных заказов
        active_order = db.query(models.Order).filter(
            models.Order.client_id == current_user.id,
            models.Order.driver_id == driver_id,
            models.Order.status.in_([
                models.OrderStatus.DRIVER_ASSIGNED,
                models.OrderStatus.LOADING,
                models.OrderStatus.EN_ROUTE,
                models.OrderStatus.UNLOADING
            ])
        ).first()
        
        if not active_order:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Доступ запрещен"
            )
    
    elif current_user.role == models.UserRole.DRIVER:
        # Водители могут видеть только свое местоположение
        if current_user.id != driver_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Доступ запрещен"
            )
    
    # Для администраторов доступ разрешен всегда
    
    # Получение истории местоположения
    from_time = datetime.utcnow() - timedelta(hours=hours)
    
    locations = db.query(models.LocationUpdate).filter(
        models.LocationUpdate.driver_id == driver_id,
        models.LocationUpdate.timestamp >= from_time
    ).order_by(models.LocationUpdate.timestamp.desc()).limit(limit).all()
    
    return locations

@router.get("/track/order/{order_id}/route")
async def get_order_route(
    order_id: int,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    Получение маршрута заказа
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заказ не найден"
        )
    
    # Проверка прав доступа
    is_authorized = (
        current_user.id == order.client_id or 
        current_user.id == order.driver_id or
        current_user.role == models.UserRole.ADMIN
    )
    
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Доступ запрещен"
        )
    
    # Получение точек маршрута
    route_points = []
    
    # Начальная точка (откуда)
    route_points.append({
        "type": "pickup",
        "address": order.from_address,
        "lat": order.from_lat,
        "lng": order.from_lng,
        "timestamp": order.pickup_date.isoformat() if order.pickup_date else None
    })
    
    # Промежуточные точки (если есть трекинг)
    if order.driver_id:
        locations = crud.get_locations_by_driver(db, order.driver_id, order_id, limit=200)
        for loc in locations:
            route_points.append({
                "type": "tracking",
                "lat": loc.lat,
                "lng": loc.lng,
                "timestamp": loc.timestamp.isoformat(),
                "accuracy": loc.accuracy,
                "speed": loc.speed
            })
    
    # Конечная точка (куда)
    route_points.append({
        "type": "delivery",
        "address": order.to_address,
        "lat": order.to_lat,
        "lng": order.to_lng,
        "timestamp": order.delivery_date.isoformat() if order.delivery_date else None
    })
    
    # Расчет статистики
    total_distance = order.distance_km or 0
    estimated_time = None
    
    if len(route_points) > 2 and order.driver_id:
        # Расчет пройденного расстояния (упрощенно)
        driver_profile = crud.get_driver_profile(db, order.driver_id)
        if driver_profile:
            estimated_time = total_distance / 60  # Предполагаемая скорость 60 км/ч
    
    return {
        "order_id": order_id,
        "order_number": order.order_number,
        "status": order.status.value,
        "route_points": route_points,
        "statistics": {
            "total_distance_km": total_distance,
            "estimated_time_hours": estimated_time,
            "points_count": len(route_points)
        }
    }
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\routes\users.py                                                    ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\users.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Роутер для работы с пользователями
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional

from .. import schemas, crud
from ..auth import get_current_active_user, get_current_admin
from ..database import get_db
from ..dependencies import PaginationParams

router = APIRouter(prefix="/api/users", tags=["users"])

@router.get("/me", response_model=schemas.UserResponse)
async def read_users_me(
    current_user: schemas.UserResponse = Depends(get_current_active_user)
):
    """
    Получение информации о текущем пользователе
    """
    return current_user

@router.put("/me", response_model=schemas.UserResponse)
async def update_user_me(
    user_update: schemas.UserUpdate,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Обновление информации текущего пользователя
    """
    updated_user = crud.update_user(db, current_user.id, user_update)
    if not updated_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    return updated_user

@router.get("/", response_model=List[schemas.UserResponse])
async def get_users(
    pagination: PaginationParams = Depends(),
    role: Optional[str] = Query(None, description="Фильтр по роли"),
    is_active: Optional[bool] = Query(None, description="Фильтр по активности"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение списка пользователей (только для администраторов)
    """
    users = crud.get_users(
        db,
        skip=pagination.skip,
        limit=pagination.limit,
        role=role,
        is_active=is_active
    )
    return users

@router.get("/{user_id}", response_model=schemas.UserResponse)
async def get_user_by_id(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Получение информации о пользователе по ID (только для администраторов)
    """
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    return user

@router.put("/{user_id}", response_model=schemas.UserResponse)
async def update_user(
    user_id: int,
    user_update: schemas.UserUpdate,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Обновление информации пользователя (только для администраторов)
    """
    updated_user = crud.update_user(db, user_id, user_update)
    if not updated_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    return updated_user

@router.delete("/{user_id}")
async def delete_user(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Удаление пользователя (только для администраторов)
    """
    success = crud.delete_user(db, user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    return {"message": "Пользователь удален"}

@router.post("/{user_id}/activate")
async def activate_user(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Активация пользователя (только для администраторов)
    """
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    user.is_active = True
    db.commit()
    db.refresh(user)
    
    return {"message": "Пользователь активирован"}

@router.post("/{user_id}/deactivate")
async def deactivate_user(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Деактивация пользователя (только для администраторов)
    """
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    user.is_active = False
    db.commit()
    db.refresh(user)
    
    return {"message": "Пользователь деактивирован"}

@router.get("/me/balance")
async def get_my_balance(
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Получение баланса текущего пользователя
    """
    user = crud.get_user_by_id(db, current_user.id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    return {"balance": user.balance}

@router.get("/search")
async def search_users(
    query: str = Query(..., description="Поисковый запрос (email, телефон, имя)"),
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Поиск пользователей (только для администраторов)
    """
    users = db.query(crud.models.User).filter(
        (crud.models.User.email.ilike(f"%{query}%")) |
        (crud.models.User.phone.ilike(f"%{query}%")) |
        (crud.models.User.full_name.ilike(f"%{query}%"))
    ).order_by(crud.models.User.created_at.desc())\
     .offset(pagination.skip)\
     .limit(pagination.limit)\
     .all()
    
    return users
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\schemas.py                                                         ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\schemas.py  ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Pydantic схемы для валидации данных
"""
from pydantic import BaseModel, EmailStr, ConfigDict, Field, field_validator
from typing import Optional, List
from datetime import datetime
from enum import Enum
from decimal import Decimal

# Enums for schemas
class UserRole(str, Enum):
    CLIENT = "client"
    DRIVER = "driver"
    ADMIN = "admin"

class VerificationStatus(str, Enum):
    PENDING = "pending"
    VERIFIED = "verified"
    REJECTED = "rejected"

class OrderStatus(str, Enum):
    DRAFT = "draft"
    SEARCHING = "searching"
    DRIVER_ASSIGNED = "driver_assigned"
    LOADING = "loading"
    EN_ROUTE = "en_route"
    UNLOADING = "unloading"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
    PAID = "paid"

class BidStatus(str, Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    REJECTED = "rejected"
    CANCELLED = "cancelled"

class PaymentStatus(str, Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"

# User schemas
class UserBase(BaseModel):
    email: EmailStr
    phone: str = Field(..., pattern=r'^\+?[1-9]\d{1,14}$')
    full_name: Optional[str] = None
    role: UserRole = UserRole.CLIENT

class UserCreate(UserBase):
    password: str = Field(..., min_length=8)
    
    @field_validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not any(c.islower() for c in v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one digit')
        return v

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserUpdate(BaseModel):
    phone: Optional[str] = None
    full_name: Optional[str] = None
    password: Optional[str] = None

class UserResponse(UserBase):
    id: int
    is_active: bool
    is_verified: bool
    balance: float
    created_at: datetime
    updated_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    user: UserResponse

class TokenData(BaseModel):
    user_id: Optional[int] = None
    email: Optional[str] = None
    role: Optional[str] = None
    exp: Optional[int] = None

# Driver schemas
class DriverProfileBase(BaseModel):
    vehicle_type: str
    vehicle_model: Optional[str] = None
    vehicle_number: str
    carrying_capacity: float = Field(..., gt=0)
    volume: float = Field(..., gt=0)

class DriverProfileCreate(DriverProfileBase):
    pass

class DriverProfileUpdate(BaseModel):
    vehicle_type: Optional[str] = None
    vehicle_model: Optional[str] = None
    vehicle_number: Optional[str] = None
    carrying_capacity: Optional[float] = None
    volume: Optional[float] = None
    is_online: Optional[bool] = None
    current_location_lat: Optional[float] = None
    current_location_lng: Optional[float] = None

class DriverProfileResponse(DriverProfileBase):
    id: int
    user_id: int
    verification_status: VerificationStatus
    rating: float
    total_orders: int
    total_distance: float
    is_online: bool
    current_location_lat: Optional[float] = None
    current_location_lng: Optional[float] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class DriverWithProfile(BaseModel):
    user: UserResponse
    profile: DriverProfileResponse
    model_config = ConfigDict(from_attributes=True)

# Order schemas
class OrderBase(BaseModel):
    from_address: str = Field(..., min_length=3)
    from_lat: float = Field(..., ge=-90, le=90)
    from_lng: float = Field(..., ge=-180, le=180)
    to_address: str = Field(..., min_length=3)
    to_lat: float = Field(..., ge=-90, le=90)
    to_lng: float = Field(..., ge=-180, le=180)
    cargo_description: str = Field(..., min_length=5)
    cargo_weight: float = Field(..., gt=0)
    cargo_volume: float = Field(..., gt=0)
    cargo_type: str = Field(..., min_length=2)
    desired_price: float = Field(..., gt=0)
    pickup_date: Optional[datetime] = None

class OrderCreate(OrderBase):
    pass

class OrderUpdate(BaseModel):
    status: Optional[OrderStatus] = None
    driver_id: Optional[int] = None
    final_price: Optional[float] = None
    pickup_date: Optional[datetime] = None
    delivery_date: Optional[datetime] = None

class OrderResponse(OrderBase):
    id: int
    order_number: str
    client_id: int
    driver_id: Optional[int] = None
    status: OrderStatus
    distance_km: Optional[float] = None
    final_price: Optional[float] = None
    platform_fee: Optional[float] = None
    order_amount: Optional[float] = None
    payment_status: PaymentStatus
    delivery_date: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class OrderWithRelations(OrderResponse):
    client: Optional[UserResponse] = None
    driver: Optional[UserResponse] = None
    bids: List['BidResponse'] = []
    model_config = ConfigDict(from_attributes=True)

# Bid schemas
class BidBase(BaseModel):
    proposed_price: float = Field(..., gt=0)
    message: Optional[str] = None

class BidCreate(BidBase):
    pass

class BidResponse(BidBase):
    id: int
    order_id: int
    driver_id: int
    status: BidStatus
    created_at: datetime
    updated_at: Optional[datetime] = None
    driver: Optional[UserResponse] = None
    model_config = ConfigDict(from_attributes=True)

# Message schemas
class MessageBase(BaseModel):
    content: str = Field(..., min_length=1, max_length=1000)

class MessageCreate(MessageBase):
    pass

class MessageResponse(MessageBase):
    id: int
    order_id: int
    sender_id: int
    is_read: bool
    timestamp: datetime
    sender: Optional[UserResponse] = None
    model_config = ConfigDict(from_attributes=True)

# Location schemas
class LocationBase(BaseModel):
    lat: float = Field(..., ge=-90, le=90)
    lng: float = Field(..., ge=-180, le=180)
    accuracy: Optional[float] = None
    speed: Optional[float] = None
    heading: Optional[float] = None

class LocationCreate(LocationBase):
    order_id: Optional[int] = None

class LocationResponse(LocationBase):
    id: int
    driver_id: int
    order_id: Optional[int] = None
    timestamp: datetime
    model_config = ConfigDict(from_attributes=True)

# Payment schemas
class PaymentBase(BaseModel):
    amount: float = Field(..., gt=0)
    currency: str = "RUB"
    description: Optional[str] = None

class PaymentCreate(PaymentBase):
    order_id: int
    payment_method: str

class PaymentResponse(PaymentBase):
    id: int
    user_id: int
    order_id: Optional[int] = None
    status: PaymentStatus
    payment_method: Optional[str] = None
    payment_id: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

# Notification schemas
class NotificationBase(BaseModel):
    title: str
    message: str
    type: str
    data: Optional[dict] = None

class NotificationResponse(NotificationBase):
    id: int
    user_id: int
    is_read: bool
    created_at: datetime
    model_config = ConfigDict(from_attributes=True)

# Calculator schemas
class PriceCalculationRequest(BaseModel):
    from_lat: float
    from_lng: float
    to_lat: float
    to_lng: float
    weight: float = Field(..., gt=0)
    volume: float = Field(..., gt=0)

class PriceCalculation(BaseModel):
    distance_km: float
    base_price: float
    weight_multiplier: float
    volume_multiplier: float
    suggested_price: float
    platform_fee: float
    driver_amount: float

# Admin schemas
class AdminStats(BaseModel):
    total_users: int
    total_drivers: int
    total_clients: int
    total_orders: int
    total_revenue: float
    pending_verifications: int
    active_orders: int

class VerificationRequest(BaseModel):
    driver_id: int
    status: VerificationStatus
    notes: Optional[str] = None

# Update forward references
OrderWithRelations.model_rebuild()
BidResponse.model_rebuild()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\seed.py                                                            ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\seed.py     ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Seed данные для начальной настройки базы данных
"""
from sqlalchemy.orm import Session
import random
from datetime import datetime, timedelta
from . import crud, models, schemas
from .auth import get_password_hash

def seed_database(db: Session):
    """Заполнение базы данных тестовыми данными"""
    print("🌱 Заполнение базы данных тестовыми данными...")
    
    # Проверяем, есть ли уже данные
    existing_users = db.query(models.User).count()
    if existing_users > 0:
        print("⚠️  База данных уже содержит данные. Пропускаем seed.")
        return
    
    # Создаем администратора
    print("👑 Создание администратора...")
    admin_user = models.User(
        email="admin@cargopro.com",
        phone="+79991112233",
        full_name="Администратор CargoPro",
        role=models.UserRole.ADMIN,
        is_active=True,
        is_verified=True,
        hashed_password=get_password_hash("Admin123!"),
        balance=0.0
    )
    db.add(admin_user)
    db.commit()
    db.refresh(admin_user)
    print(f"✅ Администратор создан: {admin_user.email}")
    
    # Создаем тестовых клиентов
    print("👥 Создание тестовых клиентов...")
    clients_data = [
        {
            "email": "client1@example.com",
            "phone": "+79992223344",
            "full_name": "Иван Петров",
            "password": "Client123!"
        },
        {
            "email": "client2@example.com",
            "phone": "+79993334455",
            "full_name": "Мария Сидорова",
            "password": "Client123!"
        },
        {
            "email": "company@example.com",
            "phone": "+74951234567",
            "full_name": "ООО 'Грузовик'",
            "password": "Company123!"
        }
    ]
    
    clients = []
    for client_data in clients_data:
        client = models.User(
            email=client_data["email"],
            phone=client_data["phone"],
            full_name=client_data["full_name"],
            role=models.UserRole.CLIENT,
            is_active=True,
            is_verified=True,
            hashed_password=get_password_hash(client_data["password"]),
            balance=10000.0  # Начальный баланс
        )
        db.add(client)
        clients.append(client)
    
    db.commit()
    for client in clients:
        db.refresh(client)
        print(f"✅ Клиент создан: {client.email}")
    
    # Создаем тестовых водителей
    print("🚚 Создание тестовых водителей...")
    drivers_data = [
        {
            "email": "driver1@example.com",
            "phone": "+79994445566",
            "full_name": "Алексей Водилов",
            "password": "Driver123!",
            "vehicle_type": "Грузовик",
            "vehicle_model": "Mercedes Actros",
            "vehicle_number": "А123ВС777",
            "carrying_capacity": 20.0,
            "volume": 90.0,
            "verification_status": models.VerificationStatus.VERIFIED,
            "rating": 4.8,
            "total_orders": 42,
            "total_distance": 12500.5,
            "is_online": True
        },
        {
            "email": "driver2@example.com",
            "phone": "+79995556677",
            "full_name": "Дмитрий Шоферов",
            "password": "Driver123!",
            "vehicle_type": "Фургон",
            "vehicle_model": "Ford Transit",
            "vehicle_number": "В456ОР777",
            "carrying_capacity": 3.5,
            "volume": 18.0,
            "verification_status": models.VerificationStatus.VERIFIED,
            "rating": 4.5,
            "total_orders": 28,
            "total_distance": 8500.0,
            "is_online": True
        },
        {
            "email": "driver3@example.com",
            "phone": "+79996667788",
            "full_name": "Сергей Грузовиков",
            "password": "Driver123!",
            "vehicle_type": "Рефрижератор",
            "vehicle_model": "Volvo FH",
            "vehicle_number": "С789ТУ777",
            "carrying_capacity": 18.0,
            "volume": 82.0,
            "verification_status": models.VerificationStatus.PENDING,
            "rating": 4.2,
            "total_orders": 15,
            "total_distance": 6200.0,
            "is_online": False
        },
        {
            "email": "driver4@example.com",
            "phone": "+79997778899",
            "full_name": "Павел Перевозкин",
            "password": "Driver123!",
            "vehicle_type": "Тентованный",
            "vehicle_model": "Scania R450",
            "vehicle_number": "Е012КХ777",
            "carrying_capacity": 22.0,
            "volume": 96.0,
            "verification_status": models.VerificationStatus.VERIFIED,
            "rating": 4.9,
            "total_orders": 67,
            "total_distance": 21000.0,
            "is_online": True
        }
    ]
    
    drivers = []
    for driver_data in drivers_data:
        # Создаем пользователя-водителя
        driver_user = models.User(
            email=driver_data["email"],
            phone=driver_data["phone"],
            full_name=driver_data["full_name"],
            role=models.UserRole.DRIVER,
            is_active=True,
            is_verified=True if driver_data["verification_status"] == models.VerificationStatus.VERIFIED else False,
            hashed_password=get_password_hash(driver_data["password"]),
            balance=5000.0  # Начальный баланс
        )
        db.add(driver_user)
        db.flush()  # Получаем ID пользователя
        
        # Создаем профиль водителя
        driver_profile = models.DriverProfile(
            user_id=driver_user.id,
            vehicle_type=driver_data["vehicle_type"],
            vehicle_model=driver_data["vehicle_model"],
            vehicle_number=driver_data["vehicle_number"],
            carrying_capacity=driver_data["carrying_capacity"],
            volume=driver_data["volume"],
            verification_status=driver_data["verification_status"],
            rating=driver_data["rating"],
            total_orders=driver_data["total_orders"],
            total_distance=driver_data["total_distance"],
            is_online=driver_data["is_online"],
            current_location_lat=55.7558 + random.uniform(-0.1, 0.1) if driver_data["is_online"] else None,
            current_location_lng=37.6173 + random.uniform(-0.1, 0.1) if driver_data["is_online"] else None
        )
        db.add(driver_profile)
        drivers.append(driver_user)
    
    db.commit()
    for driver in drivers:
        db.refresh(driver)
        print(f"✅ Водитель создан: {driver.email}")
    
    # Создаем тестовые заказы
    print("📦 Создание тестовых заказов...")
    orders_data = [
        {
            "client_id": clients[0].id,
            "status": models.OrderStatus.SEARCHING,
            "from_address": "Москва, Ленинский проспект, 32",
            "from_lat": 55.6911,
            "from_lng": 37.5734,
            "to_address": "Санкт-Петербург, Невский проспект, 28",
            "to_lat": 59.9343,
            "to_lng": 30.3351,
            "cargo_description": "Оборудование для офиса",
            "cargo_weight": 2.5,
            "cargo_volume": 12.0,
            "cargo_type": "Оборудование",
            "desired_price": 35000.0,
            "pickup_date": datetime.utcnow() + timedelta(days=2)
        },
        {
            "client_id": clients[1].id,
            "driver_id": drivers[0].id,
            "status": models.OrderStatus.EN_ROUTE,
            "from_address": "Екатеринбург, ул. Малышева, 51",
            "from_lat": 56.8389,
            "from_lng": 60.6057,
            "to_address": "Челябинск, пр. Ленина, 54",
            "to_lat": 55.1644,
            "to_lng": 61.4368,
            "cargo_description": "Партия одежды",
            "cargo_weight": 8.0,
            "cargo_volume": 45.0,
            "cargo_type": "Одежда",
            "desired_price": 18000.0,
            "final_price": 17500.0,
            "platform_fee": 875.0,
            "order_amount": 16625.0,
            "payment_status": models.PaymentStatus.COMPLETED,
            "pickup_date": datetime.utcnow() - timedelta(days=1),
            "delivery_date": datetime.utcnow() + timedelta(days=1)
        },
        {
            "client_id": clients[2].id,
            "status": models.OrderStatus.DRAFT,
            "from_address": "Новосибирск, Красный проспект, 28",
            "from_lat": 55.0084,
            "from_lng": 82.9357,
            "to_address": "Красноярск, ул. Карла Маркса, 48",
            "to_lat": 56.0153,
            "to_lng": 92.8932,
            "cargo_description": "Строительные материалы",
            "cargo_weight": 15.0,
            "cargo_volume": 75.0,
            "cargo_type": "Стройматериалы",
            "desired_price": 42000.0,
            "pickup_date": datetime.utcnow() + timedelta(days=3)
        },
        {
            "client_id": clients[0].id,
            "driver_id": drivers[1].id,
            "status": models.OrderStatus.COMPLETED,
            "from_address": "Казань, ул. Баумана, 44",
            "from_lat": 55.7961,
            "from_lng": 49.1064,
            "to_address": "Самара, ул. Куйбышева, 92",
            "to_lat": 53.1959,
            "to_lng": 50.1002,
            "cargo_description": "Электроника и бытовая техника",
            "cargo_weight": 3.0,
            "cargo_volume": 15.0,
            "cargo_type": "Электроника",
            "desired_price": 22000.0,
            "final_price": 21500.0,
            "platform_fee": 1075.0,
            "order_amount": 20425.0,
            "payment_status": models.PaymentStatus.COMPLETED,
            "pickup_date": datetime.utcnow() - timedelta(days=5),
            "delivery_date": datetime.utcnow() - timedelta(days=2),
            "completed_at": datetime.utcnow() - timedelta(days=2)
        },
        {
            "client_id": clients[1].id,
            "status": models.OrderStatus.SEARCHING,
            "from_address": "Ростов-на-Дону, ул. Большая Садовая, 88",
            "from_lat": 47.2224,
            "from_lng": 39.7186,
            "to_address": "Краснодар, ул. Красная, 32",
            "to_lat": 45.0355,
            "to_lng": 38.9753,
            "cargo_description": "Продукты питания (охлажденные)",
            "cargo_weight": 5.0,
            "cargo_volume": 30.0,
            "cargo_type": "Продукты",
            "desired_price": 15000.0,
            "pickup_date": datetime.utcnow() + timedelta(days=1)
        }
    ]
    
    orders = []
    for i, order_data in enumerate(orders_data):
        # Генерируем номер заказа
        order_number = crud.generate_order_number()
        
        # Расчет расстояния
        distance = crud.utils.calculate_distance(
            order_data["from_lat"], order_data["from_lng"],
            order_data["to_lat"], order_data["to_lng"]
        )
        
        order = models.Order(
            order_number=order_number,
            distance_km=distance,
            **{k: v for k, v in order_data.items() if k != 'client_id' and k != 'driver_id'}
        )
        order.client_id = order_data["client_id"]
        if "driver_id" in order_data:
            order.driver_id = order_data["driver_id"]
        
        db.add(order)
        orders.append(order)
    
    db.commit()
    for order in orders:
        db.refresh(order)
        print(f"✅ Заказ создан: {order.order_number} ({order.status})")
    
    # Создаем тестовые ставки
    print("💰 Создание тестовых ставок...")
    bids_data = [
        {
            "order_id": orders[0].id,
            "driver_id": drivers[0].id,
            "proposed_price": 34000.0,
            "message": "Могу взять заказ завтра утром",
            "status": models.BidStatus.PENDING
        },
        {
            "order_id": orders[0].id,
            "driver_id": drivers[3].id,
            "proposed_price": 33000.0,
            "message": "Еду в том направлении, могу взять дешевле",
            "status": models.BidStatus.PENDING
        },
        {
            "order_id": orders[2].id,
            "driver_id": drivers[1].id,
            "proposed_price": 40000.0,
            "message": "Специализируюсь на строительных материалах",
            "status": models.BidStatus.PENDING
        },
        {
            "order_id": orders[4].id,
            "driver_id": drivers[0].id,
            "proposed_price": 14500.0,
            "message": "Есть рефрижератор, могу перевезти продукты",
            "status": models.BidStatus.ACCEPTED
        }
    ]
    
    for bid_data in bids_data:
        bid = models.Bid(**bid_data)
        db.add(bid)
    
    db.commit()
    print(f"✅ Создано {len(bids_data)} ставок")
    
    # Создаем тестовые сообщения в чате
    print("💬 Создание тестовых сообщений...")
    messages_data = [
        {
            "order_id": orders[1].id,
            "sender_id": clients[1].id,
            "content": "Здравствуйте! Когда планируете начать погрузку?",
            "timestamp": datetime.utcnow() - timedelta(days=1, hours=3)
        },
        {
            "order_id": orders[1].id,
            "sender_id": drivers[0].id,
            "content": "Добрый день! Подъеду к 10:00 завтра",
            "timestamp": datetime.utcnow() - timedelta(days=1, hours=2, minutes=30)
        },
        {
            "order_id": orders[1].id,
            "sender_id": clients[1].id,
            "content": "Отлично, буду ждать. Нужна ли помощь с погрузкой?",
            "timestamp": datetime.utcnow() - timedelta(days=1, hours=2)
        },
        {
            "order_id": orders[1].id,
            "sender_id": drivers[0].id,
            "content": "Да, потребуется 2 человека для погрузки",
            "timestamp": datetime.utcnow() - timedelta(days=1, hours=1)
        },
        {
            "order_id": orders[3].id,
            "sender_id": clients[0].id,
            "content": "Спасибо за быструю доставку! Все в порядке",
            "timestamp": datetime.utcnow() - timedelta(days=2, hours=5)
        },
        {
            "order_id": orders[3].id,
            "sender_id": drivers[1].id,
            "content": "Рад был помочь! Обращайтесь еще",
            "timestamp": datetime.utcnow() - timedelta(days=2, hours=4)
        }
    ]
    
    for message_data in messages_data:
        message = models.Message(**message_data)
        db.add(message)
    
    db.commit()
    print(f"✅ Создано {len(messages_data)} сообщений")
    
    # Создаем тестовые платежи
    print("💳 Создание тестовых платежей...")
    payments_data = [
        {
            "user_id": clients[1].id,
            "order_id": orders[1].id,
            "amount": 17500.0,
            "currency": "RUB",
            "status": models.PaymentStatus.COMPLETED,
            "payment_method": "card",
            "payment_id": "pay_test_123456",
            "description": f"Оплата заказа #{orders[1].order_number}",
            "completed_at": datetime.utcnow() - timedelta(days=1)
        },
        {
            "user_id": clients[0].id,
            "order_id": orders[3].id,
            "amount": 21500.0,
            "currency": "RUB",
            "status": models.PaymentStatus.COMPLETED,
            "payment_method": "sbp",
            "payment_id": "pay_test_789012",
            "description": f"Оплата заказа #{orders[3].order_number}",
            "completed_at": datetime.utcnow() - timedelta(days=2)
        }
    ]
    
    for payment_data in payments_data:
        payment = models.Payment(**payment_data)
        db.add(payment)
    
    db.commit()
    print(f"✅ Создано {len(payments_data)} платежей")
    
    # Создаем тестовые уведомления
    print("🔔 Создание тестовых уведомлений...")
    notifications_data = [
        {
            "user_id": drivers[0].id,
            "title": "Новый заказ доступен",
            "message": "Появился новый заказ по вашему маршруту",
            "type": "new_order",
            "data": {"order_id": orders[0].id},
            "is_read": False,
            "created_at": datetime.utcnow() - timedelta(hours=2)
        },
        {
            "user_id": drivers[3].id,
            "title": "Новый заказ доступен",
            "message": "Появился новый заказ по вашему маршруту",
            "type": "new_order",
            "data": {"order_id": orders[0].id},
            "is_read": True,
            "created_at": datetime.utcnow() - timedelta(hours=1)
        },
        {
            "user_id": clients[1].id,
            "title": "Водитель назначен",
            "message": "На ваш заказ назначен водитель",
            "type": "driver_assigned",
            "data": {"order_id": orders[1].id, "driver_id": drivers[0].id},
            "is_read": True,
            "created_at": datetime.utcnow() - timedelta(days=1)
        },
        {
            "user_id": admin_user.id,
            "title": "Новый водитель",
            "message": "Зарегистрирован новый водитель",
            "type": "new_driver",
            "data": {"driver_id": drivers[2].id},
            "is_read": False,
            "created_at": datetime.utcnow() - timedelta(days=3)
        }
    ]
    
    for notification_data in notifications_data:
        notification = models.Notification(**notification_data)
        db.add(notification)
    
    db.commit()
    print(f"✅ Создано {len(notifications_data)} уведомлений")
    
    print("🎉 Заполнение базы данных завершено!")
    print("\n📋 Тестовые данные для входа:")
    print("=" * 50)
    print("👑 Администратор:")
    print(f"  Email: admin@cargopro.com")
    print(f"  Пароль: Admin123!")
    print()
    print("👥 Клиенты:")
    print(f"  1. Email: client1@example.com, Пароль: Client123!")
    print(f"  2. Email: client2@example.com, Пароль: Client123!")
    print(f"  3. Email: company@example.com, Пароль: Company123!")
    print()
    print("🚚 Водители:")
    print(f"  1. Email: driver1@example.com, Пароль: Driver123! (верифицирован, онлайн)")
    print(f"  2. Email: driver2@example.com, Пароль: Driver123! (верифицирован, онлайн)")
    print(f"  3. Email: driver3@example.com, Пароль: Driver123! (ожидает верификации, офлайн)")
    print(f"  4. Email: driver4@example.com, Пароль: Driver123! (верифицирован, онлайн)")
    print("=" * 50)

def clear_database(db: Session):
    """Очистка базы данных (только для тестов!)"""
    print("⚠️  Очистка базы данных...")
    
    # Порядок удаления важен из-за внешних ключей
    db.query(models.Notification).delete()
    db.query(models.Payment).delete()
    db.query(models.LocationUpdate).delete()
    db.query(models.Message).delete()
    db.query(models.Bid).delete()
    db.query(models.Order).delete()
    db.query(models.DriverProfile).delete()
    db.query(models.User).delete()
    
    db.commit()
    print("✅ База данных очищена")
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\utils.py                                                           ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\utils.py    ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Вспомогательные функции
"""
import math
from typing import Tuple
from datetime import datetime, timedelta
import re
import secrets
import string
from pathlib import Path

def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """
    Расчет расстояния между двумя координатами по формуле Хаверсина
    Возвращает расстояние в километрах
    """
    R = 6371  # Радиус Земли в километрах
    
    # Конвертация градусов в радианы
    phi1 = math.radians(lat1)
    phi2 = math.radians(lat2)
    delta_phi = math.radians(lat2 - lat1)
    delta_lambda = math.radians(lon2 - lon1)
    
    # Формула Хаверсина
    a = math.sin(delta_phi / 2) ** 2 + \
        math.cos(phi1) * math.cos(phi2) * \
        math.sin(delta_lambda / 2) ** 2
    
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c
    
    return round(distance, 2)

def calculate_price(
    distance_km: float,
    weight: float,
    volume: float,
    base_rate_per_km: float = 15.0,
    weight_rate_per_ton: float = 10.0,
    volume_rate_per_cubic: float = 5.0,
    min_price: float = 500.0
) -> Tuple[float, float, float]:
    """
    Расчет стоимости перевозки
    Возвращает: (финальная_цена, комиссия_платформы, сумма_водителю)
    """
    # Базовая цена за километр
    base_price = max(distance_km * base_rate_per_km, 100)
    
    # Надбавки за вес и объем
    weight_adjustment = weight * weight_rate_per_ton
    volume_adjustment = volume * volume_rate_per_cubic
    
    # Финальная цена
    final_price = base_price + weight_adjustment + volume_adjustment
    final_price = max(final_price, min_price)
    
    # Комиссия платформы (5%)
    platform_fee = final_price * 0.05
    
    # Сумма водителю
    driver_amount = final_price - platform_fee
    
    return round(final_price, 2), round(platform_fee, 2), round(driver_amount, 2)

def validate_phone_number(phone: str) -> bool:
    """Валидация номера телефона"""
    pattern = r'^\+?[1-9]\d{1,14}$'
    return bool(re.match(pattern, phone))

def validate_coordinates(lat: float, lng: float) -> bool:
    """Валидация координат"""
    return -90 <= lat <= 90 and -180 <= lng <= 180

def generate_verification_code(length: int = 6) -> str:
    """Генерация кода верификации"""
    return ''.join(secrets.choice(string.digits) for _ in range(length))

def format_datetime(dt: datetime) -> str:
    """Форматирование даты-времени"""
    return dt.strftime("%d.%m.%Y %H:%M")

def format_price(price: float) -> str:
    """Форматирование цены"""
    return f"{price:,.2f}".replace(",", " ").replace(".", ",") + " ₽"

def calculate_eta(distance_km: float, avg_speed_kmh: float = 60) -> timedelta:
    """Расчет примерного времени прибытия"""
    hours = distance_km / avg_speed_kmh
    return timedelta(hours=hours)

def get_file_extension(filename: str) -> str:
    """Получение расширения файла"""
    return Path(filename).suffix.lower()

def is_allowed_file(filename: str, allowed_extensions: set) -> bool:
    """Проверка расширения файла"""
    return get_file_extension(filename) in allowed_extensions

def calculate_rating(current_rating: float, new_rating: int, total_ratings: int) -> float:
    """Расчет рейтинга"""
    if total_ratings == 0:
        return new_rating
    return round((current_rating * total_ratings + new_rating) / (total_ratings + 1), 1)

def truncate_text(text: str, max_length: int = 100) -> str:
    """Обрезка текста"""
    if len(text) <= max_length:
        return text
    return text[:max_length - 3] + "..."

def generate_password(length: int = 12) -> str:
    """Генерация безопасного пароля"""
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def validate_password_strength(password: str) -> Tuple[bool, str]:
    """Проверка сложности пароля"""
    if len(password) < 8:
        return False, "Пароль должен содержать минимум 8 символов"
    
    if not any(c.isupper() for c in password):
        return False, "Пароль должен содержать хотя бы одну заглавную букву"
    
    if not any(c.islower() for c in password):
        return False, "Пароль должен содержать хотя бы одну строчную букву"
    
    if not any(c.isdigit() for c in password):
        return False, "Пароль должен содержать хотя бы одну цифру"
    
    # Проверка специальных символов не обязательна, но рекомендуется
    special_chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    if not any(c in special_chars for c in password):
        # Возвращаем True, но с рекомендацией
        return True, "Рекомендуется добавить специальные символы (!@#$%^&*)"
    
    return True, "Пароль надежный"

def calculate_driver_score(
    rating: float,
    total_orders: int,
    total_distance: float,
    response_time_avg: float
) -> float:
    """Расчет скора водителя для рекомендаций"""
    # Весовые коэффициенты
    rating_weight = 0.4
    experience_weight = 0.3
    distance_weight = 0.2
    response_weight = 0.1
    
    # Нормализация значений
    rating_score = rating / 5.0
    experience_score = min(total_orders / 100, 1.0)
    distance_score = min(total_distance / 10000, 1.0)
    response_score = 1.0 / (1.0 + response_time_avg / 3600)  # часы в секундах
    
    # Расчет общего скора
    total_score = (
        rating_score * rating_weight +
        experience_score * experience_weight +
        distance_score * distance_weight +
        response_score * response_weight
    )
    
    return round(total_score * 100, 2)
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: app\websocket_manager.py                                               ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\websocket_manager.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

"""
Менеджер WebSocket соединений
"""
from typing import Dict, List, Set, Optional
from fastapi import WebSocket, WebSocketDisconnect
from collections import defaultdict
import json
import asyncio
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class ConnectionManager:
    def __init__(self):
        # Для чата: order_id -> список WebSocket соединений
        self.chat_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # Для трекинга: driver_id -> список WebSocket соединений подписчиков
        self.tracking_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # Для водителей, отправляющих свою геопозицию
        self.driver_tracking_sockets: Dict[int, WebSocket] = {}
        
        # Для администраторов
        self.admin_connections: List[WebSocket] = []
        
        # Словарь user_id -> список активных соединений
        self.user_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # Ограничение соединений на пользователя
        self.max_connections_per_user = 5

    # Общие методы
    async def connect_user(self, websocket: WebSocket, user_id: int):
        """Подключение пользователя"""
        await websocket.accept()
        
        # Проверка лимита соединений
        if len(self.user_connections[user_id]) >= self.max_connections_per_user:
            # Закрываем самое старое соединение
            old_ws = self.user_connections[user_id].pop(0)
            try:
                await old_ws.close(code=1000)
            except:
                pass
        
        self.user_connections[user_id].append(websocket)
        logger.info(f"User {user_id} connected. Total connections: {len(self.user_connections[user_id])}")

    def disconnect_user(self, websocket: WebSocket, user_id: int):
        """Отключение пользователя"""
        if user_id in self.user_connections:
            if websocket in self.user_connections[user_id]:
                self.user_connections[user_id].remove(websocket)
                logger.info(f"User {user_id} disconnected. Remaining connections: {len(self.user_connections[user_id])}")
            
            if not self.user_connections[user_id]:
                del self.user_connections[user_id]

    async def send_to_user(self, user_id: int, message: dict):
        """Отправка сообщения конкретному пользователю"""
        if user_id in self.user_connections:
            disconnected = []
            for connection in self.user_connections[user_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    logger.error(f"Error sending to user {user_id}: {e}")
                    disconnected.append(connection)
            
            for connection in disconnected:
                self.disconnect_user(connection, user_id)

    # Методы для чата
    async def connect_chat(self, websocket: WebSocket, order_id: int, user_id: int):
        """Подключение к чату заказа"""
        await self.connect_user(websocket, user_id)
        
        if order_id not in self.chat_connections:
            self.chat_connections[order_id] = []
        
        self.chat_connections[order_id].append(websocket)
        logger.info(f"User {user_id} connected to chat for order {order_id}")

    def disconnect_chat(self, websocket: WebSocket, order_id: int, user_id: int):
        """Отключение от чата"""
        self.disconnect_user(websocket, user_id)
        
        if order_id in self.chat_connections:
            if websocket in self.chat_connections[order_id]:
                self.chat_connections[order_id].remove(websocket)
            
            if not self.chat_connections[order_id]:
                del self.chat_connections[order_id]

    async def broadcast_chat_message(self, order_id: int, message: dict, exclude_user_id: Optional[int] = None):
        """Трансляция сообщения в чат"""
        if order_id in self.chat_connections:
            disconnected = []
            for connection in self.chat_connections[order_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    logger.error(f"Error broadcasting chat message: {e}")
                    disconnected.append(connection)
            
            for connection in disconnected:
                # Находим user_id для этого соединения
                for uid, connections in self.user_connections.items():
                    if connection in connections:
                        self.disconnect_chat(connection, order_id, uid)
                        break

    # Методы для трекинга (водители)
    async def connect_driver_tracking(self, websocket: WebSocket, driver_id: int):
        """Подключение водителя для отправки геопозиции"""
        await websocket.accept()
        self.driver_tracking_sockets[driver_id] = websocket
        logger.info(f"Driver {driver_id} connected for location updates")

    def disconnect_driver_tracking(self, driver_id: int):
        """Отключение водителя от трекинга"""
        if driver_id in self.driver_tracking_sockets:
            del self.driver_tracking_sockets[driver_id]
            logger.info(f"Driver {driver_id} disconnected from location updates")

    # Методы для трекинга (подписчики)
    async def connect_tracking_subscriber(self, websocket: WebSocket, driver_id: int, user_id: int):
        """Подключение подписчика к трекингу водителя"""
        await self.connect_user(websocket, user_id)
        
        if driver_id not in self.tracking_connections:
            self.tracking_connections[driver_id] = []
        
        self.tracking_connections[driver_id].append(websocket)
        logger.info(f"User {user_id} subscribed to tracking for driver {driver_id}")

    def disconnect_tracking_subscriber(self, websocket: WebSocket, driver_id: int, user_id: int):
        """Отключение подписчика от трекинга"""
        self.disconnect_user(websocket, user_id)
        
        if driver_id in self.tracking_connections:
            if websocket in self.tracking_connections[driver_id]:
                self.tracking_connections[driver_id].remove(websocket)
            
            if not self.tracking_connections[driver_id]:
                del self.tracking_connections[driver_id]

    async def broadcast_location(self, driver_id: int, location_data: dict):
        """Трансляция местоположения водителя всем подписчикам"""
        # Отправляем подписчикам
        if driver_id in self.tracking_connections:
            disconnected = []
            for connection in self.tracking_connections[driver_id]:
                try:
                    await connection.send_json({
                        "type": "location_update",
                        "driver_id": driver_id,
                        "data": location_data,
                        "timestamp": datetime.utcnow().isoformat()
                    })
                except Exception as e:
                    logger.error(f"Error broadcasting location to subscriber: {e}")
                    disconnected.append(connection)
            
            for connection in disconnected:
                # Находим user_id для этого соединения
                for uid, connections in self.user_connections.items():
                    if connection in connections:
                        self.disconnect_tracking_subscriber(connection, driver_id, uid)
                        break
        
        # Отправляем администраторам
        disconnected_admins = []
        for connection in self.admin_connections:
            try:
                await connection.send_json({
                    "type": "admin_location_update",
                    "driver_id": driver_id,
                    "data": location_data,
                    "timestamp": datetime.utcnow().isoformat()
                })
            except Exception as e:
                logger.error(f"Error broadcasting location to admin: {e}")
                disconnected_admins.append(connection)
        
        for connection in disconnected_admins:
            if connection in self.admin_connections:
                self.admin_connections.remove(connection)

    # Методы для администраторов
    async def connect_admin(self, websocket: WebSocket, admin_id: int):
        """Подключение администратора"""
        await self.connect_user(websocket, admin_id)
        self.admin_connections.append(websocket)
        logger.info(f"Admin {admin_id} connected")

    def disconnect_admin(self, websocket: WebSocket, admin_id: int):
        """Отключение администратора"""
        self.disconnect_user(websocket, admin_id)
        if websocket in self.admin_connections:
            self.admin_connections.remove(websocket)

    async def broadcast_admin_notification(self, notification: dict):
        """Трансляция уведомления администраторам"""
        disconnected = []
        for connection in self.admin_connections:
            try:
                await connection.send_json({
                    "type": "admin_notification",
                    "data": notification,
                    "timestamp": datetime.utcnow().isoformat()
                })
            except Exception as e:
                logger.error(f"Error broadcasting admin notification: {e}")
                disconnected.append(connection)
        
        for connection in disconnected:
            if connection in self.admin_connections:
                self.admin_connections.remove(connection)

    async def broadcast_system_message(self, message: dict, user_ids: Optional[List[int]] = None):
        """Трансляция системного сообщения"""
        if user_ids:
            # Отправляем конкретным пользователям
            for user_id in user_ids:
                await self.send_to_user(user_id, {
                    "type": "system_message",
                    "data": message,
                    "timestamp": datetime.utcnow().isoformat()
                })
        else:
            # Отправляем всем пользователям
            for user_id in list(self.user_connections.keys()):
                await self.send_to_user(user_id, {
                    "type": "system_message",
                    "data": message,
                    "timestamp": datetime.utcnow().isoformat()
                })

    # Статистика
    def get_stats(self) -> dict:
        """Получение статистики соединений"""
        return {
            "total_users_connected": len(self.user_connections),
            "total_connections": sum(len(conns) for conns in self.user_connections.values()),
            "active_chats": len(self.chat_connections),
            "drivers_tracking": len(self.driver_tracking_sockets),
            "tracking_subscriptions": len(self.tracking_connections),
            "admins_connected": len(self.admin_connections)
        }

# Глобальный экземпляр менеджера
manager = ConnectionManager()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: check_db.py                                                            ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\check_db.py     ║
╚══════════════════════════════════════════════════════════════════════════════╝

# check_db.py
"""
Проверка базы данных
"""
import os
import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.database import engine, Base
from app.config import settings

print("Проверка базы данных...")
print(f"Database URL: {settings.DATABASE_URL}")

# Проверяем файл SQLite
if settings.DATABASE_URL.startswith("sqlite"):
    db_path = settings.DATABASE_URL.replace("sqlite:///", "")
    print(f"SQLite файл: {db_path}")
    
    if os.path.exists(db_path):
        print(f"Файл БД существует, размер: {os.path.getsize(db_path)} байт")
    else:
        print("Файл БД не существует")

# Пытаемся создать таблицы
try:
    print("\nПопытка создать таблицы...")
    Base.metadata.create_all(bind=engine)
    print("Таблицы успешно созданы!")
except Exception as e:
    print(f"Ошибка при создании таблиц: {e}")
    print(f"Тип ошибки: {type(e)}")
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: code.py                                                                ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\code.py         ║
╚══════════════════════════════════════════════════════════════════════════════╝

import os
import argparse
from pathlib import Path

def should_skip_directory(dir_name):
    """Проверяет, нужно ли пропускать директорию"""
    skip_dirs = {
        'node_modules', '.git', 'build', 'dist', 'coverage', 
        '.next', '.nuxt', '.cache', 'assets', 'static',
        'public', '.vscode', '.idea', '__pycache__', 'cache',
        'logs', 'temp', 'tmp', 'vendor', 'bin', 'obj'
    }
    return dir_name in skip_dirs or dir_name.startswith('.')

def should_skip_file(file_name):
    """Проверяет, нужно ли пропускать файл"""
    skip_files = {
        'package.json', 'package-lock.json', 'yarn.lock',
        'tsconfig.json', 'webpack.config.js', '.eslintrc.js',
        '.prettierrc', 'babel.config.js', 'next.config.js',
        'jest.config.js', 'vue.config.js', 'nuxt.config.js',
        '.gitignore', '.env', '.env.local', 'README.md'
    }
    return file_name in skip_files

def is_target_file(file_name):
    """Проверяет, является ли файл целевым (JS/JSX/TS/TSX и другие исходные файлы)"""
    target_extensions = {
        '.js', '.jsx', '.ts', '.tsx', '.vue', '.svelte',
        '.css', '.scss', '.less', '.html', '.htm', '.json',
        '.py', '.java', '.cpp', '.c', '.h', '.cs', '.php',
        '.rb', '.go', '.rs', '.swift', '.kt', '.dart'
    }
    return any(file_name.endswith(ext) for ext in target_extensions)

def get_file_category(file_extension):
    """Возвращает категорию файла для группировки"""
    categories = {
        '.js': 'JavaScript',
        '.jsx': 'React JSX',
        '.ts': 'TypeScript', 
        '.tsx': 'React TypeScript',
        '.vue': 'Vue',
        '.svelte': 'Svelte',
        '.py': 'Python',
        '.html': 'HTML',
        '.css': 'CSS',
        '.scss': 'SCSS',
        '.less': 'LESS',
        '.json': 'JSON',
        '.java': 'Java',
        '.cpp': 'C++',
        '.c': 'C',
        '.cs': 'C#',
        '.php': 'PHP',
        '.rb': 'Ruby',
        '.go': 'Go',
        '.rs': 'Rust',
        '.swift': 'Swift',
        '.kt': 'Kotlin',
        '.dart': 'Dart'
    }
    return categories.get(file_extension, 'Other')

def format_file_header(file_path, relative_path, category):
    """Форматирует заголовок файла"""
    header = []
    header.append("╔" + "═" * 78 + "╗")
    header.append(f"║ ФАЙЛ: {relative_path:<70} ║")
    header.append(f"║ КАТЕГОРИЯ: {category:<65} ║")
    header.append(f"║ ПОЛНЫЙ ПУТЬ: {file_path:<64} ║")
    header.append("╚" + "═" * 78 + "╝")
    return '\n'.join(header)

def format_file_footer():
    """Форматирует подвал файла"""
    return "\n" + "─" * 80 + "\n"

def collect_source_files(root_dir, output_file):
    """Рекурсивно собирает исходные файлы и записывает их в output_file"""
    
    root_path = Path(root_dir)
    files_by_category = {}
    total_files = 0
    
    print("🔍 Сканирую структуру проекта...")
    
    # Сначала собираем все файлы по категориям
    for root, dirs, files in os.walk(root_dir):
        # Удаляем директории, которые нужно пропустить
        dirs[:] = [d for d in dirs if not should_skip_directory(d)]
        
        for file in files:
            if should_skip_file(file):
                continue
                
            if is_target_file(file):
                file_path = Path(root) / file
                relative_path = file_path.relative_to(root_path)
                file_extension = file_path.suffix.lower()
                category = get_file_category(file_extension)
                
                if category not in files_by_category:
                    files_by_category[category] = []
                
                files_by_category[category].append((file_path, relative_path))
                total_files += 1
    
    print(f"📁 Найдено {total_files} файлов в {len(files_by_category)} категориях")
    
    # Записываем файлы в выходной файл, сгруппированные по категориям
    with open(output_file, 'w', encoding='utf-8') as out_f:
        # Заголовок документа
        out_f.write("=" * 80 + "\n")
        out_f.write(f"ИСХОДНЫЙ КОД ПРОЕКТА\n")
        out_f.write(f"Директория: {root_dir}\n")
        out_f.write(f"Всего файлов: {total_files}\n")
        out_f.write("=" * 80 + "\n\n")
        
        # Проходим по категориям в алфавитном порядке
        for category in sorted(files_by_category.keys()):
            files_in_category = files_by_category[category]
            
            # Заголовок категории
            out_f.write("\n" + "■" * 80 + "\n")
            out_f.write(f"КАТЕГОРИЯ: {category} ({len(files_in_category)} файлов)\n")
            out_f.write("■" * 80 + "\n\n")
            
            # Сортируем файлы по пути
            for file_path, relative_path in sorted(files_in_category, key=lambda x: str(x[1])):
                try:
                    # Записываем заголовок файла
                    out_f.write(format_file_header(str(file_path), str(relative_path), category))
                    out_f.write("\n\n")
                    
                    # Читаем и записываем содержимое файла
                    with open(file_path, 'r', encoding='utf-8') as in_f:
                        content = in_f.read().rstrip()  # Убираем лишние пробелы в конце
                        out_f.write(content)
                    
                    # Записываем подвал файла
                    out_f.write(format_file_footer())
                    
                    print(f"✅ Обработан: {relative_path}")
                    
                except UnicodeDecodeError:
                    try:
                        # Пробуем другую кодировку
                        with open(file_path, 'r', encoding='cp1251') as in_f:
                            content = in_f.read().rstrip()
                            out_f.write(content)
                        out_f.write(format_file_footer())
                        print(f"✅ Обработан (Windows-1251): {relative_path}")
                    except Exception as e:
                        out_f.write(f"// ⚠️ Ошибка чтения файла: {e}\n")
                        out_f.write(format_file_footer())
                        print(f"❌ Ошибка: {relative_path} - {e}")
                        
                except Exception as e:
                    out_f.write(f"// ⚠️ Ошибка чтения файла: {e}\n")
                    out_f.write(format_file_footer())
                    print(f"❌ Ошибка: {relative_path} - {e}")

def main():
    parser = argparse.ArgumentParser(
        description='📁 Сборщик исходного кода проекта - создает структурированный файл со всем кодом',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('--input', '-i', default='.', 
                       help='Входная директория (по умолчанию текущая)')
    parser.add_argument('--output', '-o', default='project_code.txt',
                       help='Выходной файл (по умолчанию project_code.txt)')
    
    args = parser.parse_args()
    
    input_dir = os.path.abspath(args.input)
    output_file = args.output
    
    if not os.path.exists(input_dir):
        print(f"❌ Ошибка: Директория {input_dir} не существует!")
        return
    
    print("🚀 Запуск сборщика исходного кода...")
    print(f"📂 Исходная директория: {input_dir}")
    print(f"💾 Выходной файл: {output_file}")
    print("-" * 60)
    
    collect_source_files(input_dir, output_file)
    
    print("-" * 60)
    print(f"🎉 Сборка завершена успешно!")
    print(f"📄 Все файлы сохранены в: {output_file}")

if __name__ == "__main__":
    main()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: init_db.py                                                             ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\init_db.py      ║
╚══════════════════════════════════════════════════════════════════════════════╝

# init_db.py
"""
Инициализация базы данных с правильной кодировкой
"""
import os
import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.database import engine, Base
import sqlalchemy
import traceback

print("Инициализация базы данных...")

try:
    # Создаем таблицы с указанием кодировки
    Base.metadata.create_all(bind=engine)
    print("База данных успешно инициализирована!")
    
    # Проверяем соединение
    with engine.connect() as conn:
        result = conn.execute("SELECT 1").scalar()
        print(f"Проверка соединения: {result}")
        
except Exception as e:
    print(f"Ошибка: {e}")
    traceback.print_exc()
    
    # Пробуем альтернативный подход
    print("\nПробуем альтернативный подход...")
    try:
        # Создаем движок с явной кодировкой
        from sqlalchemy import create_engine
        from app.config import settings
        
        new_engine = create_engine(
            settings.DATABASE_URL,
            connect_args={"check_same_thread": False},
            echo=True
        )
        
        Base.metadata.create_all(bind=new_engine)
        print("База данных создана с альтернативным движком!")
        
    except Exception as e2:
        print(f"Альтернативный подход также не сработал: {e2}")
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: run.py                                                                 ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\run.py          ║
╚══════════════════════════════════════════════════════════════════════════════╝

#!/usr/bin/env python3
"""
Запуск сервера CargoPro
"""
import uvicorn
import os
from dotenv import load_dotenv

load_dotenv()

if __name__ == "__main__":
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", 8000))
    reload = os.getenv("DEBUG", "True").lower() == "true"
    
    print(f"🚀 Запуск CargoPro Backend на {host}:{port}")
    print(f"📊 Документация API: http://{host}:{port}/api/docs")
    print(f"🔧 Режим разработки: {reload}")
    
    uvicorn.run(
        "app.main:app",
        host=host,
        port=port,
        reload=reload,
        log_level="info"
    )
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: seed_data.py                                                           ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\seed_data.py    ║
╚══════════════════════════════════════════════════════════════════════════════╝

#!/usr/bin/env python3
"""
Скрипт для заполнения базы данных тестовыми данными
"""
import sys
import os

# Добавляем путь к приложению
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.database import SessionLocal, engine
from app.models import Base
from app.seed import seed_database, clear_database

def main():
    """Основная функция"""
    print("🌱 Генератор тестовых данных для CargoPro")
    print("=" * 50)
    
    # Создаем таблицы если их нет
    try:
        Base.metadata.create_all(bind=engine)
        print("✅ Таблицы базы данных созданы")
    except Exception as e:
        print(f"❌ Ошибка создания таблиц: {e}")
        return
    
    # Создаем сессию базы данных
    db = SessionLocal()
    
    try:
        # Очищаем базу данных (опционально)
        if len(sys.argv) > 1 and sys.argv[1] == "--clear":
            print("🧹 Очистка базы данных...")
            clear_database(db)
        
        # Заполняем базу данных тестовыми данными
        seed_database(db)
        
        print("=" * 50)
        print("🎉 Тестовые данные успешно созданы!")
        print("\n📋 Тестовые учетные записи:")
        print("-" * 40)
        print("👑 Администратор:")
        print("  Email: admin@cargopro.com")
        print("  Пароль: Admin123!")
        print()
        print("👥 Клиенты:")
        print("  1. Email: client1@example.com, Пароль: Client123!")
        print("  2. Email: client2@example.com, Пароль: Client123!")
        print("  3. Email: company@example.com, Пароль: Company123!")
        print()
        print("🚚 Водители:")
        print("  1. Email: driver1@example.com, Пароль: Driver123!")
        print("  2. Email: driver2@example.com, Пароль: Driver123!")
        print("  3. Email: driver3@example.com, Пароль: Driver123!")
        print("  4. Email: driver4@example.com, Пароль: Driver123!")
        print("-" * 40)
        print("\n🚀 Запустите сервер командой: python run.py")
        print("📚 Документация API: http://localhost:8000/api/docs")
        
    except Exception as e:
        print(f"❌ Ошибка при заполнении базы данных: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    main()
────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════╗
║ ФАЙЛ: test_cargopro_api.py                                                   ║
║ КАТЕГОРИЯ: Python                                                            ║
║ ПОЛНЫЙ ПУТЬ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\test_cargopro_api.py ║
╚══════════════════════════════════════════════════════════════════════════════╝

# test_cargopro_api.py
"""
Тесты для проверки всех эндпоинтов CargoPro API
IP адрес: 192.168.10.102
"""

import requests
import json
import time
import os
import sys
from datetime import datetime
import logging

# Настройка логгера
logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)

# Конфигурация
BASE_URL = "http://192.168.10.102:8000"
API_URL = f"{BASE_URL}/api"

# Тестовые данные
TEST_ADMIN = {
    "username": "admin@cargopro.com",
    "password": "Admin123!"
}

TEST_CLIENT = {
    "username": "client1@example.com",
    "password": "Client123!"
}

TEST_DRIVER = {
    "username": "driver1@example.com",
    "password": "Driver123!"
}

# Глобальные переменные для хранения токенов и ID
tokens = {}
user_ids = {}
order_id = None
bid_id = None

# Вспомогательные функции
def get_auth_headers(user_type="admin"):
    """Получение заголовков с токеном авторизации"""
    token = tokens.get(user_type)
    if not token:
        return {}
    return {"Authorization": f"Bearer {token}"}

def make_request(method, endpoint, data=None, headers=None, user_type="admin", expected_status=200):
    """Универсальная функция для выполнения запросов"""
    url = f"{API_URL}{endpoint}"
    
    if headers is None:
        headers = get_auth_headers(user_type)
    
    if data and method in ["POST", "PUT"]:
        headers["Content-Type"] = "application/json"
    
    logger.info(f"Making {method} request to {endpoint}")
    
    try:
        if method == "GET":
            if data:
                response = requests.get(url, headers=headers, params=data)
            else:
                response = requests.get(url, headers=headers)
        elif method == "POST":
            response = requests.post(url, json=data, headers=headers)
        elif method == "PUT":
            response = requests.put(url, json=data, headers=headers)
        elif method == "DELETE":
            response = requests.delete(url, headers=headers)
        else:
            raise ValueError(f"Unsupported method: {method}")
        
        logger.info(f"Response status: {response.status_code}")
        
        if response.status_code != expected_status:
            logger.error(f"Request failed: {response.status_code} - {response.text}")
        
        assert response.status_code == expected_status, f"Expected {expected_status}, got {response.status_code}: {response.text}"
        
        return response
    except Exception as e:
        logger.error(f"Request error: {e}")
        raise

def login_user(user_data, user_type):
    """Вход пользователя"""
    response = requests.post(f"{API_URL}/auth/login", 
                           data=user_data,
                           headers={"Content-Type": "application/x-www-form-urlencoded"})
    
    if response.status_code == 200:
        data = response.json()
        tokens[user_type] = data["access_token"]
        user_ids[user_type] = data["user"]["id"]
        logger.info(f"{user_type.capitalize()} logged in: {user_data['username']}")
        return True
    else:
        logger.error(f"Login failed for {user_type}: {response.status_code} - {response.text}")
        return False

# Основные тесты
class TestAuthAPI:
    """Тесты для эндпоинтов аутентификации"""
    
    def test_health_check(self):
        """Тест проверки здоровья API"""
        response = requests.get(BASE_URL)
        assert response.status_code == 200
        data = response.json()
        assert "message" in data
        logger.info(f"Health check: {data['message']}")
        return True
    
    def test_register_new_user(self):
        """Тест регистрации нового пользователя"""
        timestamp = int(time.time())
        new_user = {
            "email": f"testuser{timestamp}@example.com",
            "phone": f"+7999{timestamp % 10000000:07d}",
            "full_name": f"Test User {timestamp}",
            "role": "client",
            "password": "Test123!"
        }
        
        response = requests.post(f"{API_URL}/auth/register", json=new_user)
        
        if response.status_code in [200, 400]:
            # 400 - пользователь уже существует, это тоже нормально для тестов
            logger.info(f"User registration attempt: {response.status_code}")
            return True
        
        assert response.status_code == 200
        data = response.json()
        assert "email" in data
        logger.info(f"New user registered: {data['email']}")
        return True
    
    def test_login_admin(self):
        """Тест входа администратора"""
        return login_user(TEST_ADMIN, "admin")
    
    def test_login_client(self):
        """Тест входа клиента"""
        return login_user(TEST_CLIENT, "client")
    
    def test_login_driver(self):
        """Тест входа водителя"""
        return login_user(TEST_DRIVER, "driver")
    
    def test_get_current_user(self):
        """Тест получения информации о текущем пользователе"""
        response = make_request("GET", "/auth/me", user_type="admin")
        data = response.json()
        assert "email" in data
        assert data["email"] == TEST_ADMIN["username"]
        logger.info(f"Current user: {data['email']}")
        return True
    
    def test_refresh_token(self):
        """Тест обновления токена"""
        # Сначала получаем refresh токен
        login_response = requests.post(f"{API_URL}/auth/login", 
                                     data=TEST_ADMIN,
                                     headers={"Content-Type": "application/x-www-form-urlencoded"})
        
        if login_response.status_code != 200:
            logger.warning("Skipping refresh token test - login failed")
            return True
        
        refresh_token = login_response.json()["refresh_token"]
        
        response = requests.post(f"{API_URL}/auth/refresh", 
                               json={"refresh_token": refresh_token})
        
        if response.status_code == 200:
            data = response.json()
            assert "access_token" in data
            logger.info("Token refreshed successfully")
        else:
            logger.warning(f"Refresh token test failed: {response.status_code}")
        
        return True

class TestUsersAPI:
    """Тесты для эндпоинтов пользователей"""
    
    def test_get_user_profile(self):
        """Тест получения профиля пользователя"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        response = make_request("GET", "/users/me", user_type="client")
        data = response.json()
        assert "email" in data
        assert data["email"] == TEST_CLIENT["username"]
        logger.info(f"User profile retrieved: {data['email']}")
        return True
    
    def test_update_user_profile(self):
        """Тест обновления профиля пользователя"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        update_data = {
            "full_name": "Updated Test User",
            "phone": "+79991112233"
        }
        
        response = make_request("PUT", "/users/me", update_data, user_type="client")
        data = response.json()
        assert data["full_name"] == update_data["full_name"]
        logger.info(f"User profile updated: {data['full_name']}")
        return True
    
    def test_get_all_users_admin(self):
        """Тест получения списка пользователей (только админ)"""
        if not tokens.get("admin"):
            logger.warning("Skipping test - admin not logged in")
            return True
        
        response = make_request("GET", "/users/", user_type="admin")
        data = response.json()
        assert isinstance(data, list)
        logger.info(f"Retrieved {len(data)} users")
        return True
    
    def test_get_user_by_id(self):
        """Тест получения пользователя по ID (только админ)"""
        if not tokens.get("admin") or not user_ids.get("client"):
            logger.warning("Skipping test - admin or client ID not available")
            return True
        
        response = make_request("GET", f"/users/{user_ids['client']}", user_type="admin")
        data = response.json()
        assert data["id"] == user_ids["client"]
        logger.info(f"User retrieved by ID: {data['email']}")
        return True
    
    def test_get_user_balance(self):
        """Тест получения баланса пользователя"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        response = make_request("GET", "/users/me/balance", user_type="client")
        data = response.json()
        assert "balance" in data
        logger.info(f"User balance: {data['balance']}")
        return True

class TestOrdersAPI:
    """Тесты для эндпоинтов заказов"""
    
    def test_create_order(self):
        """Тест создания нового заказа"""
        global order_id
        
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        order_data = {
            "from_address": "Москва, Ленинский проспект, 32",
            "from_lat": 55.6911,
            "from_lng": 37.5734,
            "to_address": "Санкт-Петербург, Невский проспект, 28",
            "to_lat": 59.9343,
            "to_lng": 30.3351,
            "cargo_description": "Тестовый груз для проверки API",
            "cargo_weight": 2.5,
            "cargo_volume": 12.0,
            "cargo_type": "Оборудование",
            "desired_price": 35000.0
        }
        
        response = make_request("POST", "/orders/", order_data, user_type="client")
        data = response.json()
        
        assert "order_number" in data
        assert "id" in data
        order_id = data["id"]
        
        logger.info(f"Order created: {data['order_number']} (ID: {order_id})")
        return True
    
    def test_get_my_orders(self):
        """Тест получения списка заказов пользователя"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        response = make_request("GET", "/orders/", user_type="client")
        data = response.json()
        assert isinstance(data, list)
        logger.info(f"Retrieved {len(data)} orders for client")
        return True
    
    def test_get_order_by_id(self):
        """Тест получения заказа по ID"""
        if not tokens.get("client") or not order_id:
            logger.warning("Skipping test - client not logged in or no order created")
            return True
        
        response = make_request("GET", f"/orders/{order_id}", user_type="client")
        data = response.json()
        assert data["id"] == order_id
        logger.info(f"Order retrieved: {data['order_number']}")
        return True
    
    def test_publish_order(self):
        """Тест публикации заказа"""
        if not tokens.get("client") or not order_id:
            logger.warning("Skipping test - client not logged in or no order created")
            return True
        
        response = make_request("POST", f"/orders/{order_id}/publish", user_type="client")
        data = response.json()
        assert "message" in data
        logger.info(f"Order published: {data['message']}")
        return True
    
    def test_get_available_orders(self):
        """Тест получения доступных заказов (для водителей)"""
        if not tokens.get("driver"):
            logger.warning("Skipping test - driver not logged in")
            return True
        
        response = make_request("GET", "/orders/available", user_type="driver")
        data = response.json()
        assert isinstance(data, list)
        logger.info(f"Retrieved {len(data)} available orders")
        return True
    
    def test_calculate_price(self):
        """Тест расчета стоимости перевозки"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        calc_data = {
            "from_lat": 55.7558,
            "from_lng": 37.6173,
            "to_lat": 59.9343,
            "to_lng": 30.3351,
            "weight": 2.5,
            "volume": 12.0
        }
        
        response = make_request("POST", "/orders/calculate-price", calc_data, user_type="client")
        data = response.json()
        assert "suggested_price" in data
        logger.info(f"Price calculated: {data['suggested_price']}")
        return True

# Функция для запуска всех тестов
def run_all_tests():
    """Запуск всех тестов последовательно"""
    test_classes = [
        TestAuthAPI(),
        TestUsersAPI(),
        TestOrdersAPI()
    ]
    
    total_tests = 0
    passed_tests = 0
    failed_tests = []
    
    logger.info("=" * 80)
    logger.info("НАЧАЛО ТЕСТИРОВАНИЯ CARGO PRO API - БАЗОВЫЕ ТЕСТЫ")
    logger.info("=" * 80)
    
    for test_class in test_classes:
        class_name = test_class.__class__.__name__
        logger.info(f"\nТестируем: {class_name}")
        logger.info("-" * 60)
        
        # Получаем все методы тестирования из класса
        test_methods = [method for method in dir(test_class) 
                       if method.startswith('test_') and callable(getattr(test_class, method))]
        
        for method_name in test_methods:
            total_tests += 1
            method = getattr(test_class, method_name)
            
            try:
                result = method()
                if result:
                    logger.info(f"✓ {method_name}: PASSED")
                    passed_tests += 1
                else:
                    logger.warning(f"⚠ {method_name}: SKIPPED")
                    passed_tests += 0.5  # Половина балла за пропущенные тесты
            except AssertionError as e:
                logger.error(f"✗ {method_name}: FAILED - Assertion Error: {str(e)}")
                failed_tests.append(f"{class_name}.{method_name}: {str(e)}")
            except Exception as e:
                logger.error(f"✗ {method_name}: FAILED - {str(e)}")
                failed_tests.append(f"{class_name}.{method_name}: {str(e)}")
    
    # Вывод результатов
    logger.info("\n" + "=" * 80)
    logger.info("РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ")
    logger.info("=" * 80)
    logger.info(f"Всего тестов: {total_tests}")
    logger.info(f"Пройдено: {passed_tests:.1f}")
    logger.info(f"Успешность: {(passed_tests/total_tests*100):.1f}%")
    
    if failed_tests:
        logger.info("\nПРОВАЛЕННЫЕ ТЕСТЫ:")
        for failed_test in failed_tests:
            logger.info(f"  - {failed_test}")
    else:
        logger.info("\nВСЕ ТЕСТЫ ПРОЙДЕНЫ УСПЕШНО!")
    
    return passed_tests >= total_tests * 0.8  # 80% успешности

def main():
    """Основная функция"""
    # Проверка доступности сервера
    try:
        logger.info(f"Проверяю доступность сервера {BASE_URL}...")
        response = requests.get(BASE_URL, timeout=10)
        if response.status_code == 200:
            logger.info(f"✓ Сервер доступен по адресу {BASE_URL}")
            
            # Запуск тестов
            success = run_all_tests()
            
            if success:
                logger.info("\n✅ ОСНОВНЫЕ ЭНДПОИНТЫ РАБОТАЮТ КОРРЕКТНО!")
                logger.info("\nСледующие шаги:")
                logger.info("1. Проверьте базу данных с помощью: python seed_data.py")
                logger.info("2. Запустите полное тестирование после заполнения БД")
                exit(0)
            else:
                logger.info("\n⚠ НЕКОТОРЫЕ ТЕСТЫ ПРОВАЛИЛИСЬ!")
                logger.info("\nРекомендации:")
                logger.info("1. Запустите: python seed_data.py для заполнения БД")
                logger.info("2. Убедитесь, что сервер запущен: python run.py")
                logger.info("3. Проверьте файл .env с настройками")
                exit(1)
        else:
            logger.error(f"✗ Сервер недоступен или вернул ошибку: {response.status_code}")
            exit(1)
    except requests.exceptions.ConnectionError:
        logger.error(f"✗ Не удалось подключиться к серверу {BASE_URL}")
        logger.info("\nУбедитесь, что:")
        logger.info("1. Сервер запущен (python run.py)")
        logger.info("2. IP адрес верный (192.168.10.102)")
        logger.info("3. Порт 8000 открыт")
        logger.info("4. Файрвол не блокирует соединение")
        exit(1)
    except Exception as e:
        logger.error(f"✗ Ошибка при подключении: {str(e)}")
        exit(1)

if __name__ == "__main__":
    main()
────────────────────────────────────────────────────────────────────────────────
