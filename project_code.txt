================================================================================
Ğ˜Ğ¡Ğ¥ĞĞ”ĞĞ«Ğ™ ĞšĞĞ” ĞŸĞ ĞĞ•ĞšĞ¢Ğ
Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend
Ğ’ÑĞµĞ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: 37
================================================================================


â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python (37 Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²)
â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\__init__.py                                                        â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\__init__.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\auth.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\auth.py     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ĞÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¸ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ - Ğ ĞĞ‘ĞĞ§ĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯
"""
from datetime import datetime, timedelta, timezone
from typing import Optional, Annotated
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
import secrets
import hashlib

from . import models, schemas
from .database import get_db
from .config import settings

# Ğ¡Ñ…ĞµĞ¼Ğ° OAuth2 Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ñ‚Ğ¾ĞºĞµĞ½Ğ°
oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="/api/auth/login",
    auto_error=False
)

ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES
REFRESH_TOKEN_EXPIRE_DAYS = settings.REFRESH_TOKEN_EXPIRE_DAYS

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ - SHA256"""
    try:
        test_hash = hashlib.sha256(plain_password.encode()).hexdigest()
        return test_hash == hashed_password
    except Exception as e:
        print(f"Password verification error: {e}")
        return False

def get_password_hash(password: str) -> str:
    """Ğ¥ĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ - SHA256"""
    return hashlib.sha256(password.encode()).hexdigest()

def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ email"""
    return db.query(models.User).filter(models.User.email == email).first()

def get_user_by_id(db: Session, user_id: int) -> Optional[models.User]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ ID"""
    return db.query(models.User).filter(models.User.id == user_id).first()

def authenticate_user(db: Session, email: str, password: str) -> Optional[models.User]:
    """ĞÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    print(f"ğŸ” Authenticating user: {email}")
    user = get_user_by_email(db, email)
    if not user:
        print(f"âŒ User not found: {email}")
        return None
    
    if not verify_password(password, user.hashed_password):
        print(f"âŒ Wrong password for: {email}")
        return None
    
    print(f"âœ… User authenticated: {email}, role: {user.role}")
    return user

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ access Ñ‚Ğ¾ĞºĞµĞ½Ğ°"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({
        "exp": expire,
        "type": "access",
        "jti": secrets.token_urlsafe(32)
    })
    
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

def create_refresh_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ refresh Ñ‚Ğ¾ĞºĞµĞ½Ğ°"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    
    to_encode.update({
        "exp": expire,
        "type": "refresh",
        "jti": secrets.token_urlsafe(32)
    })
    
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

def verify_token(token: str) -> Optional[dict]:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¾ĞºĞµĞ½Ğ°"""
    try:
        return jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
    except JWTError:
        return None

async def get_current_user(
    token: Annotated[str, Depends(oauth2_scheme)],
    db: Session = Depends(get_db)
) -> models.User:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸Ğ· Ñ‚Ğ¾ĞºĞµĞ½Ğ°"""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    payload = verify_token(token)
    if payload is None:
        raise credentials_exception
    
    user_id: int = payload.get("user_id")
    token_type: str = payload.get("type")
    
    if user_id is None or token_type != "access":
        raise credentials_exception
    
    user = get_user_by_id(db, user_id)
    if user is None:
        raise credentials_exception
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User is inactive"
        )
    
    return user

async def get_current_active_user(
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)]
) -> schemas.UserResponse:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User is inactive"
        )
    return current_user

def check_user_role(user: models.User, allowed_roles: list) -> bool:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ€Ğ¾Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    if user.role not in allowed_roles:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Operation not allowed for {user.role} role"
        )
    return True

# Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ€Ğ¾Ğ»ĞµĞ¹
async def get_current_admin(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹"""
    check_user_role(current_user, [models.UserRole.ADMIN])
    return current_user

async def get_current_driver(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸"""
    check_user_role(current_user, [models.UserRole.DRIVER])
    return current_user

async def get_current_client(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹"""
    check_user_role(current_user, [models.UserRole.CLIENT])
    return current_user

async def get_current_client_or_admin(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹ Ğ¸Ğ»Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹"""
    check_user_role(current_user, [models.UserRole.CLIENT, models.UserRole.ADMIN])
    return current_user

async def get_current_driver_or_admin(
    current_user: Annotated[models.User, Depends(get_current_user)]
) -> models.User:
    """Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸ Ğ¸Ğ»Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹"""
    check_user_role(current_user, [models.UserRole.DRIVER, models.UserRole.ADMIN])
    return current_user
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\config.py                                                          â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\config.py   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
"""
from pydantic_settings import BaseSettings
from typing import List
import os
from dotenv import load_dotenv

load_dotenv()

class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite:///./cargopro.db")
    
    # JWT
    SECRET_KEY: str = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
    ALGORITHM: str = os.getenv("ALGORITHM", "HS256")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30"))
    REFRESH_TOKEN_EXPIRE_DAYS: int = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS", "7"))
    
    # CORS
    ALLOWED_ORIGINS: List[str] = eval(os.getenv("ALLOWED_ORIGINS", '["http://localhost:3000", "http://localhost:8080"]'))
    
    # Server
    HOST: str = os.getenv("HOST", "0.0.0.0")
    PORT: int = int(os.getenv("PORT", "8000"))
    DEBUG: bool = os.getenv("DEBUG", "True").lower() == "true"
    
    # File upload
    UPLOAD_DIR: str = os.getenv("UPLOAD_DIR", "./uploads")
    MAX_FILE_SIZE_MB: int = int(os.getenv("MAX_FILE_SIZE_MB", "10"))
    
    # Redis
    REDIS_URL: str = os.getenv("REDIS_URL", "redis://localhost:6379/0")
    
    # Email
    SMTP_SERVER: str = os.getenv("SMTP_SERVER", "")
    SMTP_PORT: int = int(os.getenv("SMTP_PORT", "587"))
    SMTP_USERNAME: str = os.getenv("SMTP_USERNAME", "")
    SMTP_PASSWORD: str = os.getenv("SMTP_PASSWORD", "")
    EMAIL_FROM: str = os.getenv("EMAIL_FROM", "noreply@cargopro.com")
    
    # Payment
    STRIPE_SECRET_KEY: str = os.getenv("STRIPE_SECRET_KEY", "")
    STRIPE_PUBLIC_KEY: str = os.getenv("STRIPE_PUBLIC_KEY", "")
    
    # Test mode
    TEST_MODE: bool = os.getenv("TEST_MODE", "False").lower() == "true"
    
    class Config:
        env_file = ".env"

settings = Settings()

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¾Ğº
os.makedirs(settings.UPLOAD_DIR, exist_ok=True)
os.makedirs(os.path.join(settings.UPLOAD_DIR, "drivers"), exist_ok=True)
os.makedirs(os.path.join(settings.UPLOAD_DIR, "orders"), exist_ok=True)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\crud.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\crud.py     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ±Ğ°Ğ·Ğ¾Ğ¹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… (CRUD)
"""
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, desc, func
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
import random
import string

from . import models, schemas
from .auth import get_password_hash
from .utils import calculate_distance

# User CRUD
def create_user(db: Session, user: schemas.UserCreate) -> models.User:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    hashed_password = get_password_hash(user.password)
    db_user = models.User(
        email=user.email,
        phone=user.phone,
        full_name=user.full_name,
        role=user.role,
        hashed_password=hashed_password
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ email"""
    return db.query(models.User).filter(models.User.email == email).first()

def get_user_by_id(db: Session, user_id: int) -> Optional[models.User]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ ID"""
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_users(
    db: Session, 
    skip: int = 0, 
    limit: int = 100,
    role: Optional[str] = None,
    is_active: Optional[bool] = None
) -> List[models.User]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""
    query = db.query(models.User)
    
    if role:
        query = query.filter(models.User.role == role)
    if is_active is not None:
        query = query.filter(models.User.is_active == is_active)
    
    return query.order_by(models.User.created_at.desc()).offset(skip).limit(limit).all()

def update_user(
    db: Session, 
    user_id: int, 
    user_update: schemas.UserUpdate
) -> Optional[models.User]:
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    user = get_user_by_id(db, user_id)
    if not user:
        return None
    
    update_data = user_update.model_dump(exclude_unset=True)
    
    if "password" in update_data and update_data["password"]:
        update_data["hashed_password"] = get_password_hash(update_data.pop("password"))
    
    for field, value in update_data.items():
        setattr(user, field, value)
    
    db.commit()
    db.refresh(user)
    return user

def delete_user(db: Session, user_id: int) -> bool:
    """Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    user = get_user_by_id(db, user_id)
    if not user:
        return False
    
    db.delete(user)
    db.commit()
    return True

# Driver Profile CRUD
def create_driver_profile(
    db: Session, 
    profile: schemas.DriverProfileCreate, 
    user_id: int
) -> models.DriverProfile:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
    db_profile = models.DriverProfile(
        user_id=user_id,
        **profile.model_dump()
    )
    db.add(db_profile)
    db.commit()
    db.refresh(db_profile)
    return db_profile

def get_driver_profile(db: Session, user_id: int) -> Optional[models.DriverProfile]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
    return db.query(models.DriverProfile).filter(models.DriverProfile.user_id == user_id).first()

def get_driver_profiles(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    verification_status: Optional[str] = None,
    is_online: Optional[bool] = None
) -> List[models.DriverProfile]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ĞµĞ¹ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹"""
    query = db.query(models.DriverProfile)
    
    if verification_status:
        query = query.filter(models.DriverProfile.verification_status == verification_status)
    if is_online is not None:
        query = query.filter(models.DriverProfile.is_online == is_online)
    
    return query.order_by(desc(models.DriverProfile.rating)).offset(skip).limit(limit).all()

def update_driver_profile(
    db: Session, 
    user_id: int, 
    profile_update: schemas.DriverProfileUpdate
) -> Optional[models.DriverProfile]:
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
    profile = get_driver_profile(db, user_id)
    if not profile:
        return None
    
    update_data = profile_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(profile, field, value)
    
    db.commit()
    db.refresh(profile)
    return profile

def update_driver_location(
    db: Session,
    user_id: int,
    lat: float,
    lng: float
) -> Optional[models.DriverProfile]:
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
    profile = get_driver_profile(db, user_id)
    if not profile:
        return None
    
    profile.current_location_lat = lat
    profile.current_location_lng = lng
    profile.is_online = True
    
    db.commit()
    db.refresh(profile)
    return profile

def verify_driver_profile(
    db: Session,
    user_id: int,
    status: str,
    notes: Optional[str] = None
) -> Optional[models.DriverProfile]:
    """Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
    profile = get_driver_profile(db, user_id)
    if not profile:
        return None
    
    profile.verification_status = status
    
    # Ğ•ÑĞ»Ğ¸ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½, Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    if status == models.VerificationStatus.VERIFIED:
        user = get_user_by_id(db, user_id)
        if user:
            user.is_verified = True
    
    db.commit()
    db.refresh(profile)
    return profile

# Order CRUD
def generate_order_number() -> str:
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    letters = ''.join(random.choices(string.ascii_uppercase, k=2))
    numbers = ''.join(random.choices(string.digits, k=6))
    return f"CP{letters}{numbers}"

def create_order(db: Session, order: schemas.OrderCreate, client_id: int) -> models.Order:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    # Ğ Ğ°ÑÑ‡ĞµÑ‚ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
    distance = calculate_distance(
        order.from_lat, order.from_lng,
        order.to_lat, order.to_lng
    )
    
    db_order = models.Order(
        order_number=generate_order_number(),
        client_id=client_id,
        distance_km=distance,
        **order.model_dump()
    )
    db.add(db_order)
    db.commit()
    db.refresh(db_order)
    return db_order

def get_order(db: Session, order_id: int) -> Optional[models.Order]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¿Ğ¾ ID"""
    return db.query(models.Order).filter(models.Order.id == order_id).first()

def get_order_by_number(db: Session, order_number: str) -> Optional[models.Order]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¿Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€Ñƒ"""
    return db.query(models.Order).filter(models.Order.order_number == order_number).first()

def get_orders(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    client_id: Optional[int] = None,
    driver_id: Optional[int] = None,
    status: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    cargo_type: Optional[str] = None
) -> List[models.Order]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²"""
    query = db.query(models.Order)
    
    if client_id:
        query = query.filter(models.Order.client_id == client_id)
    if driver_id:
        query = query.filter(models.Order.driver_id == driver_id)
    if status:
        query = query.filter(models.Order.status == status)
    if min_price:
        query = query.filter(models.Order.desired_price >= min_price)
    if max_price:
        query = query.filter(models.Order.desired_price <= max_price)
    if cargo_type:
        query = query.filter(models.Order.cargo_type == cargo_type)
    
    return query.order_by(desc(models.Order.created_at)).offset(skip).limit(limit).all()

def get_available_orders(
    db: Session,
    driver_id: Optional[int] = None,
    skip: int = 0,
    limit: int = 100
) -> List[models.Order]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹"""
    query = db.query(models.Order).filter(
        models.Order.status.in_([models.OrderStatus.SEARCHING])
    )
    
    # Ğ•ÑĞ»Ğ¸ ÑƒĞºĞ°Ğ·Ğ°Ğ½ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ, Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹ Ğ¿Ğ¾ ĞµĞ³Ğ¾ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑĞ¼
    if driver_id:
        driver_profile = get_driver_profile(db, driver_id)
        if driver_profile:
            # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿Ğ¾Ğ´ÑŠĞµĞ¼Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ğ¾Ğ±ÑŠĞµĞ¼Ñƒ
            query = query.filter(
                models.Order.cargo_weight <= driver_profile.carrying_capacity,
                models.Order.cargo_volume <= driver_profile.volume
            )
    
    return query.order_by(desc(models.Order.created_at)).offset(skip).limit(limit).all()

def update_order(
    db: Session, 
    order_id: int, 
    order_update: schemas.OrderUpdate
) -> Optional[models.Order]:
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    order = get_order(db, order_id)
    if not order:
        return None
    
    update_data = order_update.model_dump(exclude_unset=True)
    
    # Ğ•ÑĞ»Ğ¸ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚ÑÑ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ, Ğ¼ĞµĞ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ
    if "driver_id" in update_data and update_data["driver_id"]:
        order.status = models.OrderStatus.DRIVER_ASSIGNED
    
    # Ğ•ÑĞ»Ğ¸ ÑƒÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ†ĞµĞ½Ğ°, Ñ€Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ
    if "final_price" in update_data and update_data["final_price"]:
        order.final_price = update_data["final_price"]
        order.platform_fee = order.final_price * 0.05  # 5% ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ
        order.order_amount = order.final_price - order.platform_fee
    
    for field, value in update_data.items():
        if field != "final_price":  # Ğ£Ğ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ»Ğ¸
            setattr(order, field, value)
    
    db.commit()
    db.refresh(order)
    return order

def complete_order(db: Session, order_id: int) -> Optional[models.Order]:
    """Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    order = get_order(db, order_id)
    if not order:
        return None
    
    order.status = models.OrderStatus.COMPLETED
    order.completed_at = datetime.utcnow()
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    if order.driver_id:
        profile = get_driver_profile(db, order.driver_id)
        if profile:
            profile.total_orders += 1
            if order.distance_km:
                profile.total_distance += order.distance_km
    
    db.commit()
    db.refresh(order)
    return order

def cancel_order(db: Session, order_id: int) -> Optional[models.Order]:
    """ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    order = get_order(db, order_id)
    if not order:
        return None
    
    order.status = models.OrderStatus.CANCELLED
    
    # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ²ÑĞµ ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ·Ğ°ĞºĞ°Ğ·Ñƒ
    bids = db.query(models.Bid).filter(models.Bid.order_id == order_id).all()
    for bid in bids:
        bid.status = models.BidStatus.CANCELLED
    
    db.commit()
    db.refresh(order)
    return order

# Bid CRUD
def create_bid(
    db: Session, 
    bid: schemas.BidCreate, 
    order_id: int, 
    driver_id: int
) -> models.Bid:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ·Ğ°ĞºĞ°Ğ· Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ´Ğ»Ñ ÑÑ‚Ğ°Ğ²Ğ¾Ğº
    order = get_order(db, order_id)
    if not order or order.status != models.OrderStatus.SEARCHING:
        raise ValueError("Order is not available for bidding")
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ ÑƒĞ¶Ğµ Ğ½Ğµ Ğ´ĞµĞ»Ğ°Ğ» ÑÑ‚Ğ°Ğ²ĞºÑƒ
    existing_bid = db.query(models.Bid).filter(
        models.Bid.order_id == order_id,
        models.Bid.driver_id == driver_id
    ).first()
    
    if existing_bid:
        raise ValueError("You already placed a bid on this order")
    
    db_bid = models.Bid(
        order_id=order_id,
        driver_id=driver_id,
        **bid.model_dump()
    )
    db.add(db_bid)
    db.commit()
    db.refresh(db_bid)
    return db_bid

def get_bid(db: Session, bid_id: int) -> Optional[models.Bid]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¿Ğ¾ ID"""
    return db.query(models.Bid).filter(models.Bid.id == bid_id).first()

def get_bids_by_order(db: Session, order_id: int) -> List[models.Bid]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ğ²Ğ¾Ğº Ğ¿Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ñƒ"""
    return db.query(models.Bid).filter(models.Bid.order_id == order_id).all()

def get_bids_by_driver(db: Session, driver_id: int) -> List[models.Bid]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ğ²Ğ¾Ğº Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
    return db.query(models.Bid).filter(models.Bid.driver_id == driver_id).all()

def accept_bid(db: Session, bid_id: int) -> Optional[models.Bid]:
    """ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğµ ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    bid = get_bid(db, bid_id)
    if not bid:
        return None
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ ÑÑ‚Ğ°Ğ²ĞºĞ¸
    bid.status = models.BidStatus.ACCEPTED
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
    order = get_order(db, bid.order_id)
    if order:
        order.driver_id = bid.driver_id
        order.status = models.OrderStatus.DRIVER_ASSIGNED
        order.final_price = bid.proposed_price
        order.platform_fee = bid.proposed_price * 0.05
        order.order_amount = bid.proposed_price - order.platform_fee
    
    # ĞÑ‚ĞºĞ»Ğ¾Ğ½ÑĞµĞ¼ Ğ²ÑĞµ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ·Ğ°ĞºĞ°Ğ·Ñƒ
    other_bids = db.query(models.Bid).filter(
        and_(
            models.Bid.order_id == bid.order_id,
            models.Bid.id != bid_id
        )
    ).all()
    
    for other_bid in other_bids:
        other_bid.status = models.BidStatus.REJECTED
    
    db.commit()
    db.refresh(bid)
    return bid

def reject_bid(db: Session, bid_id: int) -> Optional[models.Bid]:
    """ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    bid = get_bid(db, bid_id)
    if not bid:
        return None
    
    bid.status = models.BidStatus.REJECTED
    db.commit()
    db.refresh(bid)
    return bid

# Message CRUD
def create_message(
    db: Session, 
    message: schemas.MessageCreate, 
    order_id: int, 
    sender_id: int
) -> models.Message:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ"""
    db_message = models.Message(
        order_id=order_id,
        sender_id=sender_id,
        **message.model_dump()
    )
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    return db_message

def get_messages_by_order(
    db: Session, 
    order_id: int, 
    skip: int = 0, 
    limit: int = 100
) -> List[models.Message]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ¿Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ñƒ"""
    return db.query(models.Message)\
        .filter(models.Message.order_id == order_id)\
        .order_by(models.Message.timestamp.asc())\
        .offset(skip)\
        .limit(limit)\
        .all()

def mark_messages_as_read(
    db: Session,
    order_id: int,
    user_id: int
) -> int:
    """ĞŸĞ¾Ğ¼ĞµÑ‚ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ñ…"""
    result = db.query(models.Message)\
        .filter(
            models.Message.order_id == order_id,
            models.Message.sender_id != user_id,
            models.Message.is_read == False
        )\
        .update({"is_read": True})
    
    db.commit()
    return result

# Location CRUD
def create_location_update(
    db: Session, 
    location: schemas.LocationCreate, 
    driver_id: int
) -> models.LocationUpdate:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ"""
    db_location = models.LocationUpdate(
        driver_id=driver_id,
        **location.model_dump()
    )
    db.add(db_location)
    db.commit()
    db.refresh(db_location)
    return db_location

def get_locations_by_driver(
    db: Session, 
    driver_id: int, 
    order_id: Optional[int] = None,
    limit: int = 100
) -> List[models.LocationUpdate]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
    query = db.query(models.LocationUpdate)\
        .filter(models.LocationUpdate.driver_id == driver_id)
    
    if order_id:
        query = query.filter(models.LocationUpdate.order_id == order_id)
    
    return query\
        .order_by(desc(models.LocationUpdate.timestamp))\
        .limit(limit)\
        .all()

# Payment CRUD
def create_payment(
    db: Session,
    payment: schemas.PaymentCreate,
    user_id: int
) -> models.Payment:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°"""
    db_payment = models.Payment(
        user_id=user_id,
        **payment.model_dump()
    )
    db.add(db_payment)
    db.commit()
    db.refresh(db_payment)
    return db_payment

def get_payment(db: Session, payment_id: int) -> Optional[models.Payment]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ° Ğ¿Ğ¾ ID"""
    return db.query(models.Payment).filter(models.Payment.id == payment_id).first()

def update_payment_status(
    db: Session,
    payment_id: int,
    status: str,
    payment_id_external: Optional[str] = None
) -> Optional[models.Payment]:
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°"""
    payment = get_payment(db, payment_id)
    if not payment:
        return None
    
    payment.status = status
    if payment_id_external:
        payment.payment_id = payment_id_external
    
    if status == models.PaymentStatus.COMPLETED:
        payment.completed_at = datetime.utcnow()
        
        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        user = get_user_by_id(db, payment.user_id)
        if user:
            user.balance += payment.amount
        
        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        if payment.order_id:
            order = get_order(db, payment.order_id)
            if order:
                order.payment_status = models.PaymentStatus.COMPLETED
                order.status = models.OrderStatus.PAID
    
    db.commit()
    db.refresh(payment)
    return payment

# Statistics
def get_system_stats(db: Session) -> Dict[str, Any]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸"""
    stats = {}
    
    # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸
    stats["total_users"] = db.query(func.count(models.User.id)).scalar()
    stats["total_drivers"] = db.query(func.count(models.User.id))\
        .filter(models.User.role == models.UserRole.DRIVER)\
        .scalar()
    stats["total_clients"] = db.query(func.count(models.User.id))\
        .filter(models.User.role == models.UserRole.CLIENT)\
        .scalar()
    
    # Ğ—Ğ°ĞºĞ°Ğ·Ñ‹
    stats["total_orders"] = db.query(func.count(models.Order.id)).scalar()
    stats["active_orders"] = db.query(func.count(models.Order.id))\
        .filter(
            models.Order.status.in_([
                models.OrderStatus.SEARCHING,
                models.OrderStatus.DRIVER_ASSIGNED,
                models.OrderStatus.LOADING,
                models.OrderStatus.EN_ROUTE
            ])
        )\
        .scalar()
    
    # Ğ’Ñ‹Ñ€ÑƒÑ‡ĞºĞ°
    stats["total_revenue"] = db.query(func.coalesce(func.sum(models.Order.platform_fee), 0)).scalar() or 0
    
    # ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
    stats["pending_verifications"] = db.query(func.count(models.DriverProfile.id))\
        .filter(models.DriverProfile.verification_status == models.VerificationStatus.PENDING)\
        .scalar()
    
    # Ğ—Ğ° Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 7 Ğ´Ğ½ĞµĞ¹
    week_ago = datetime.utcnow() - timedelta(days=7)
    
    stats["new_users_week"] = db.query(func.count(models.User.id))\
        .filter(models.User.created_at >= week_ago)\
        .scalar()
    
    stats["new_orders_week"] = db.query(func.count(models.Order.id))\
        .filter(models.Order.created_at >= week_ago)\
        .scalar()
    
    stats["revenue_week"] = db.query(func.coalesce(func.sum(models.Order.platform_fee), 0))\
        .filter(
            models.Order.created_at >= week_ago,
            models.Order.payment_status == models.PaymentStatus.COMPLETED
        )\
        .scalar() or 0
    
    return stats
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\database.py                                                        â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\database.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
"""
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ´Ğ²Ğ¸Ğ¶Ğ¾Ğº Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
if settings.DATABASE_URL.startswith("sqlite"):
    engine = create_engine(
        settings.DATABASE_URL, connect_args={"check_same_thread": False}
    )
else:
    engine = create_engine(settings.DATABASE_URL)

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºÑƒ ÑĞµÑÑĞ¸Ğ¹
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ĞµĞ¹
Base = declarative_base()

# Dependency Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ÑĞµÑÑĞ¸Ğ¸ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\dependencies.py                                                    â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\dependencies.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ»Ñ Dependency Injection
"""
from fastapi import Depends, HTTPException, status, Query, Header
from sqlalchemy.orm import Session
from typing import Optional
import jwt
from .config import settings
from .database import get_db
from .auth import get_current_user, get_current_admin, get_current_driver, get_current_client
from . import crud

# Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ»Ñ WebSocket Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
async def get_websocket_user(
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ´Ğ»Ñ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ"""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token is required"
        )
    
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: int = payload.get("user_id")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )
        
        user = crud.get_user_by_id(db, user_id)
        if user is None or not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found or inactive"
            )
        
        return user
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )

async def get_websocket_driver(
    user = Depends(get_websocket_user)
):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ´Ğ»Ñ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ"""
    if user.role != "driver":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only drivers can access this endpoint"
        )
    return user

async def get_websocket_admin(
    user = Depends(get_websocket_user)
):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ° Ğ´Ğ»Ñ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ"""
    if user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only admins can access this endpoint"
        )
    return user

# Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹
async def check_order_access(
    order_id: int,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ"""
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Order not found"
        )
    
    # ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ¸Ğ¼ĞµÑÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ ĞºĞ¾ Ğ²ÑĞµĞ¼Ñƒ
    if current_user.role == "admin":
        return order
    
    # ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹ Ğ¸Ğ¼ĞµÑÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº ÑĞ²Ğ¾Ğ¸Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ğ¼
    if current_user.role == "client" and order.client_id == current_user.id:
        return order
    
    # Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸ Ğ¸Ğ¼ĞµÑÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ‹Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ğ¼
    if current_user.role == "driver" and order.driver_id == current_user.id:
        return order
    
    # Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸ Ñ‚Ğ°ĞºĞ¶Ğµ Ğ¸Ğ¼ĞµÑÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ğ¼, Ğ½Ğ° ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¾Ğ½Ğ¸ ÑĞ´ĞµĞ»Ğ°Ğ»Ğ¸ ÑÑ‚Ğ°Ğ²ĞºĞ¸
    if current_user.role == "driver":
        bid = db.query(crud.models.Bid).filter(
            crud.models.Bid.order_id == order_id,
            crud.models.Bid.driver_id == current_user.id
        ).first()
        if bid:
            return order
    
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
        detail="You don't have access to this order"
    )

async def check_driver_verified(
    current_user = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Driver profile not found"
        )
    
    if profile.verification_status != "verified":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Driver profile is not verified"
        )
    
    return current_user

# Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ»Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸
class PaginationParams:
    def __init__(
        self,
        skip: int = Query(0, ge=0, description="ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹"),
        limit: int = Query(100, ge=1, le=1000, description="ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹"),
        sort_by: str = Query("created_at", description="ĞŸĞ¾Ğ»Ğµ Ğ´Ğ»Ñ ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸"),
        sort_desc: bool = Query(True, description="Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¿Ğ¾ ÑƒĞ±Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ")
    ):
        self.skip = skip
        self.limit = limit
        self.sort_by = sort_by
        self.sort_desc = sort_desc

# Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ»Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
class OrderFilterParams:
    def __init__(
        self,
        status: Optional[str] = Query(None, description="Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"),
        min_price: Optional[float] = Query(None, ge=0, description="ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ†ĞµĞ½Ğ°"),
        max_price: Optional[float] = Query(None, ge=0, description="ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ†ĞµĞ½Ğ°"),
        cargo_type: Optional[str] = Query(None, description="Ğ¢Ğ¸Ğ¿ Ğ³Ñ€ÑƒĞ·Ğ°"),
        date_from: Optional[str] = Query(None, description="Ğ”Ğ°Ñ‚Ğ° Ğ¾Ñ‚ (YYYY-MM-DD)"),
        date_to: Optional[str] = Query(None, description="Ğ”Ğ°Ñ‚Ğ° Ğ´Ğ¾ (YYYY-MM-DD)")
    ):
        self.status = status
        self.min_price = min_price
        self.max_price = max_price
        self.cargo_type = cargo_type
        self.date_from = date_from
        self.date_to = date_to

# Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ»Ñ API ĞºĞ»ÑÑ‡ĞµĞ¹ (Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸)
async def verify_api_key(
    x_api_key: Optional[str] = Header(None)
):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° API ĞºĞ»ÑÑ‡Ğ° Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¹"""
    # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ ĞºĞ»ÑÑ‡Ğ¸ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒÑÑ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    valid_keys = {
        "mobile_app_key": "mobile-app-integration",
        "admin_panel_key": "admin-panel-integration",
        "website_key": "website-integration"
    }
    
    if not x_api_key or x_api_key not in valid_keys:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )
    
    return valid_keys[x_api_key]

# Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ´Ğ»Ñ rate limiting (ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ)
class RateLimiter:
    def __init__(self):
        # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Redis
        self.requests = {}
    
    async def __call__(self, user_id: int = Depends(get_current_user)):
        import time
        current_time = time.time()
        
        if user_id not in self.requests:
            self.requests[user_id] = []
        
        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ (ÑÑ‚Ğ°Ñ€ÑˆĞµ 1 Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñ‹)
        self.requests[user_id] = [
            req_time for req_time in self.requests[user_id]
            if current_time - req_time < 60
        ]
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ (60 Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ² Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñƒ)
        if len(self.requests[user_id]) >= 60:
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Too many requests"
            )
        
        self.requests[user_id].append(current_time)
        return user_id

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ rate limiter
rate_limiter = RateLimiter()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\file_storage.py                                                    â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\file_storage.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²Ñ‹Ğ¼ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰ĞµĞ¼
"""
import os
import uuid
from pathlib import Path
from typing import Optional, Tuple
from fastapi import UploadFile, HTTPException
import shutil
from PIL import Image
import magic

from .config import settings
from .utils import is_allowed_file

class FileStorage:
    def __init__(self):
        self.base_dir = Path(settings.UPLOAD_DIR)
        self.max_size = settings.MAX_FILE_SIZE_MB * 1024 * 1024  # ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ² Ğ±Ğ°Ğ¹Ñ‚Ñ‹
        
        # Ğ Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ½Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²
        self.allowed_extensions = {
            '.jpg', '.jpeg', '.png', '.gif',  # Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
            '.pdf', '.doc', '.docx',          # Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ‹
        }
        
        # MIME Ñ‚Ğ¸Ğ¿Ñ‹
        self.allowed_mime_types = {
            'image/jpeg', 'image/png', 'image/gif',
            'application/pdf', 'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        }
    
    def _generate_filename(self, original_filename: str) -> str:
        """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°"""
        ext = Path(original_filename).suffix.lower()
        unique_id = uuid.uuid4().hex
        return f"{unique_id}{ext}"
    
    def _get_mime_type(self, file_path: str) -> str:
        """ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ MIME Ñ‚Ğ¸Ğ¿Ğ° Ñ„Ğ°Ğ¹Ğ»Ğ°"""
        mime = magic.Magic(mime=True)
        return mime.from_file(file_path)
    
    def validate_file(self, file: UploadFile) -> Tuple[bool, str]:
        """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°"""
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°
        file.file.seek(0, 2)  # ĞŸĞµÑ€ĞµĞ¼ĞµÑ‰Ğ°ĞµĞ¼ÑÑ Ğ² ĞºĞ¾Ğ½ĞµÑ† Ñ„Ğ°Ğ¹Ğ»Ğ°
        file_size = file.file.tell()
        file.file.seek(0)  # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾
        
        if file_size > self.max_size:
            return False, f"File size exceeds maximum allowed size ({settings.MAX_FILE_SIZE_MB}MB)"
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ
        if not is_allowed_file(file.filename, self.allowed_extensions):
            return False, f"File type not allowed. Allowed types: {', '.join(self.allowed_extensions)}"
        
        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ MIME Ñ‚Ğ¸Ğ¿Ğ°
        temp_path = self.base_dir / f"temp_{uuid.uuid4()}.tmp"
        try:
            with open(temp_path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° MIME Ñ‚Ğ¸Ğ¿Ğ°
            mime_type = self._get_mime_type(str(temp_path))
            if mime_type not in self.allowed_mime_types:
                return False, f"MIME type {mime_type} not allowed"
            
            # Ğ”Ğ»Ñ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
            if mime_type.startswith('image/'):
                try:
                    with Image.open(temp_path) as img:
                        img.verify()  # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
                except Exception as e:
                    return False, f"Invalid image file: {str(e)}"
        
        finally:
            # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»
            if temp_path.exists():
                temp_path.unlink()
            
            # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾
            file.file.seek(0)
        
        return True, "File is valid"
    
    async def save_file(self, file: UploadFile, subdirectory: str, user_id: int) -> str:
        """
        Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ°
        Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ¾Ñ‚Ğ½Ğ¾ÑĞ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ Ğº Ñ„Ğ°Ğ¹Ğ»Ñƒ
        """
        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ
        is_valid, message = self.validate_file(file)
        if not is_valid:
            raise HTTPException(status_code=400, detail=message)
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ¸
        user_dir = self.base_dir / subdirectory / str(user_id)
        user_dir.mkdir(parents=True, exist_ok=True)
        
        # Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°
        filename = self._generate_filename(file.filename)
        file_path = user_dir / filename
        
        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ°
        try:
            with open(file_path, "wb") as buffer:
                # Ğ”Ğ»Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ñ‡Ğ°ÑÑ‚ÑĞ¼Ğ¸
                while chunk := await file.read(1024 * 1024):  # 1MB chunks
                    buffer.write(chunk)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Error saving file: {str(e)}")
        
        # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ¾Ñ‚Ğ½Ğ¾ÑĞ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ
        relative_path = file_path.relative_to(self.base_dir)
        return str(relative_path)
    
    def get_file_path(self, relative_path: str) -> Optional[Path]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ¿ÑƒÑ‚Ğ¸ Ğº Ñ„Ğ°Ğ¹Ğ»Ñƒ"""
        file_path = self.base_dir / relative_path
        if file_path.exists() and file_path.is_file():
            return file_path
        return None
    
    def delete_file(self, relative_path: str) -> bool:
        """Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ°"""
        file_path = self.get_file_path(relative_path)
        if file_path:
            try:
                file_path.unlink()
                return True
            except:
                return False
        return False
    
    def save_driver_document(
        self,
        file: UploadFile,
        user_id: int,
        document_type: str
    ) -> str:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
        return self.save_file(file, f"drivers/{document_type}", user_id)
    
    def save_order_image(
        self,
        file: UploadFile,
        user_id: int,
        order_id: int
    ) -> str:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ³Ñ€ÑƒĞ·Ğ°"""
        return self.save_file(file, f"orders/{order_id}/images", user_id)

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğ°
file_storage = FileStorage()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\init.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\init.py     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
CargoPro Backend Application
"""
__version__ = "1.0.0"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\main.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\main.py     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ FastAPI
"""
from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse  # <-- Ğ”ĞĞ‘ĞĞ’Ğ¬Ğ¢Ğ• Ğ­Ğ¢Ğ
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.staticfiles import StaticFiles
import logging
import os
from starlette.exceptions import HTTPException as StarletteHTTPException  # <-- Ğ”ĞĞ‘ĞĞ’Ğ¬Ğ¢Ğ•

from .database import engine, Base
from .config import settings
from .routes import (
    auth_router,
    users_router,
    drivers_router,
    orders_router,
    bids_router,
    chat_router,
    track_router,
    admin_router,
    health_router,
    integration_router,
    admin_dashboard_router
)

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
logging.basicConfig(
    level=logging.INFO if not settings.DEBUG else logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ† Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
try:
    Base.metadata.create_all(bind=engine)
    logger.info("Database tables created successfully")
except Exception as e:
    logger.error(f"Error creating database tables: {e}")

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ FastAPI Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
app = FastAPI(
    title="CargoPro Backend API",
    description="""
    ğŸšš Backend Ğ´Ğ»Ñ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·Ğ¾Ğº CargoPro
    
    ## ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸:
    
    ### Ğ”Ğ»Ñ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ²:
    * ğŸ“¦ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ğ¼Ğ¸
    * ğŸ’¬ Ğ§Ğ°Ñ‚ Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑĞ¼Ğ¸
    * ğŸ“ ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ·Ğ° Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
    * ğŸ’³ ĞĞ¿Ğ»Ğ°Ñ‚Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
    
    ### Ğ”Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹:
    * ğŸš— ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
    * ğŸ’° Ğ Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ğ²Ğ¾Ğº
    * ğŸ“ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ³ĞµĞ¾Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸
    * ğŸ“± ĞœĞ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
    
    ### Ğ”Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²:
    * ğŸ‘¥ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸
    * âœ… Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹
    * ğŸ“Š ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    * âš™ï¸ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
    
    ## Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ:
    * ğŸŒ ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ÑĞ°Ğ¹Ñ‚
    * ğŸ“± ĞœĞ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
    * ğŸ› ï¸ ĞĞ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ
    """,
    version="1.0.0",
    docs_url="/api/docs" if settings.DEBUG else None,
    redoc_url="/api/redoc" if settings.DEBUG else None,
    openapi_url="/api/openapi.json" if settings.DEBUG else None,
)

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Middleware Ğ´Ğ»Ñ ÑĞ¶Ğ°Ñ‚Ğ¸Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ²
app.add_middleware(GZipMiddleware, minimum_size=1000)

# ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² (Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ½Ñ‹Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²)
app.mount("/uploads", StaticFiles(directory=settings.UPLOAD_DIR), name="uploads")

# ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ñ€Ğ¾ÑƒÑ‚ĞµÑ€Ğ¾Ğ²
app.include_router(auth_router)
app.include_router(users_router)
app.include_router(drivers_router)
app.include_router(orders_router)
app.include_router(bids_router)
app.include_router(chat_router)
app.include_router(track_router)
app.include_router(admin_router)
app.include_router(health_router)
app.include_router(integration_router)
app.include_router(admin_dashboard_router)

# ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ñ‹
@app.get("/")
async def root():
    """
    ĞšĞ¾Ñ€Ğ½ĞµĞ²Ğ¾Ğ¹ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚
    """
    return {
        "message": "ğŸšš Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² CargoPro API",
        "version": "1.0.0",
        "docs": "/api/docs" if settings.DEBUG else None,
        "status": "operational",
        "services": {
            "authentication": "active",
            "orders": "active",
            "tracking": "active",
            "chat": "active",
            "payments": "active"
        }
    }

@app.get("/api")
async def api_info():
    """
    Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ API
    """
    return {
        "name": "CargoPro API",
        "version": "1.0.0",
        "description": "API Ğ´Ğ»Ñ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹ Ğ³Ñ€ÑƒĞ·Ğ¾Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·Ğ¾Ğº CargoPro",
        "endpoints": {
            "auth": "/api/auth",
            "users": "/api/users",
            "drivers": "/api/drivers",
            "orders": "/api/orders",
            "bids": "/api/bids",
            "admin": "/api/admin",
            "health": "/health",
            "integration": "/api/integration"
        },
        "websockets": {
            "chat": "/ws/chat/{order_id}",
            "tracking": "/ws/track/{driver_id}",
            "notifications": "/ws/notifications"
        }
    }

# Middleware Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
@app.middleware("http")
async def log_requests(request, call_next):
    """
    Middleware Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ HTTP Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
    """
    logger.info(f"Request: {request.method} {request.url.path}")
    response = await call_next(request)
    logger.info(f"Response: {response.status_code}")
    return response

# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº - Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ«Ğ• Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ˜
@app.exception_handler(404)
async def not_found_exception_handler(request, exc):
    """
    ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° 404 Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
    """
    return JSONResponse(
        status_code=404,
        content={
            "error": "Not Found",
            "message": "Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑˆĞµĞ½Ğ½Ñ‹Ğ¹ Ñ€ĞµÑÑƒÑ€Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½",
            "path": request.url.path
        }
    )

@app.exception_handler(500)
async def internal_server_error_handler(request, exc):
    """
    ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° 500 Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
    """
    logger.error(f"Internal Server Error: {exc}")
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal Server Error",
            "message": "Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ÑÑ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° ÑĞµÑ€Ğ²ĞµÑ€Ğ°",
            "request_id": request.headers.get("X-Request-ID", "unknown")
        }
    )

# Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ´Ğ»Ñ Ğ²ÑĞµÑ… HTTP Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹
@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail}
    )

# Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ (Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸)
if __name__ == "__main__":
    import uvicorn
    
    logger.info(f"ğŸš€ Starting CargoPro Backend on {settings.HOST}:{settings.PORT}")
    logger.info(f"ğŸ“Š API Documentation: http://{settings.HOST}:{settings.PORT}/api/docs")
    logger.info(f"ğŸ”§ Debug mode: {settings.DEBUG}")
    
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level="info"
    )
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\models.py                                                          â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\models.py   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ĞœĞ¾Ğ´ĞµĞ»Ğ¸ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
"""
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, ForeignKey, Enum, Text, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum
from .database import Base

class UserRole(str, enum.Enum):
    CLIENT = "client"
    DRIVER = "driver"
    ADMIN = "admin"

class VerificationStatus(str, enum.Enum):
    PENDING = "pending"
    VERIFIED = "verified"
    REJECTED = "rejected"

class OrderStatus(str, enum.Enum):
    DRAFT = "draft"              # Ğ§ĞµÑ€Ğ½Ğ¾Ğ²Ğ¸Ğº
    SEARCHING = "searching"      # ĞŸĞ¾Ğ¸ÑĞº Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    DRIVER_ASSIGNED = "driver_assigned"  # Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½
    LOADING = "loading"          # ĞŸĞ¾Ğ³Ñ€ÑƒĞ·ĞºĞ°
    EN_ROUTE = "en_route"        # Ğ’ Ğ¿ÑƒÑ‚Ğ¸
    UNLOADING = "unloading"      # Ğ Ğ°Ğ·Ğ³Ñ€ÑƒĞ·ĞºĞ°
    COMPLETED = "completed"      # Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½
    CANCELLED = "cancelled"      # ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½
    PAID = "paid"                # ĞĞ¿Ğ»Ğ°Ñ‡ĞµĞ½

class BidStatus(str, enum.Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    REJECTED = "rejected"
    CANCELLED = "cancelled"

class PaymentStatus(str, enum.Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    phone = Column(String, unique=True, index=True, nullable=False)
    role = Column(Enum(UserRole), default=UserRole.CLIENT, nullable=False)
    is_active = Column(Boolean, default=True)
    is_verified = Column(Boolean, default=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=True)
    balance = Column(Float, default=0.0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    driver_profile = relationship("DriverProfile", back_populates="user", uselist=False, cascade="all, delete-orphan")
    orders_as_client = relationship("Order", foreign_keys="Order.client_id", back_populates="client")
    orders_as_driver = relationship("Order", foreign_keys="Order.driver_id", back_populates="driver")
    bids = relationship("Bid", back_populates="driver", cascade="all, delete-orphan")
    sent_messages = relationship("Message", foreign_keys="Message.sender_id", back_populates="sender")
    location_updates = relationship("LocationUpdate", back_populates="driver")
    payments = relationship("Payment", back_populates="user")

class DriverProfile(Base):
    __tablename__ = "driver_profiles"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), unique=True, nullable=False)
    vehicle_type = Column(String, nullable=False)
    vehicle_model = Column(String, nullable=True)
    vehicle_number = Column(String, nullable=False)
    carrying_capacity = Column(Float, nullable=False)  # Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…
    volume = Column(Float, nullable=False)  # Ğ² Ğ¼Â³
    license_path = Column(String, nullable=True)
    passport_path = Column(String, nullable=True)
    vehicle_registration_path = Column(String, nullable=True)
    insurance_path = Column(String, nullable=True)
    verification_status = Column(Enum(VerificationStatus), default=VerificationStatus.PENDING)
    rating = Column(Float, default=0.0)
    total_orders = Column(Integer, default=0)
    total_distance = Column(Float, default=0.0)
    is_online = Column(Boolean, default=False)
    current_location_lat = Column(Float, nullable=True)
    current_location_lng = Column(Float, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="driver_profile")

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    order_number = Column(String, unique=True, index=True, nullable=False)
    client_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    driver_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    status = Column(Enum(OrderStatus), default=OrderStatus.DRAFT, nullable=False)
    
    # Address information
    from_address = Column(String, nullable=False)
    from_lat = Column(Float, nullable=False)
    from_lng = Column(Float, nullable=False)
    to_address = Column(String, nullable=False)
    to_lat = Column(Float, nullable=False)
    to_lng = Column(Float, nullable=False)
    distance_km = Column(Float, nullable=True)
    
    # Cargo details
    cargo_description = Column(String, nullable=False)
    cargo_weight = Column(Float, nullable=False)  # Ğ² Ñ‚Ğ¾Ğ½Ğ½Ğ°Ñ…
    cargo_volume = Column(Float, nullable=False)  # Ğ² Ğ¼Â³
    cargo_type = Column(String, nullable=False)
    cargo_images = Column(JSON, nullable=True)  # ĞŸÑƒÑ‚Ğ¸ Ğº Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸ÑĞ¼ Ğ³Ñ€ÑƒĞ·Ğ°
    
    # Price information
    desired_price = Column(Float, nullable=False)
    final_price = Column(Float, nullable=True)
    platform_fee = Column(Float, nullable=True)  # 5% ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ
    order_amount = Column(Float, nullable=True)  # Ğ¡ÑƒĞ¼Ğ¼Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ° (Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ†ĞµĞ½Ğ° - ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ)
    payment_status = Column(Enum(PaymentStatus), default=PaymentStatus.PENDING)
    
    # Dates
    pickup_date = Column(DateTime, nullable=True)
    delivery_date = Column(DateTime, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    client = relationship("User", foreign_keys=[client_id], back_populates="orders_as_client")
    driver = relationship("User", foreign_keys=[driver_id], back_populates="orders_as_driver")
    bids = relationship("Bid", back_populates="order", cascade="all, delete-orphan")
    messages = relationship("Message", back_populates="order", cascade="all, delete-orphan")
    location_updates = relationship("LocationUpdate", back_populates="order", cascade="all, delete-orphan")
    payment = relationship("Payment", back_populates="order", uselist=False, cascade="all, delete-orphan")

class Bid(Base):
    __tablename__ = "bids"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id", ondelete="CASCADE"), nullable=False)
    driver_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    proposed_price = Column(Float, nullable=False)
    message = Column(String, nullable=True)
    status = Column(Enum(BidStatus), default=BidStatus.PENDING, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    order = relationship("Order", back_populates="bids")
    driver = relationship("User", back_populates="bids")

class Message(Base):
    __tablename__ = "messages"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id", ondelete="CASCADE"), nullable=False)
    sender_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    content = Column(Text, nullable=False)
    is_read = Column(Boolean, default=False)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    order = relationship("Order", back_populates="messages")
    sender = relationship("User", foreign_keys=[sender_id], back_populates="sent_messages")

class LocationUpdate(Base):
    __tablename__ = "location_updates"
    
    id = Column(Integer, primary_key=True, index=True)
    driver_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    order_id = Column(Integer, ForeignKey("orders.id", ondelete="CASCADE"), nullable=True)
    lat = Column(Float, nullable=False)
    lng = Column(Float, nullable=False)
    accuracy = Column(Float, nullable=True)
    speed = Column(Float, nullable=True)
    heading = Column(Float, nullable=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    driver = relationship("User", back_populates="location_updates")
    order = relationship("Order", back_populates="location_updates")

class Payment(Base):
    __tablename__ = "payments"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    order_id = Column(Integer, ForeignKey("orders.id"), nullable=True, unique=True)
    amount = Column(Float, nullable=False)
    currency = Column(String, default="RUB")
    status = Column(Enum(PaymentStatus), default=PaymentStatus.PENDING)
    payment_method = Column(String, nullable=True)
    payment_id = Column(String, nullable=True)  # ID Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ° Ğ² Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ
    description = Column(String, nullable=True)
    # Ğ˜Ğ—ĞœĞ•ĞĞ˜Ğ¢Ğ¬ ĞĞ:
    payment_metadata = Column(JSON, nullable=True)  # <-- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="payments")
    order = relationship("Order", back_populates="payment")

class Notification(Base):
    __tablename__ = "notifications"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    title = Column(String, nullable=False)
    message = Column(String, nullable=False)
    type = Column(String, nullable=False)  # order, payment, system, etc.
    data = Column(JSON, nullable=True)
    is_read = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    user = relationship("User")  # Ğ£Ğ‘Ğ˜Ğ ĞĞ•Ğœ `me` Ğ¸Ğ· ÑÑ‚Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\notifications.py                                                   â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\notifications.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
"""
from typing import Dict, List, Optional
from datetime import datetime
import asyncio
import logging
from enum import Enum

from . import crud, schemas
from .websocket_manager import manager

logger = logging.getLogger(__name__)

class NotificationType(Enum):
    """Ğ¢Ğ¸Ğ¿Ñ‹ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹"""
    # Ğ”Ğ»Ñ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹
    NEW_ORDER_AVAILABLE = "new_order_available"
    BID_ACCEPTED = "bid_accepted"
    BID_REJECTED = "bid_rejected"
    ORDER_ASSIGNED = "order_assigned"
    ORDER_UPDATED = "order_updated"
    ORDER_COMPLETED = "order_completed"
    ORDER_CANCELLED = "order_cancelled"
    
    # Ğ”Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸
    NEW_DRIVER_REGISTERED = "new_driver_registered"
    NEW_ORDER_CREATED = "new_order_created"
    PAYMENT_RECEIVED = "payment_received"
    VERIFICATION_REQUIRED = "verification_required"
    
    # Ğ”Ğ»Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ³Ğ¾ ÑĞ°Ğ¹Ñ‚Ğ°
    DRIVER_ASSIGNED = "driver_assigned"
    ORDER_IN_PROGRESS = "order_in_progress"
    ORDER_DELIVERED = "order_delivered"
    PAYMENT_SUCCESS = "payment_success"
    PAYMENT_FAILED = "payment_failed"

class NotificationService:
    def __init__(self):
        self.notification_templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, Dict[str, str]]:
        """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ğ¾Ğ² ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹"""
        return {
            NotificationType.NEW_ORDER_AVAILABLE.value: {
                "title": "ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ· Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½",
                "message": "ĞŸĞ¾ÑĞ²Ğ¸Ğ»ÑÑ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ· Ğ¿Ğ¾ Ğ²Ğ°ÑˆĞµĞ¼Ñƒ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñƒ"
            },
            NotificationType.BID_ACCEPTED.value: {
                "title": "Ğ’Ğ°ÑˆĞ° ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ°",
                "message": "ĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼! Ğ’Ğ°ÑˆĞ° ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ· Ğ±Ñ‹Ğ»Ğ° Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ°"
            },
            NotificationType.BID_REJECTED.value: {
                "title": "Ğ’Ğ°ÑˆĞ° ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ°",
                "message": "Ğš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ğ²Ğ°ÑˆĞ° ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ· Ğ±Ñ‹Ğ»Ğ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ°"
            },
            NotificationType.ORDER_ASSIGNED.value: {
                "title": "Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½",
                "message": "Ğ’Ğ°Ğ¼ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·"
            },
            NotificationType.ORDER_UPDATED.value: {
                "title": "Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½",
                "message": "Ğ’ Ğ·Ğ°ĞºĞ°Ğ·Ğµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ"
            },
            NotificationType.ORDER_COMPLETED.value: {
                "title": "Ğ—Ğ°ĞºĞ°Ğ· Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½",
                "message": "Ğ—Ğ°ĞºĞ°Ğ· ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½"
            },
            NotificationType.ORDER_CANCELLED.value: {
                "title": "Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½",
                "message": "Ğ—Ğ°ĞºĞ°Ğ· Ğ±Ñ‹Ğ» Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½"
            },
            NotificationType.NEW_DRIVER_REGISTERED.value: {
                "title": "ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ",
                "message": "Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ"
            },
            NotificationType.NEW_ORDER_CREATED.value: {
                "title": "ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·",
                "message": "Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ· Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºÑƒ"
            },
            NotificationType.PAYMENT_RECEIVED.value: {
                "title": "ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶",
                "message": "ĞŸĞ¾ÑÑ‚ÑƒĞ¿Ğ¸Ğ»Ğ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğ° Ğ·Ğ° Ğ·Ğ°ĞºĞ°Ğ·"
            },
            NotificationType.VERIFICATION_REQUIRED.value: {
                "title": "Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ",
                "message": "ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸"
            },
            NotificationType.DRIVER_ASSIGNED.value: {
                "title": "Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½",
                "message": "ĞĞ° Ğ²Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ"
            },
            NotificationType.ORDER_IN_PROGRESS.value: {
                "title": "Ğ—Ğ°ĞºĞ°Ğ· Ğ² Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ",
                "message": "Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ"
            },
            NotificationType.ORDER_DELIVERED.value: {
                "title": "Ğ—Ğ°ĞºĞ°Ğ· Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½",
                "message": "Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½"
            },
            NotificationType.PAYMENT_SUCCESS.value: {
                "title": "ĞĞ¿Ğ»Ğ°Ñ‚Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ°",
                "message": "ĞĞ¿Ğ»Ğ°Ñ‚Ğ° Ğ·Ğ° Ğ·Ğ°ĞºĞ°Ğ· Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾"
            },
            NotificationType.PAYMENT_FAILED.value: {
                "title": "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹",
                "message": "ĞŸÑ€Ğ¸ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°"
            }
        }
    
    def _get_template(self, notification_type: str) -> Dict[str, str]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ğ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ"""
        return self.notification_templates.get(notification_type, {
            "title": "Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ",
            "message": "ĞĞ¾Ğ²Ğ¾Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ"
        })
    
    async def send_notification(
        self,
        db,
        user_id: int,
        notification_type: str,
        data: Optional[Dict] = None
    ) -> schemas.NotificationResponse:
        """ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        template = self._get_template(notification_type)
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
        notification = crud.models.Notification(
            user_id=user_id,
            title=template["title"],
            message=template["message"],
            type=notification_type,
            data=data or {}
        )
        
        db.add(notification)
        db.commit()
        db.refresh(notification)
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· WebSocket
        try:
            await manager.send_to_user(user_id, {
                "type": "notification",
                "data": {
                    "id": notification.id,
                    "title": notification.title,
                    "message": notification.message,
                    "type": notification.type,
                    "data": notification.data,
                    "is_read": notification.is_read,
                    "created_at": notification.created_at.isoformat()
                }
            })
        except Exception as e:
            logger.error(f"Error sending notification via WebSocket: {e}")
        
        return schemas.NotificationResponse.model_validate(notification)
    
    async def send_bulk_notifications(
        self,
        db,
        user_ids: List[int],
        notification_type: str,
        data: Optional[Dict] = None
    ) -> List[schemas.NotificationResponse]:
        """ĞœĞ°ÑÑĞ¾Ğ²Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹"""
        notifications = []
        for user_id in user_ids:
            try:
                notification = await self.send_notification(db, user_id, notification_type, data)
                notifications.append(notification)
            except Exception as e:
                logger.error(f"Error sending notification to user {user_id}: {e}")
        
        return notifications
    
    async def notify_new_order(self, db, order_id: int):
        """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·Ğµ"""
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ Ğ¿Ğ¾Ğ±Ğ»Ğ¸Ğ·Ğ¾ÑÑ‚Ğ¸ (ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ)
        # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ğ³ĞµĞ¾Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸
        drivers = crud.get_driver_profiles(db, verification_status="verified", is_online=True)
        
        for driver_profile in drivers[:50]:  # ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾
            await self.send_notification(
                db,
                driver_profile.user_id,
                NotificationType.NEW_ORDER_AVAILABLE.value,
                {
                    "order_id": order.id,
                    "order_number": order.order_number,
                    "from_address": order.from_address,
                    "to_address": order.to_address,
                    "price": order.desired_price,
                    "distance": order.distance_km
                }
            )
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²
        admins = crud.get_users(db, role="admin", is_active=True)
        for admin in admins:
            await self.send_notification(
                db,
                admin.id,
                NotificationType.NEW_ORDER_CREATED.value,
                {
                    "order_id": order.id,
                    "order_number": order.order_number,
                    "client_id": order.client_id,
                    "price": order.desired_price
                }
            )
    
    async def notify_bid_accepted(self, db, bid_id: int):
        """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸ ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
        bid = crud.get_bid(db, bid_id)
        if not bid:
            return
        
        # Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
        await self.send_notification(
            db,
            bid.driver_id,
            NotificationType.BID_ACCEPTED.value,
            {
                "bid_id": bid.id,
                "order_id": bid.order_id,
                "proposed_price": bid.proposed_price
            }
        )
        
        # ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñƒ
        order = crud.get_order(db, bid.order_id)
        if order:
            await self.send_notification(
                db,
                order.client_id,
                NotificationType.DRIVER_ASSIGNED.value,
                {
                    "order_id": order.id,
                    "driver_id": bid.driver_id,
                    "driver_name": bid.driver.full_name if bid.driver else None
                }
            )
    
    async def notify_order_completed(self, db, order_id: int):
        """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        # ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñƒ
        await self.send_notification(
            db,
            order.client_id,
            NotificationType.ORDER_DELIVERED.value,
            {
                "order_id": order.id,
                "order_number": order.order_number,
                "final_price": order.final_price
            }
        )
        
        # Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
        if order.driver_id:
            await self.send_notification(
                db,
                order.driver_id,
                NotificationType.ORDER_COMPLETED.value,
                {
                    "order_id": order.id,
                    "order_number": order.order_number,
                    "order_amount": order.order_amount
                }
            )
    
    async def notify_payment_success(self, db, payment_id: int):
        """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ¹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğµ"""
        payment = crud.get_payment(db, payment_id)
        if not payment:
            return
        
        # ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñƒ
        await self.send_notification(
            db,
            payment.user_id,
            NotificationType.PAYMENT_SUCCESS.value,
            {
                "payment_id": payment.id,
                "amount": payment.amount,
                "order_id": payment.order_id
            }
        )
        
        # ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼
        admins = crud.get_users(db, role="admin", is_active=True)
        for admin in admins:
            await self.send_notification(
                db,
                admin.id,
                NotificationType.PAYMENT_RECEIVED.value,
                {
                    "payment_id": payment.id,
                    "user_id": payment.user_id,
                    "amount": payment.amount
                }
            )

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ ÑĞµÑ€Ğ²Ğ¸ÑĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
notification_service = NotificationService()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\payment.py                                                         â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\payment.py  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ĞŸĞ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ°Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° (ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ)
"""
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import uuid
import logging
from enum import Enum

from . import schemas, crud
from .config import settings

logger = logging.getLogger(__name__)

class PaymentMethod(Enum):
    """ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹"""
    CARD = "card"
    SBP = "sbp"
    YOOMONEY = "yoomoney"
    PAYPAL = "paypal"

class PaymentGateway:
    """ĞŸĞ»Ğ°Ñ‚ĞµĞ¶Ğ½Ñ‹Ğ¹ ÑˆĞ»ÑĞ· (ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ)"""
    
    def __init__(self):
        self.transactions: Dict[str, Dict] = {}
    
    def create_payment(
        self,
        amount: float,
        currency: str = "RUB",
        description: str = "",
        metadata: Optional[Dict] = None
    ) -> Tuple[bool, str, Optional[str]]:
        """
        Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°
        Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚: (ÑƒÑĞ¿ĞµÑ…, ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ, payment_id)
        """
        try:
            # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ID Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°
            payment_id = f"pay_{uuid.uuid4().hex[:16]}"
            
            # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ñ‹Ğ¼ ÑˆĞ»ÑĞ·Ğ¾Ğ¼
            # (Stripe, YooKassa, CloudPayments Ğ¸ Ñ‚.Ğ´.)
            
            # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ñ
            self.transactions[payment_id] = {
                "payment_id": payment_id,
                "amount": amount,
                "currency": currency,
                "description": description,
                "metadata": metadata or {},
                "status": "pending",
                "created_at": datetime.utcnow().isoformat()
            }
            
            logger.info(f"Payment created: {payment_id}, amount: {amount} {currency}")
            
            return True, "Payment created successfully", payment_id
            
        except Exception as e:
            logger.error(f"Error creating payment: {e}")
            return False, f"Error creating payment: {str(e)}", None
    
    def confirm_payment(self, payment_id: str) -> Tuple[bool, str]:
        """ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ° (ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ)"""
        if payment_id not in self.transactions:
            return False, "Payment not found"
        
        transaction = self.transactions[payment_id]
        
        # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ² Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ¼ ÑˆĞ»ÑĞ·Ğµ
        # Ğ”Ğ»Ñ ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ğ¸ Ğ²ÑĞµĞ³Ğ´Ğ° ÑƒÑĞ¿ĞµÑ…
        transaction["status"] = "succeeded"
        transaction["confirmed_at"] = datetime.utcnow().isoformat()
        
        logger.info(f"Payment confirmed: {payment_id}")
        return True, "Payment confirmed successfully"
    
    def refund_payment(self, payment_id: str, amount: Optional[float] = None) -> Tuple[bool, str]:
        """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ° (ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ)"""
        if payment_id not in self.transactions:
            return False, "Payment not found"
        
        transaction = self.transactions[payment_id]
        
        if transaction["status"] != "succeeded":
            return False, "Payment is not succeeded"
        
        refund_amount = amount or transaction["amount"]
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğµ
        refund_id = f"ref_{uuid.uuid4().hex[:16]}"
        
        logger.info(f"Payment refunded: {payment_id}, amount: {refund_amount}")
        return True, f"Refund created: {refund_id}"
    
    def get_payment_status(self, payment_id: str) -> Optional[str]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°"""
        if payment_id in self.transactions:
            return self.transactions[payment_id]["status"]
        return None

class PaymentService:
    """Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹"""
    
    def __init__(self):
        self.gateway = PaymentGateway()
    
    async def create_order_payment(
        self,
        db,
        order_id: int,
        user_id: int,
        payment_method: str
    ) -> Tuple[bool, str, Optional[schemas.PaymentResponse]]:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ° Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
        try:
            # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
            order = crud.get_order(db, order_id)
            if not order:
                return False, "Order not found", None
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ·Ğ°ĞºĞ°Ğ· Ğ¿Ñ€Ğ¸Ğ½Ğ°Ğ´Ğ»ĞµĞ¶Ğ¸Ñ‚ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            if order.client_id != user_id:
                return False, "Order does not belong to user", None
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ·Ğ°ĞºĞ°Ğ· ĞµÑ‰Ğµ Ğ½Ğµ Ğ¾Ğ¿Ğ»Ğ°Ñ‡ĞµĞ½
            if order.payment_status == schemas.PaymentStatus.COMPLETED:
                return False, "Order already paid", None
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½ÑƒÑ Ñ†ĞµĞ½Ñƒ
            if not order.final_price:
                return False, "Order price is not set", None
            
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            payment_create = schemas.PaymentCreate(
                amount=order.final_price,
                order_id=order_id,
                payment_method=payment_method,
                description=f"ĞĞ¿Ğ»Ğ°Ñ‚Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ° #{order.order_number}"
            )
            
            payment = crud.create_payment(db, payment_create, user_id)
            
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ Ğ² Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ¼ ÑˆĞ»ÑĞ·Ğµ
            success, message, gateway_payment_id = self.gateway.create_payment(
                amount=order.final_price,
                currency="RUB",
                description=f"ĞĞ¿Ğ»Ğ°Ñ‚Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ° #{order.order_number}",
                metadata={
                    "order_id": order_id,
                    "order_number": order.order_number,
                    "user_id": user_id
                }
            )
            
            if success and gateway_payment_id:
                # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ Ñ ID Ğ¸Ğ· ÑˆĞ»ÑĞ·Ğ°
                payment = crud.update_payment_status(
                    db,
                    payment.id,
                    schemas.PaymentStatus.PROCESSING.value,
                    gateway_payment_id
                )
                
                # Ğ”Ğ»Ñ ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ğ¸ ÑÑ€Ğ°Ğ·Ñƒ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶
                if settings.TEST_MODE:
                    self.gateway.confirm_payment(gateway_payment_id)
                    payment = crud.update_payment_status(
                        db,
                        payment.id,
                        schemas.PaymentStatus.COMPLETED.value
                    )
                
                logger.info(f"Payment created for order {order_id}: {gateway_payment_id}")
                return True, "Payment created successfully", schemas.PaymentResponse.model_validate(payment)
            else:
                # Ğ•ÑĞ»Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ² ÑˆĞ»ÑĞ·Ğµ, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ
                payment = crud.update_payment_status(
                    db,
                    payment.id,
                    schemas.PaymentStatus.FAILED.value
                )
                return False, f"Payment gateway error: {message}", None
                
        except Exception as e:
            logger.error(f"Error creating payment for order {order_id}: {e}")
            return False, f"Error: {str(e)}", None
    
    async def process_payment_webhook(
        self,
        db,
        payment_id: str,
        status: str,
        metadata: Optional[Dict] = None
    ) -> Tuple[bool, str]:
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²ĞµĞ±Ñ…ÑƒĞºĞ° Ğ¾Ñ‚ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ³Ğ¾ ÑˆĞ»ÑĞ·Ğ°"""
        try:
            # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ Ğ¿Ğ¾ payment_id Ğ¸Ğ· ÑˆĞ»ÑĞ·Ğ°
            payment = db.query(crud.models.Payment).filter(
                crud.models.Payment.payment_id == payment_id
            ).first()
            
            if not payment:
                return False, "Payment not found"
            
            # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°
            payment_status = self._map_gateway_status(status)
            if not payment_status:
                return False, f"Unknown status: {status}"
            
            payment = crud.update_payment_status(db, payment.id, payment_status)
            
            logger.info(f"Payment webhook processed: {payment_id} -> {status}")
            return True, "Webhook processed successfully"
            
        except Exception as e:
            logger.error(f"Error processing payment webhook: {e}")
            return False, f"Error: {str(e)}"
    
    def _map_gateway_status(self, gateway_status: str) -> Optional[str]:
        """ĞœĞ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ² Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ³Ğ¾ ÑˆĞ»ÑĞ·Ğ° Ğ½Ğ° Ğ½Ğ°ÑˆĞ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑÑ‹"""
        status_map = {
            "succeeded": schemas.PaymentStatus.COMPLETED.value,
            "pending": schemas.PaymentStatus.PENDING.value,
            "processing": schemas.PaymentStatus.PROCESSING.value,
            "failed": schemas.PaymentStatus.FAILED.value,
            "refunded": schemas.PaymentStatus.REFUNDED.value,
        }
        return status_map.get(gateway_status.lower())
    
    async def create_payout(
        self,
        db,
        driver_id: int,
        amount: float,
        description: str = ""
    ) -> Tuple[bool, str, Optional[str]]:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ²Ñ‹Ğ¿Ğ»Ğ°Ñ‚Ñ‹ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
        try:
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
            driver = crud.get_user_by_id(db, driver_id)
            if not driver:
                return False, "Driver not found", None
            
            if driver.balance < amount:
                return False, "Insufficient balance", None
            
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ²Ñ‹Ğ¿Ğ»Ğ°Ñ‚Ñƒ Ğ² ÑˆĞ»ÑĞ·Ğµ
            success, message, payout_id = self.gateway.create_payment(
                amount=amount,
                currency="RUB",
                description=description or f"Ğ’Ñ‹Ğ¿Ğ»Ğ°Ñ‚Ğ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ #{driver_id}",
                metadata={
                    "driver_id": driver_id,
                    "type": "payout"
                }
            )
            
            if success:
                # Ğ¡Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
                driver.balance -= amount
                db.commit()
                
                logger.info(f"Payout created for driver {driver_id}: {amount} RUB")
                return True, "Payout created successfully", payout_id
            else:
                return False, message, None
                
        except Exception as e:
            logger.error(f"Error creating payout for driver {driver_id}: {e}")
            return False, f"Error: {str(e)}", None
    
    def get_supported_payment_methods(self) -> List[Dict]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµĞ¼Ñ‹Ñ… Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹"""
        return [
            {
                "id": PaymentMethod.CARD.value,
                "name": "Ğ‘Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ°Ñ ĞºĞ°Ñ€Ñ‚Ğ°",
                "description": "ĞĞ¿Ğ»Ğ°Ñ‚Ğ° ĞºĞ°Ñ€Ñ‚Ğ¾Ğ¹ Visa/Mastercard",
                "min_amount": 10.0,
                "max_amount": 100000.0,
                "currency": "RUB"
            },
            {
                "id": PaymentMethod.SBP.value,
                "name": "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ñ… Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹ (Ğ¡Ğ‘ĞŸ)",
                "description": "ĞĞ¿Ğ»Ğ°Ñ‚Ğ° Ñ‡ĞµÑ€ĞµĞ· Ğ¡Ğ‘ĞŸ Ğ¿Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€Ñƒ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°",
                "min_amount": 1.0,
                "max_amount": 100000.0,
                "currency": "RUB"
            },
            {
                "id": PaymentMethod.YOOMONEY.value,
                "name": "Ğ®Money",
                "description": "ĞĞ¿Ğ»Ğ°Ñ‚Ğ° Ñ‡ĞµÑ€ĞµĞ· ĞºĞ¾ÑˆĞµĞ»ĞµĞº Ğ®Money",
                "min_amount": 10.0,
                "max_amount": 75000.0,
                "currency": "RUB"
            }
        ]

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ³Ğ¾ ÑĞµÑ€Ğ²Ğ¸ÑĞ°
payment_service = PaymentService()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\__init__.py                                                 â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\__init__.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ€Ğ¾ÑƒÑ‚ĞµÑ€Ğ¾Ğ²
"""
from .auth import router as auth_router
from .users import router as users_router
from .drivers import router as drivers_router
from .orders import router as orders_router
from .bids import router as bids_router
from .chat import router as chat_router
from .track import router as track_router
from .admin import router as admin_router
from .health import router as health_router
from .integration import router as integration_router
from .admin_dashboard import router as admin_dashboard_router  # <-- Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›Ğ˜

__all__ = [
    "auth_router",
    "users_router",
    "drivers_router",
    "orders_router",
    "bids_router",
    "chat_router",
    "track_router",
    "admin_router",
    "health_router",
    "integration_router",
    "admin_dashboard_router"  # <-- Ğ”ĞĞ‘ĞĞ’Ğ˜Ğ›Ğ˜
]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\admin.py                                                    â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\admin.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
import logging
from datetime import datetime, timedelta

from .. import schemas, crud, models
from ..auth import get_current_admin
from ..database import get_db
from ..dependencies import PaginationParams
from ..notifications import notification_service

router = APIRouter(prefix="/api/admin", tags=["admin"])
logger = logging.getLogger(__name__)

@router.get("/stats", response_model=schemas.AdminStats)
async def get_admin_stats(
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸
    """
    stats = crud.get_system_stats(db)
    
    return schemas.AdminStats(
        total_users=stats["total_users"],
        total_drivers=stats["total_drivers"],
        total_clients=stats["total_clients"],
        total_orders=stats["total_orders"],
        total_revenue=stats["total_revenue"],
        pending_verifications=stats["pending_verifications"],
        active_orders=stats["active_orders"]
    )

@router.get("/stats/detailed")
async def get_detailed_stats(
    period: str = Query("7d", description="ĞŸĞµÑ€Ğ¸Ğ¾Ğ´: 1d, 7d, 30d"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
    """
    # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´
    if period == "1d":
        days = 1
    elif period == "30d":
        days = 30
    else:  # 7d Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
        days = 7
    
    start_date = datetime.utcnow() - timedelta(days=days)
    
    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    new_users = db.query(models.User).filter(
        models.User.created_at >= start_date
    ).count()
    
    new_drivers = db.query(models.User).filter(
        models.User.role == models.UserRole.DRIVER,
        models.User.created_at >= start_date
    ).count()
    
    new_clients = db.query(models.User).filter(
        models.User.role == models.UserRole.CLIENT,
        models.User.created_at >= start_date
    ).count()
    
    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
    new_orders = db.query(models.Order).filter(
        models.Order.created_at >= start_date
    ).count()
    
    completed_orders = db.query(models.Order).filter(
        models.Order.status == models.OrderStatus.COMPLETED,
        models.Order.updated_at >= start_date
    ).count()
    
    cancelled_orders = db.query(models.Order).filter(
        models.Order.status == models.OrderStatus.CANCELLED,
        models.Order.updated_at >= start_date
    ).count()
    
    # Ğ¤Ğ¸Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    revenue = db.query(models.Order).filter(
        models.Order.status.in_([models.OrderStatus.COMPLETED, models.OrderStatus.PAID]),
        models.Order.updated_at >= start_date
    ).all()
    
    total_revenue = sum(order.platform_fee or 0 for order in revenue)
    total_order_amount = sum(order.final_price or 0 for order in revenue)
    
    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ Ğ´Ğ½ÑĞ¼
    daily_stats = []
    for i in range(days):
        day = start_date + timedelta(days=i)
        next_day = day + timedelta(days=1)
        
        daily_orders = db.query(models.Order).filter(
            models.Order.created_at >= day,
            models.Order.created_at < next_day
        ).count()
        
        daily_revenue = db.query(models.Order).filter(
            models.Order.status.in_([models.OrderStatus.COMPLETED, models.OrderStatus.PAID]),
            models.Order.updated_at >= day,
            models.Order.updated_at < next_day
        ).all()
        
        daily_total_revenue = sum(order.platform_fee or 0 for order in daily_revenue)
        
        daily_stats.append({
            "date": day.strftime("%Y-%m-%d"),
            "orders": daily_orders,
            "revenue": daily_total_revenue
        })
    
    return {
        "period": period,
        "start_date": start_date.isoformat(),
        "end_date": datetime.utcnow().isoformat(),
        "users": {
            "new_users": new_users,
            "new_drivers": new_drivers,
            "new_clients": new_clients,
            "total_users": stats["total_users"]
        },
        "orders": {
            "new_orders": new_orders,
            "completed_orders": completed_orders,
            "cancelled_orders": cancelled_orders,
            "active_orders": stats["active_orders"],
            "total_orders": stats["total_orders"]
        },
        "financial": {
            "total_revenue": total_revenue,
            "total_order_amount": total_order_amount,
            "avg_order_value": total_order_amount / len(revenue) if revenue else 0,
            "platform_fee_percentage": 5.0  # 5% ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ
        },
        "daily_stats": daily_stats
    }

@router.get("/verifications/pending")
async def get_pending_verifications(
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹, Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ñ… Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
    """
    profiles = crud.get_driver_profiles(
        db,
        skip=pagination.skip,
        limit=pagination.limit,
        verification_status=models.VerificationStatus.PENDING.value
    )
    
    result = []
    for profile in profiles:
        result.append({
            "user": schemas.UserResponse.model_validate(profile.user),
            "profile": schemas.DriverProfileResponse.model_validate(profile),
            "documents": {
                "license": bool(profile.license_path),
                "passport": bool(profile.passport_path),
                "vehicle_registration": bool(profile.vehicle_registration_path),
                "insurance": bool(profile.insurance_path)
            },
            "days_waiting": (datetime.utcnow() - profile.created_at).days
        })
    
    return result

@router.post("/verifications/{driver_id}")
async def verify_driver(
    driver_id: int,
    verification: schemas.VerificationRequest,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    if profile.verification_status != models.VerificationStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ ÑƒĞ¶Ğµ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½"
        )
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
    profile.verification_status = verification.status
    db.commit()
    db.refresh(profile)
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user = crud.get_user_by_id(db, driver_id)
    if user:
        user.is_verified = (verification.status == models.VerificationStatus.VERIFIED)
        db.commit()
    
    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    background_tasks.add_task(
        notify_driver_about_verification,
        db,
        driver_id,
        verification.status,
        verification.notes
    )
    
    logger.info(f"Driver {driver_id} verification updated to {verification.status} by admin {current_user.email}")
    
    return {
        "message": f"Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ½Ğ° {verification.status.value}",
        "driver_id": driver_id,
        "status": verification.status.value,
        "verified_by": current_user.email
    }

@router.get("/recent-activity")
async def get_recent_activity(
    limit: int = Query(50, ge=1, le=200, description="ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ½ĞµĞ´Ğ°Ğ²Ğ½ĞµĞ¹ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ
    """
    activities = []
    
    # ĞĞµĞ´Ğ°Ğ²Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
    recent_orders = db.query(models.Order)\
        .order_by(models.Order.created_at.desc())\
        .limit(limit // 3)\
        .all()
    
    for order in recent_orders:
        activities.append({
            "type": "order_created",
            "timestamp": order.created_at,
            "data": {
                "order_id": order.id,
                "order_number": order.order_number,
                "client_id": order.client_id,
                "client_email": order.client.email,
                "status": order.status.value,
                "price": order.desired_price
            }
        })
    
    # ĞĞµĞ´Ğ°Ğ²Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸
    recent_users = db.query(models.User)\
        .order_by(models.User.created_at.desc())\
        .limit(limit // 3)\
        .all()
    
    for user in recent_users:
        activities.append({
            "type": "user_registered",
            "timestamp": user.created_at,
            "data": {
                "user_id": user.id,
                "email": user.email,
                "role": user.role.value,
                "phone": user.phone
            }
        })
    
    # ĞĞµĞ´Ğ°Ğ²Ğ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ¸
    recent_payments = db.query(models.Payment)\
        .order_by(models.Payment.created_at.desc())\
        .limit(limit // 3)\
        .all()
    
    for payment in recent_payments:
        activities.append({
            "type": "payment_processed",
            "timestamp": payment.created_at,
            "data": {
                "payment_id": payment.id,
                "user_id": payment.user_id,
                "user_email": payment.user.email,
                "amount": payment.amount,
                "status": payment.status.value,
                "order_id": payment.order_id
            }
        })
    
    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¿Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
    activities.sort(key=lambda x: x["timestamp"], reverse=True)
    
    # ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ°
    activities = activities[:limit]
    
    return activities

@router.get("/financial/transactions")
async def get_financial_transactions(
    start_date: Optional[str] = Query(None, description="Ğ”Ğ°Ñ‚Ğ° Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° (YYYY-MM-DD)"),
    end_date: Optional[str] = Query(None, description="Ğ”Ğ°Ñ‚Ğ° Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ (YYYY-MM-DD)"),
    status: Optional[str] = Query(None, description="Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°"),
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ„Ğ¸Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ñ‹Ñ… Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹
    """
    query = db.query(models.Payment)
    
    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğµ
    if start_date:
        try:
            start = datetime.strptime(start_date, "%Y-%m-%d")
            query = query.filter(models.Payment.created_at >= start)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ñ‚Ñ‹ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ°"
            )
    
    if end_date:
        try:
            end = datetime.strptime(end_date, "%Y-%m-%d") + timedelta(days=1)
            query = query.filter(models.Payment.created_at < end)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ´Ğ°Ñ‚Ñ‹ Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸Ñ"
            )
    
    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ
    if status:
        query = query.filter(models.Payment.status == status)
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹
    payments = query.order_by(models.Payment.created_at.desc())\
                   .offset(pagination.skip)\
                   .limit(pagination.limit)\
                   .all()
    
    # Ğ Ğ°ÑÑ‡ĞµÑ‚ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
    total_amount = sum(p.amount for p in payments)
    completed_amount = sum(p.amount for p in payments if p.status == models.PaymentStatus.COMPLETED)
    pending_amount = sum(p.amount for p in payments if p.status == models.PaymentStatus.PENDING)
    
    return {
        "transactions": payments,
        "statistics": {
            "total_count": len(payments),
            "total_amount": total_amount,
            "completed_amount": completed_amount,
            "pending_amount": pending_amount,
            "completed_count": len([p for p in payments if p.status == models.PaymentStatus.COMPLETED]),
            "pending_count": len([p for p in payments if p.status == models.PaymentStatus.PENDING])
        }
    }

@router.get("/orders/analytics")
async def get_orders_analytics(
    period: str = Query("30d", description="ĞŸĞµÑ€Ğ¸Ğ¾Ğ´: 7d, 30d, 90d"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ğ¼
    """
    # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´
    if period == "7d":
        days = 7
    elif period == "90d":
        days = 90
    else:  # 30d Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
        days = 30
    
    start_date = datetime.utcnow() - timedelta(days=days)
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ·Ğ° Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´
    orders = db.query(models.Order).filter(
        models.Order.created_at >= start_date
    ).all()
    
    if not orders:
        return {
            "period": period,
            "total_orders": 0,
            "analytics": {}
        }
    
    # ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼
    status_counts = {}
    for status in models.OrderStatus:
        status_counts[status.value] = len([o for o in orders if o.status == status])
    
    # ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ Ñ‚Ğ¸Ğ¿Ğ°Ğ¼ Ğ³Ñ€ÑƒĞ·Ğ°
    cargo_types = {}
    for order in orders:
        cargo_type = order.cargo_type
        if cargo_type not in cargo_types:
            cargo_types[cargo_type] = 0
        cargo_types[cargo_type] += 1
    
    # ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ Ñ†ĞµĞ½Ğ°Ğ¼
    prices = [o.final_price or o.desired_price for o in orders if o.final_price or o.desired_price]
    avg_price = sum(prices) / len(prices) if prices else 0
    min_price = min(prices) if prices else 0
    max_price = max(prices) if prices else 0
    
    # ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸ÑĞ¼
    distances = [o.distance_km for o in orders if o.distance_km]
    avg_distance = sum(distances) / len(distances) if distances else 0
    
    # Ğ¢Ğ¾Ğ¿ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ²
    client_orders = {}
    for order in orders:
        client_id = order.client_id
        if client_id not in client_orders:
            client_orders[client_id] = 0
        client_orders[client_id] += 1
    
    top_clients = sorted(client_orders.items(), key=lambda x: x[1], reverse=True)[:10]
    top_clients_details = []
    for client_id, order_count in top_clients:
        client = crud.get_user_by_id(db, client_id)
        if client:
            top_clients_details.append({
                "client_id": client_id,
                "email": client.email,
                "full_name": client.full_name,
                "order_count": order_count
            })
    
    # Ğ¢Ğ¾Ğ¿ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹
    driver_orders = {}
    for order in orders:
        if order.driver_id:
            driver_id = order.driver_id
            if driver_id not in driver_orders:
                driver_orders[driver_id] = 0
            driver_orders[driver_id] += 1
    
    top_drivers = sorted(driver_orders.items(), key=lambda x: x[1], reverse=True)[:10]
    top_drivers_details = []
    for driver_id, order_count in top_drivers:
        driver = crud.get_user_by_id(db, driver_id)
        driver_profile = crud.get_driver_profile(db, driver_id)
        if driver:
            top_drivers_details.append({
                "driver_id": driver_id,
                "email": driver.email,
                "full_name": driver.full_name,
                "vehicle_number": driver_profile.vehicle_number if driver_profile else None,
                "order_count": order_count
            })
    
    return {
        "period": period,
        "total_orders": len(orders),
        "analytics": {
            "by_status": status_counts,
            "by_cargo_type": cargo_types,
            "price_statistics": {
                "average": round(avg_price, 2),
                "minimum": round(min_price, 2),
                "maximum": round(max_price, 2),
                "total_revenue": sum([o.platform_fee or 0 for o in orders])
            },
            "distance_statistics": {
                "average_km": round(avg_distance, 2),
                "total_km": sum(distances)
            },
            "top_clients": top_clients_details,
            "top_drivers": top_drivers_details
        }
    }

@router.post("/system/announcement")
async def create_system_announcement(
    announcement: dict,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ğ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ¸Ñ
    """
    title = announcement.get("title", "")
    message = announcement.get("message", "")
    target = announcement.get("target", "all")  # all, clients, drivers
    
    if not title or not message:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ğ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹"
        )
    
    # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ñ†ĞµĞ»ĞµĞ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    if target == "clients":
        users = crud.get_users(db, role=models.UserRole.CLIENT.value, is_active=True)
    elif target == "drivers":
        users = crud.get_users(db, role=models.UserRole.DRIVER.value, is_active=True)
    else:  # all
        users = crud.get_users(db, is_active=True)
    
    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
    user_ids = [user.id for user in users]
    
    background_tasks.add_task(
        send_bulk_notifications,
        db,
        user_ids,
        "system_announcement",
        {"title": title, "message": message, "from_admin": current_user.email}
    )
    
    logger.info(f"System announcement created by {current_user.email}: {title}")
    
    return {
        "message": "ĞĞ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾",
        "recipients_count": len(user_ids),
        "target": target,
        "title": title
    }

@router.get("/system/logs")
async def get_system_logs(
    level: Optional[str] = Query(None, description="Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ: INFO, WARNING, ERROR"),
    search: Optional[str] = Query(None, description="ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ"),
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… Ğ»Ğ¾Ğ³Ğ¾Ğ² (ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ - Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ELK Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ğ½Ğ¾Ğµ)
    """
    # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğº ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
    # Ğ”Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ° Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ mock Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    
    mock_logs = [
        {
            "timestamp": datetime.utcnow().isoformat(),
            "level": "INFO",
            "message": "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ°",
            "source": "system"
        },
        {
            "timestamp": (datetime.utcnow() - timedelta(hours=1)).isoformat(),
            "level": "INFO",
            "message": "ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½",
            "source": "auth",
            "user_id": 1
        },
        {
            "timestamp": (datetime.utcnow() - timedelta(hours=2)).isoformat(),
            "level": "WARNING",
            "message": "ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ²Ñ…Ğ¾Ğ´Ğ° Ñ Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¼ Ğ¿Ğ°Ñ€Ğ¾Ğ»ĞµĞ¼",
            "source": "auth",
            "user_email": "test@example.com"
        },
        {
            "timestamp": (datetime.utcnow() - timedelta(hours=3)).isoformat(),
            "level": "ERROR",
            "message": "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°",
            "source": "payment",
            "payment_id": 123
        }
    ]
    
    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ
    if level:
        mock_logs = [log for log in mock_logs if log["level"] == level]
    
    if search:
        mock_logs = [log for log in mock_logs if search.lower() in log["message"].lower()]
    
    # ĞŸĞ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ
    total = len(mock_logs)
    logs = mock_logs[pagination.skip:pagination.skip + pagination.limit]
    
    return {
        "logs": logs,
        "total": total,
        "page": pagination.skip // pagination.limit + 1,
        "pages": (total + pagination.limit - 1) // pagination.limit
    }

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
async def notify_driver_about_verification(
    db: Session,
    driver_id: int,
    status: str,
    notes: Optional[str] = None
):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğµ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸"""
    try:
        notification_type = "driver_verified" if status == models.VerificationStatus.VERIFIED else "driver_rejected"
        
        await notification_service.send_notification(
            db,
            driver_id,
            notification_type,
            {
                "status": status,
                "notes": notes,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
    except Exception as e:
        logger.error(f"Error notifying driver about verification: {e}")

async def send_bulk_notifications(
    db: Session,
    user_ids: List[int],
    notification_type: str,
    data: dict
):
    """ĞœĞ°ÑÑĞ¾Ğ²Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹"""
    try:
        await notification_service.send_bulk_notifications(
            db,
            user_ids,
            notification_type,
            data
        )
        logger.info(f"Bulk notifications sent to {len(user_ids)} users: {notification_type}")
    except Exception as e:
        logger.error(f"Error sending bulk notifications: {e}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\admin_dashboard.py                                          â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\admin_dashboard.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸
"""
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional
import logging

from .. import schemas, crud, models
from ..auth import get_current_admin
from ..database import get_db

router = APIRouter(prefix="/api/admin", tags=["admin-dashboard"])
logger = logging.getLogger(__name__)

@router.get("/dashboard/stats")
async def get_dashboard_stats(
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ´Ğ»Ñ Ğ´Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´Ğ° Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸
    """
    stats = crud.get_system_stats(db)
    
    return {
        "totalUsers": stats["total_users"],
        "totalOrders": stats["total_orders"],
        "totalDrivers": stats["total_drivers"],
        "pendingVerifications": stats["pending_verifications"],
        "activeOrders": stats["active_orders"],
        "totalRevenue": stats["total_revenue"],
        "newUsersWeek": stats["new_users_week"],
        "newOrdersWeek": stats["new_orders_week"],
        "revenueWeek": stats["revenue_week"]
    }

@router.get("/users")
async def get_all_users(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    role: Optional[str] = Query(None),
    is_active: Optional[bool] = Query(None),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    """
    users = crud.get_users(db, skip=skip, limit=limit, role=role, is_active=is_active)
    return [schemas.UserResponse.model_validate(user) for user in users]

@router.get("/drivers")
async def get_all_drivers(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    verification_status: Optional[str] = Query(None),
    is_online: Optional[bool] = Query(None),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ²ÑĞµÑ… Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹
    """
    profiles = crud.get_driver_profiles(
        db,
        skip=skip,
        limit=limit,
        verification_status=verification_status,
        is_online=is_online
    )
    
    result = []
    for profile in profiles:
        result.append({
            "id": profile.user.id,
            "firstName": profile.user.full_name.split()[0] if profile.user.full_name else "",
            "lastName": " ".join(profile.user.full_name.split()[1:]) if profile.user.full_name else "",
            "email": profile.user.email,
            "phone": profile.user.phone,
            "vehicleType": profile.vehicle_type,
            "licensePlate": profile.vehicle_number,
            "verificationStatus": profile.verification_status.value,
            "rating": profile.rating,
            "totalOrders": profile.total_orders,
            "isOnline": profile.is_online,
            "createdAt": profile.user.created_at.isoformat()
        })
    
    return result

@router.get("/drivers/active")
async def get_active_drivers(
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹
    """
    profiles = crud.get_driver_profiles(db, is_online=True, limit=50)
    
    result = []
    for profile in profiles:
        result.append({
            "id": profile.user.id,
            "firstName": profile.user.full_name.split()[0] if profile.user.full_name else "",
            "lastName": " ".join(profile.user.full_name.split()[1:]) if profile.user.full_name else "",
            "email": profile.user.email,
            "phone": profile.user.phone,
            "vehicleType": profile.vehicle_type,
            "vehicleModel": profile.vehicle_model,
            "licensePlate": profile.vehicle_number,
            "verificationStatus": profile.verification_status.value,
            "rating": profile.rating,
            "location": {
                "latitude": profile.current_location_lat,
                "longitude": profile.current_location_lng
            } if profile.current_location_lat and profile.current_location_lng else None,
            "lastUpdate": profile.updated_at.isoformat() if profile.updated_at else profile.created_at.isoformat()
        })
    
    return result

@router.get("/drivers/{driver_id}")
async def get_driver_by_id(
    driver_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğµ
    """
    user = crud.get_user_by_id(db, driver_id)
    if not user or user.role != models.UserRole.DRIVER:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    orders = crud.get_orders(db, driver_id=driver_id, limit=10)
    
    return {
        "id": user.id,
        "firstName": user.full_name.split()[0] if user.full_name else "",
        "lastName": " ".join(user.full_name.split()[1:]) if user.full_name else "",
        "email": user.email,
        "phone": user.phone,
        "dateOfBirth": None,  # Ğ’ Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ¼ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ
        "vehicleType": profile.vehicle_type,
        "vehicleModel": profile.vehicle_model,
        "vehicleColor": None,  # Ğ’ Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ¼ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ
        "licensePlate": profile.vehicle_number,
        "verificationStatus": profile.verification_status.value,
        "rating": profile.rating,
        "totalOrders": profile.total_orders,
        "completedOrders": len([o for o in orders if o.status == models.OrderStatus.COMPLETED]),
        "cancelledOrders": len([o for o in orders if o.status == models.OrderStatus.CANCELLED]),
        "isOnline": profile.is_online,
        "documents": [
            {"type": "license", "url": f"/uploads/{profile.license_path}", "uploadedAt": profile.created_at.isoformat()} if profile.license_path else None,
            {"type": "passport", "url": f"/uploads/{profile.passport_path}", "uploadedAt": profile.created_at.isoformat()} if profile.passport_path else None,
            {"type": "registration", "url": f"/uploads/{profile.vehicle_registration_path}", "uploadedAt": profile.created_at.isoformat()} if profile.vehicle_registration_path else None,
        ],
        "createdAt": user.created_at.isoformat()
    }

@router.patch("/drivers/{driver_id}/verify")
async def verify_driver(
    driver_id: int,
    status: str,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    if status not in ["verified", "rejected", "pending"]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ"
        )
    
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    profile.verification_status = models.VerificationStatus(status)
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user = crud.get_user_by_id(db, driver_id)
    if user:
        user.is_verified = (status == "verified")
    
    db.commit()
    
    return {"message": f"Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ½Ğ° {status}", "driverId": driver_id}

@router.get("/orders")
async def get_all_orders(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    status: Optional[str] = Query(None),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ²ÑĞµÑ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
    """
    orders = crud.get_orders(db, skip=skip, limit=limit, status=status)
    
    result = []
    for order in orders:
        result.append({
            "id": order.id,
            "orderNumber": order.order_number,
            "customer": {
                "id": order.client.id,
                "name": order.client.full_name,
                "email": order.client.email,
                "phone": order.client.phone
            } if order.client else None,
            "driver": {
                "id": order.driver.id,
                "name": order.driver.full_name,
                "phone": order.driver.phone,
                "vehicleType": order.driver.driver_profile.vehicle_type if order.driver.driver_profile else None
            } if order.driver else None,
            "pickupAddress": order.from_address,
            "deliveryAddress": order.to_address,
            "pickupInstructions": None,  # Ğ’ Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ¼ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ
            "deliveryInstructions": None,  # Ğ’ Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ¼ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ
            "packageType": order.cargo_type,
            "weight": order.cargo_weight,
            "dimensions": {
                "length": order.cargo_volume ** (1/3),
                "width": order.cargo_volume ** (1/3),
                "height": order.cargo_volume ** (1/3)
            },
            "totalAmount": order.final_price or order.desired_price,
            "status": order.status.value,
            "createdAt": order.created_at.isoformat(),
            "timeline": [
                {
                    "status": "created",
                    "timestamp": order.created_at.isoformat()
                }
            ] + ([
                {
                    "status": "pickup_scheduled",
                    "timestamp": order.pickup_date.isoformat()
                }
            ] if order.pickup_date else []) + ([
                {
                    "status": "delivered",
                    "timestamp": order.completed_at.isoformat()
                }
            ] if order.completed_at else [])
        })
    
    return result

@router.patch("/orders/{order_id}/status")
async def update_order_status(
    order_id: int,
    status: str,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
    valid_statuses = [s.value for s in models.OrderStatus]
    if status not in valid_statuses:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ. Ğ”Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ: {', '.join(valid_statuses)}"
        )
    
    order.status = models.OrderStatus(status)
    
    # Ğ•ÑĞ»Ğ¸ Ğ·Ğ°ĞºĞ°Ğ· Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½, ÑƒÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ´Ğ°Ñ‚Ñƒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ
    if status == models.OrderStatus.COMPLETED.value and not order.completed_at:
        order.completed_at = datetime.utcnow()
    
    db.commit()
    
    return {"message": f"Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ½Ğ° {status}", "orderId": order_id}

@router.patch("/users/{user_id}/toggle-block")
async def toggle_user_block(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°/Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    """
    if user_id == current_user.id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ»ÑŒĞ·Ñ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ°Ğ¼Ğ¾Ğ³Ğ¾ ÑĞµĞ±Ñ"
        )
    
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    user.is_active = not user.is_active
    db.commit()
    
    status_text = "Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½" if user.is_active else "Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½"
    return {"message": f"ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ {status_text}", "userId": user_id, "isActive": user.is_active}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\auth.py                                                     â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\auth.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
"""
from datetime import timedelta
from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
import logging

from .. import schemas, crud
from ..auth import (
    authenticate_user, create_access_token, create_refresh_token,
    verify_token, get_current_user, ACCESS_TOKEN_EXPIRE_MINUTES,
    get_password_hash
)
from ..database import get_db
from ..notifications import notification_service

router = APIRouter(prefix="/api/auth", tags=["authentication"])
logger = logging.getLogger(__name__)

@router.post("/register", response_model=schemas.UserResponse)
async def register(
    user: schemas.UserCreate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    """
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    db_user = crud.get_user_by_email(db, email=user.email)
    if db_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ¾Ğ¼ĞµÑ€Ğ° Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°
    db_user_by_phone = db.query(crud.models.User).filter(
        crud.models.User.phone == user.phone
    ).first()
    
    if db_user_by_phone:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ° ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½"
        )
    
    # ĞĞ±Ñ€ĞµĞ·Ğ°ĞµĞ¼ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ ĞµÑĞ»Ğ¸ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğ¹
    if len(user.password) > 72:
        user.password = user.password[:72]
    
    try:
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        created_user = crud.create_user(db=db, user=user)
        
        # Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼
        if user.role == schemas.UserRole.DRIVER:
            background_tasks.add_task(
                notify_admins_about_new_driver,
                db,
                created_user.id
            )
        
        logger.info(f"User registered: {created_user.email}, role: {created_user.role}")
        
        return created_user
        
    except Exception as e:
        logger.error(f"Error during registration: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"ĞÑˆĞ¸Ğ±ĞºĞ° Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸: {str(e)}"
        )

@router.post("/login", response_model=schemas.Token)
async def login(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    db: Session = Depends(get_db)
):
    """
    Ğ’Ñ…Ğ¾Ğ´ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ
    """
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºÑƒ
    print(f"ğŸ” LOGIN ATTEMPT:")
    print(f"  Username (email): {form_data.username}")
    print(f"  Password length: {len(form_data.password) if form_data.password else 0}")
    
    user = authenticate_user(db, form_data.username, form_data.password)
    
    if not user:
        print(f"âŒ AUTH FAILED: User not found or password incorrect")
        print(f"   Searching for email: {form_data.username}")
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        existing_user = crud.get_user_by_email(db, form_data.username)
        if existing_user:
            print(f"   User exists: {existing_user.email}, active: {existing_user.is_active}")
            print(f"   Hashed password: {existing_user.hashed_password[:30]}...")
        else:
            print(f"   No user with email: {form_data.username}")
        
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ email Ğ¸Ğ»Ğ¸ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    print(f"âœ… USER FOUND: {user.email}, Role: {user.role}, Active: {user.is_active}")
    
    if not user.is_active:
        print(f"âŒ USER INACTIVE: {user.email} is not active")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½ĞµĞ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½"
        )
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ²
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"user_id": user.id, "email": user.email, "role": user.role.value},
        expires_delta=access_token_expires
    )
    refresh_token = create_refresh_token(
        data={"user_id": user.id, "email": user.email, "role": user.role.value}
    )
    
    logger.info(f"User logged in: {user.email}, role: {user.role}")
    
    response_data = {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "user": schemas.UserResponse.model_validate(user)
    }
    
    print(f"âœ… LOGIN SUCCESSFUL: {user.email}")
    print(f"   Token: {access_token[:50]}...")
    print(f"   Response structure: {response_data}")
    
    return schemas.Token(**response_data)

@router.post("/refresh", response_model=schemas.Token)
async def refresh_token(
    data: dict,
    db: Session = Depends(get_db)
):
    """
    ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ access Ñ‚Ğ¾ĞºĞµĞ½Ğ° Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ refresh Ñ‚Ğ¾ĞºĞµĞ½Ğ°
    """
    refresh_token = data.get("refresh_token")
    if not refresh_token:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Refresh token is required"
        )
    
    payload = verify_token(refresh_token)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ refresh Ñ‚Ğ¾ĞºĞµĞ½"
        )
    
    token_type = payload.get("type")
    if token_type != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ñ‚Ğ¾ĞºĞµĞ½Ğ°"
        )
    
    user_id = payload.get("user_id")
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½ĞµĞ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½"
        )
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ²
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"user_id": user.id, "email": user.email, "role": user.role.value},
        expires_delta=access_token_expires
    )
    new_refresh_token = create_refresh_token(
        data={"user_id": user.id, "email": user.email, "role": user.role.value}
    )
    
    logger.info(f"Token refreshed for user: {user.email}")
    
    return schemas.Token(
        access_token=access_token,
        refresh_token=new_refresh_token,
        token_type="bearer",
        user=schemas.UserResponse.model_validate(user)
    )

@router.get("/me", response_model=schemas.UserResponse)
async def get_current_user_info(
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)]
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ
    """
    return current_user

@router.post("/change-password")
async def change_password(
    password_data: schemas.UserUpdate,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    Ğ¡Ğ¼ĞµĞ½Ğ° Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ
    """
    if not password_data.password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"
        )
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ
    hashed_password = get_password_hash(password_data.password)
    current_user.hashed_password = hashed_password
    db.commit()
    
    logger.info(f"Password changed for user: {current_user.email}")
    
    return {"message": "ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½"}

@router.post("/reset-password-request")
async def reset_password_request(
    data: dict,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½Ğ° ÑĞ±Ñ€Ğ¾Ñ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ
    """
    email = data.get("email")
    if not email:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email is required"
        )
    
    user = crud.get_user_by_email(db, email)
    if not user:
        # Ğ”Ğ»Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ Ğ½Ğµ Ñ€Ğ°ÑĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼, ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ
        return {"message": "Ğ•ÑĞ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ñ Ñ‚Ğ°ĞºĞ¸Ğ¼ email ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚, Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ½Ğ° Ğ¿Ğ¾Ñ‡Ñ‚Ñƒ"}
    
    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½ ÑĞ±Ñ€Ğ¾ÑĞ° Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ
    reset_token = create_access_token(
        data={"user_id": user.id, "purpose": "password_reset"},
        expires_delta=timedelta(hours=1)
    )
    
    # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° email
    # background_tasks.add_task(send_password_reset_email, user.email, reset_token)
    
    logger.info(f"Password reset requested for user: {user.email}")
    
    return {"message": "Ğ•ÑĞ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ñ Ñ‚Ğ°ĞºĞ¸Ğ¼ email ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚, Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ½Ğ° Ğ¿Ğ¾Ñ‡Ñ‚Ñƒ"}

@router.post("/reset-password")
async def reset_password(
    data: dict,
    db: Session = Depends(get_db)
):
    """
    Ğ¡Ğ±Ñ€Ğ¾Ñ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½Ğ°
    """
    token = data.get("token")
    new_password = data.get("new_password")
    
    if not token or not new_password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Token and new password are required"
        )
    
    payload = verify_token(token)
    if not payload or payload.get("purpose") != "password_reset":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ¸Ğ»Ğ¸ Ğ¿Ñ€Ğ¾ÑÑ€Ğ¾Ñ‡ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ‚Ğ¾ĞºĞµĞ½"
        )
    
    user_id = payload.get("user_id")
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ
    hashed_password = get_password_hash(new_password)
    user.hashed_password = hashed_password
    db.commit()
    
    logger.info(f"Password reset for user: {user.email}")
    
    return {"message": "ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½"}

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
async def notify_admins_about_new_driver(db: Session, driver_id: int):
    """
    Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğµ
    """
    try:
        admins = crud.get_users(db, role="admin", is_active=True)
        for admin in admins:
            await notification_service.send_notification(
                db,
                admin.id,
                "new_driver_registered",
                {"driver_id": driver_id}
            )
    except Exception as e:
        logger.error(f"Error notifying admins about new driver: {e}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\bids.py                                                     â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\bids.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ ÑĞ¾ ÑÑ‚Ğ°Ğ²ĞºĞ°Ğ¼Ğ¸
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List
import logging

from .. import schemas, crud, models
from ..auth import get_current_active_user, get_current_driver, get_current_client_or_admin
from ..database import get_db
from ..dependencies import PaginationParams
from ..notifications import notification_service

router = APIRouter(prefix="/api/bids", tags=["bids"])
logger = logging.getLogger(__name__)

@router.post("/order/{order_id}", response_model=schemas.BidResponse)
async def create_bid(
    order_id: int,
    bid: schemas.BidCreate,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ·
    """
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile or profile.verification_status != models.VerificationStatus.VERIFIED:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ½Ğµ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    if order.status != models.OrderStatus.SEARCHING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ´Ğ»Ñ ÑÑ‚Ğ°Ğ²Ğ¾Ğº"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°, Ğ½Ğµ Ğ´ĞµĞ»Ğ°ĞµÑ‚ Ğ»Ğ¸ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ½Ğ° ÑĞ²Ğ¾Ğ¹ Ğ¶Ğµ Ğ·Ğ°ĞºĞ°Ğ·
    if order.client_id == current_user.id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ»ÑŒĞ·Ñ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ½Ğ° ÑĞ²Ğ¾Ğ¹ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°, Ğ½Ğµ Ğ´ĞµĞ»Ğ°Ğ» Ğ»Ğ¸ ÑƒĞ¶Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ½Ğ° ÑÑ‚Ğ¾Ñ‚ Ğ·Ğ°ĞºĞ°Ğ·
    existing_bid = db.query(models.Bid).filter(
        models.Bid.order_id == order_id,
        models.Bid.driver_id == current_user.id
    ).first()
    
    if existing_bid:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ğ’Ñ‹ ÑƒĞ¶Ğµ ÑĞ´ĞµĞ»Ğ°Ğ»Ğ¸ ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ½Ğ° ÑÑ‚Ğ¾Ñ‚ Ğ·Ğ°ĞºĞ°Ğ·"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°, Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ»Ğ¸ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ¿Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼ Ğ³Ñ€ÑƒĞ·Ğ°
    if (order.cargo_weight > profile.carrying_capacity or 
        order.cargo_volume > profile.volume):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Ğ’Ğ°Ñˆ Ñ‚Ñ€Ğ°Ğ½ÑĞ¿Ğ¾Ñ€Ñ‚ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ³Ñ€ÑƒĞ·Ğ°. "
                  f"Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ: Ğ´Ğ¾ {order.cargo_weight}Ñ‚, {order.cargo_volume}Ğ¼Â³. "
                  f"Ğ’Ğ°ÑˆĞ¸ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸: {profile.carrying_capacity}Ñ‚, {profile.volume}Ğ¼Â³"
        )
    
    try:
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ğ²ĞºÑƒ
        created_bid = crud.create_bid(db, bid, order_id, current_user.id)
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ° Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ÑÑ‚Ğ°Ğ²ĞºĞµ
        background_tasks.add_task(
            notify_client_about_new_bid,
            db,
            order_id,
            created_bid.id
        )
        
        logger.info(f"Bid created: ID {created_bid.id} for order {order_id} by driver {current_user.email}")
        
        return created_bid
        
    except ValueError as e:
        logger.error(f"Error creating bid: {e}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Error creating bid: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ ÑÑ‚Ğ°Ğ²ĞºĞ¸: {str(e)}"
        )

@router.get("/order/{order_id}", response_model=List[schemas.BidResponse])
async def get_order_bids(
    order_id: int,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° ÑÑ‚Ğ°Ğ²Ğ¾Ğº Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    has_access = False
    
    if current_user.role == models.UserRole.ADMIN:
        has_access = True
    elif current_user.role == models.UserRole.CLIENT and order.client_id == current_user.id:
        has_access = True
    elif current_user.role == models.UserRole.DRIVER and order.driver_id == current_user.id:
        has_access = True
    
    if not has_access:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº ÑÑ‚Ğ°Ğ²ĞºĞ°Ğ¼ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ğ²ĞºĞ¸
    bids = crud.get_bids_by_order(db, order_id)
    
    # Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ, Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµĞ³Ğ¾ ÑÑ‚Ğ°Ğ²ĞºĞ¸
    if current_user.role == models.UserRole.DRIVER and order.client_id != current_user.id:
        bids = [bid for bid in bids if bid.driver_id == current_user.id]
    
    return bids

@router.get("/my", response_model=List[schemas.BidResponse])
async def get_my_bids(
    pagination: PaginationParams = Depends(),
    status: str = Query(None, description="Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ"),
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° ÑÑ‚Ğ°Ğ²Ğ¾Ğº Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    query = db.query(models.Bid).filter(
        models.Bid.driver_id == current_user.id
    )
    
    if status:
        query = query.filter(models.Bid.status == status)
    
    bids = query.order_by(models.Bid.created_at.desc())\
               .offset(pagination.skip)\
               .limit(pagination.limit)\
               .all()
    
    return bids

@router.get("/{bid_id}", response_model=schemas.BidResponse)
async def get_bid(
    bid_id: int,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ ÑÑ‚Ğ°Ğ²ĞºĞµ
    """
    bid = crud.get_bid(db, bid_id)
    if not bid:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    has_access = False
    
    if current_user.role == models.UserRole.ADMIN:
        has_access = True
    elif current_user.role == models.UserRole.CLIENT and bid.order.client_id == current_user.id:
        has_access = True
    elif current_user.role == models.UserRole.DRIVER and bid.driver_id == current_user.id:
        has_access = True
    
    if not has_access:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº ÑÑ‚Ğ°Ğ²ĞºĞµ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    return bid

@router.post("/{bid_id}/accept", response_model=schemas.BidResponse)
async def accept_bid(
    bid_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_client_or_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğµ ÑÑ‚Ğ°Ğ²ĞºĞ¸ (Ğ´Ğ»Ñ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ° Ğ¸Ğ»Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°)
    """
    bid = crud.get_bid(db, bid_id)
    if not bid:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°"
        )
    
    order = crud.get_order(db, bid.order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ† Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ ÑÑ‚Ğ°Ğ²ĞºĞ¸"
        )
    
    if bid.status != models.BidStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚ÑŒ ÑÑ‚Ñƒ ÑÑ‚Ğ°Ğ²ĞºÑƒ"
        )
    
    if order.status != models.OrderStatus.SEARCHING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ ÑÑ‚Ğ°Ğ²Ğ¾Ğº"
        )
    
    try:
        # ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ğ²ĞºÑƒ
        accepted_bid = crud.accept_bid(db, bid_id)
        
        if not accepted_bid:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸ ÑÑ‚Ğ°Ğ²ĞºĞ¸"
            )
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸ ÑÑ‚Ğ°Ğ²ĞºĞ¸
        background_tasks.add_task(
            notification_service.notify_bid_accepted,
            db,
            bid_id
        )
        
        logger.info(f"Bid accepted: ID {bid_id} for order {order.id}")
        
        return accepted_bid
        
    except Exception as e:
        logger.error(f"Error accepting bid: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸ ÑÑ‚Ğ°Ğ²ĞºĞ¸: {str(e)}"
        )

@router.post("/{bid_id}/reject")
async def reject_bid(
    bid_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_client_or_admin),
    db: Session = Depends(get_db)
):
    """
    ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ğ²ĞºĞ¸ (Ğ´Ğ»Ñ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ° Ğ¸Ğ»Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°)
    """
    bid = crud.get_bid(db, bid_id)
    if not bid:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°"
        )
    
    order = crud.get_order(db, bid.order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ† Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ÑÑ‚ÑŒ ÑÑ‚Ğ°Ğ²ĞºĞ¸"
        )
    
    if bid.status != models.BidStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ñƒ ÑÑ‚Ğ°Ğ²ĞºÑƒ"
        )
    
    # ĞÑ‚ĞºĞ»Ğ¾Ğ½ÑĞµĞ¼ ÑÑ‚Ğ°Ğ²ĞºÑƒ
    rejected_bid = crud.reject_bid(db, bid_id)
    
    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸ ÑÑ‚Ğ°Ğ²ĞºĞ¸
    background_tasks.add_task(
        notify_driver_about_bid_rejection,
        db,
        bid_id
    )
    
    logger.info(f"Bid rejected: ID {bid_id} by user {current_user.email}")
    
    return {"message": "Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ°", "bid": rejected_bid}

@router.post("/{bid_id}/cancel")
async def cancel_bid(
    bid_id: int,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    ĞÑ‚Ğ¼ĞµĞ½Ğ° ÑÑ‚Ğ°Ğ²ĞºĞ¸ (Ğ´Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ)
    """
    bid = crud.get_bid(db, bid_id)
    if not bid:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°"
        )
    
    if bid.driver_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ²Ñ‚Ğ¾Ñ€ ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ĞµĞµ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ"
        )
    
    if bid.status != models.BidStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ñƒ ÑÑ‚Ğ°Ğ²ĞºÑƒ"
        )
    
    # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ ÑÑ‚Ğ°Ğ²ĞºÑƒ
    bid.status = models.BidStatus.CANCELLED
    db.commit()
    db.refresh(bid)
    
    logger.info(f"Bid cancelled: ID {bid_id} by driver {current_user.email}")
    
    return {"message": "Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°", "bid": bid}

@router.get("/stats/my")
async def get_my_bids_stats(
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ¿Ğ¾ ÑÑ‚Ğ°Ğ²ĞºĞ°Ğ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    bids = crud.get_bids_by_driver(db, current_user.id)
    
    total_bids = len(bids)
    accepted_bids = len([b for b in bids if b.status == models.BidStatus.ACCEPTED])
    pending_bids = len([b for b in bids if b.status == models.BidStatus.PENDING])
    rejected_bids = len([b for b in bids if b.status == models.BidStatus.REJECTED])
    
    # Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ÑÑ‚ÑŒ ÑÑ‚Ğ°Ğ²Ğ¾Ğº
    success_rate = (accepted_bids / total_bids * 100) if total_bids > 0 else 0
    
    # Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ°Ñ Ñ†ĞµĞ½Ğ°
    accepted_prices = [b.proposed_price for b in bids if b.status == models.BidStatus.ACCEPTED]
    avg_accepted_price = sum(accepted_prices) / len(accepted_prices) if accepted_prices else 0
    
    stats = {
        "total_bids": total_bids,
        "accepted_bids": accepted_bids,
        "pending_bids": pending_bids,
        "rejected_bids": rejected_bids,
        "success_rate": round(success_rate, 2),
        "avg_accepted_price": round(avg_accepted_price, 2),
        "total_earnings": sum(accepted_prices) if accepted_prices else 0
    }
    
    return stats

@router.get("/order/{order_id}/best")
async def get_best_bids(
    order_id: int,
    limit: int = Query(5, ge=1, le=20, description="ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ»ÑƒÑ‡ÑˆĞ¸Ñ… ÑÑ‚Ğ°Ğ²Ğ¾Ğº"),
    current_user: schemas.UserResponse = Depends(get_current_client_or_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ»ÑƒÑ‡ÑˆĞ¸Ñ… ÑÑ‚Ğ°Ğ²Ğ¾Ğº Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ° (Ğ¿Ğ¾ Ñ†ĞµĞ½Ğµ Ğ¸ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ñƒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ)
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº ÑÑ‚Ğ°Ğ²ĞºĞ°Ğ¼ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    bids = crud.get_bids_by_order(db, order_id)
    
    if not bids:
        return {"bids": [], "count": 0}
    
    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ pending ÑÑ‚Ğ°Ğ²ĞºĞ¸
    pending_bids = [b for b in bids if b.status == models.BidStatus.PENDING]
    
    if not pending_bids:
        return {"bids": [], "count": 0}
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑÑ…
    best_bids = []
    for bid in pending_bids:
        driver_profile = crud.get_driver_profile(db, bid.driver_id)
        if driver_profile:
            # Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞºĞ¾Ñ€Ğ¸Ğ½Ğ³ ÑÑ‚Ğ°Ğ²ĞºĞ¸ (Ğ½Ğ¸Ğ¶Ğµ Ñ†ĞµĞ½Ğ° + Ğ²Ñ‹ÑˆĞµ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ = Ğ»ÑƒÑ‡ÑˆĞµ)
            price_score = 1 / bid.proposed_price  # Ğ§ĞµĞ¼ Ğ½Ğ¸Ğ¶Ğµ Ñ†ĞµĞ½Ğ°, Ñ‚ĞµĞ¼ Ğ²Ñ‹ÑˆĞµ ÑĞºĞ¾Ñ€Ğ¸Ğ½Ğ³
            rating_score = driver_profile.rating / 5.0  # ĞĞ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³
            
            # ĞšĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ÑĞºĞ¾Ñ€Ğ¸Ğ½Ğ³ (70% Ñ†ĞµĞ½Ğ°, 30% Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³)
            total_score = price_score * 0.7 + rating_score * 0.3
            
            best_bids.append({
                "bid": schemas.BidResponse.model_validate(bid),
                "driver_rating": driver_profile.rating,
                "driver_total_orders": driver_profile.total_orders,
                "driver_verification_status": driver_profile.verification_status.value,
                "score": total_score
            })
    
    # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ ÑĞºĞ¾Ñ€Ğ¸Ğ½Ğ³Ñƒ
    best_bids.sort(key=lambda x: x["score"], reverse=True)
    
    # ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾
    best_bids = best_bids[:limit]
    
    return {
        "bids": best_bids,
        "count": len(best_bids),
        "order_price": order.desired_price,
        "cheapest_bid": min([b["bid"].proposed_price for b in best_bids]) if best_bids else None,
        "avg_bid": sum([b["bid"].proposed_price for b in best_bids]) / len(best_bids) if best_bids else None
    }

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
async def notify_client_about_new_bid(db: Session, order_id: int, bid_id: int):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ° Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ÑÑ‚Ğ°Ğ²ĞºĞµ"""
    try:
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        bid = crud.get_bid(db, bid_id)
        if not bid:
            return
        
        await notification_service.send_notification(
            db,
            order.client_id,
            "new_bid_received",
            {
                "order_id": order_id,
                "order_number": order.order_number,
                "bid_id": bid_id,
                "driver_id": bid.driver_id,
                "proposed_price": bid.proposed_price,
                "driver_name": bid.driver.full_name if bid.driver else None
            }
        )
    except Exception as e:
        logger.error(f"Error notifying client about new bid: {e}")

async def notify_driver_about_bid_rejection(db: Session, bid_id: int):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸ ÑÑ‚Ğ°Ğ²ĞºĞ¸"""
    try:
        bid = crud.get_bid(db, bid_id)
        if not bid or not bid.driver_id:
            return
        
        await notification_service.send_notification(
            db,
            bid.driver_id,
            "bid_rejected",
            {
                "bid_id": bid_id,
                "order_id": bid.order_id,
                "proposed_price": bid.proposed_price
            }
        )
    except Exception as e:
        logger.error(f"Error notifying driver about bid rejection: {e}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\chat.py                                                     â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\chat.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ñ‡Ğ°Ñ‚Ğ° (WebSocket)
"""
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, HTTPException, status
from sqlalchemy.orm import Session
import json
import logging
from datetime import datetime
from typing import Annotated
from .. import crud, schemas, models
from ..auth import verify_token, get_current_user
from ..database import get_db
from ..websocket_manager import manager
from ..notifications import notification_service

router = APIRouter()
logger = logging.getLogger(__name__)

@router.websocket("/ws/chat/{order_id}")
async def websocket_chat_endpoint(
    websocket: WebSocket,
    order_id: int,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint Ğ´Ğ»Ñ Ñ‡Ğ°Ñ‚Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    """
    # Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ñ‚Ğ¾ĞºĞµĞ½Ğ°
    payload = verify_token(token)
    if not payload:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    user_id = payload.get("user_id")
    if not user_id:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    user = crud.get_user_by_id(db, user_id)
    order = crud.get_order(db, order_id)
    
    if not user or not user.is_active:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    if not order:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Order not found")
        return
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº Ñ‡Ğ°Ñ‚Ñƒ
    is_authorized = (
        user.id == order.client_id or 
        user.id == order.driver_id or
        user.role == models.UserRole.ADMIN
    )
    
    if not is_authorized:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Not authorized")
        return
    
    # ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº Ñ‡Ğ°Ñ‚Ñƒ
    await manager.connect_chat(websocket, order_id, user_id)
    
    try:
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
        messages = crud.get_messages_by_order(db, order_id, limit=50)
        for message in reversed(messages):  # ĞÑ‚ ÑÑ‚Ğ°Ñ€Ñ‹Ñ… Ğº Ğ½Ğ¾Ğ²Ñ‹Ğ¼
            await websocket.send_json({
                "type": "chat_history",
                "data": {
                    "id": message.id,
                    "order_id": message.order_id,
                    "sender_id": message.sender_id,
                    "sender_email": message.sender.email,
                    "sender_name": message.sender.full_name,
                    "sender_role": message.sender.role.value,
                    "content": message.content,
                    "is_read": message.is_read,
                    "timestamp": message.timestamp.isoformat()
                }
            })
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¸
        await manager.broadcast_chat_message(order_id, {
            "type": "user_connected",
            "data": {
                "user_id": user_id,
                "user_email": user.email,
                "user_name": user.full_name,
                "user_role": user.role.value,
                "timestamp": datetime.utcnow().isoformat()
            }
        }, exclude_user_id=user_id)
        
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ» Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
        while True:
            # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¾Ñ‚ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¸Ğ¿Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
            if message_data.get("type") != "chat_message":
                continue
            
            content = message_data.get("content", "").strip()
            if not content:
                continue
            
            # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ² Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            message_create = schemas.MessageCreate(content=content)
            message = crud.create_message(db, message_create, order_id, user_id)
            
            # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ‚Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ğ¸
            broadcast_message = {
                "type": "chat_message",
                "data": {
                    "id": message.id,
                    "order_id": message.order_id,
                    "sender_id": message.sender_id,
                    "sender_email": user.email,
                    "sender_name": user.full_name,
                    "sender_role": user.role.value,
                    "content": message.content,
                    "is_read": message.is_read,
                    "timestamp": message.timestamp.isoformat()
                }
            }
            
            # Ğ¢Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ²ÑĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼ Ñ‡Ğ°Ñ‚Ğ°
            await manager.broadcast_chat_message(order_id, broadcast_message)
            
            # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼ Ñ‡Ğ°Ñ‚Ğ°
            other_user_id = order.client_id if user_id != order.client_id else (order.driver_id or 0)
            if other_user_id:
                try:
                    await notification_service.send_notification(
                        db,
                        other_user_id,
                        "chat_message",
                        {
                            "order_id": order_id,
                            "order_number": order.order_number,
                            "sender_id": user_id,
                            "sender_name": user.full_name,
                            "message": content[:100] + ("..." if len(content) > 100 else "")
                        }
                    )
                except Exception as e:
                    logger.error(f"Error sending chat notification: {e}")
            
            logger.info(f"Chat message sent: order {order_id}, user {user.email}")
            
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected: order {order_id}, user {user.email}")
        manager.disconnect_chat(websocket, order_id, user_id)
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¸
        try:
            await manager.broadcast_chat_message(order_id, {
                "type": "user_disconnected",
                "data": {
                    "user_id": user_id,
                    "user_email": user.email,
                    "user_name": user.full_name,
                    "user_role": user.role.value,
                    "timestamp": datetime.utcnow().isoformat()
                }
            }, exclude_user_id=user_id)
        except:
            pass
            
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        manager.disconnect_chat(websocket, order_id, user_id)
        try:
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        except:
            pass

@router.get("/chat/{order_id}/messages", response_model=list[schemas.MessageResponse])
async def get_chat_messages(
    order_id: int,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 100
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ñ‡Ğ°Ñ‚Ğ° (HTTP endpoint)
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    is_authorized = (
        current_user.id == order.client_id or 
        current_user.id == order.driver_id or
        current_user.role == models.UserRole.ADMIN
    )
    
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ñ‡Ğ°Ñ‚Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
    messages = crud.get_messages_by_order(db, order_id, skip, limit)
    
    # ĞŸĞ¾Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğµ
    if messages:
        crud.mark_messages_as_read(db, order_id, current_user.id)
    
    return messages

@router.post("/chat/{order_id}/mark-read")
async def mark_chat_as_read(
    order_id: int,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ¼ĞµÑ‚ĞºĞ° Ğ²ÑĞµÑ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ñ‡Ğ°Ñ‚Ğ° ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ñ…
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    is_authorized = (
        current_user.id == order.client_id or 
        current_user.id == order.driver_id or
        current_user.role == models.UserRole.ADMIN
    )
    
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ñ‡Ğ°Ñ‚Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    # ĞŸĞ¾Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğµ
    updated_count = crud.mark_messages_as_read(db, order_id, current_user.id)
    
    return {"message": f"ĞÑ‚Ğ¼ĞµÑ‡ĞµĞ½Ğ¾ {updated_count} ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğµ"}

@router.get("/chat/unread-count")
async def get_unread_chat_count(
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ½ĞµĞ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
    """
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    if current_user.role == models.UserRole.CLIENT:
        orders = crud.get_orders(db, client_id=current_user.id)
    elif current_user.role == models.UserRole.DRIVER:
        orders = crud.get_orders(db, driver_id=current_user.id)
    else:  # Admin
        orders = []
    
    total_unread = 0
    orders_with_unread = []
    
    for order in orders:
        unread_count = db.query(models.Message).filter(
            models.Message.order_id == order.id,
            models.Message.sender_id != current_user.id,
            models.Message.is_read == False
        ).count()
        
        if unread_count > 0:
            total_unread += unread_count
            orders_with_unread.append({
                "order_id": order.id,
                "order_number": order.order_number,
                "unread_count": unread_count,
                "last_message": db.query(models.Message)
                    .filter(models.Message.order_id == order.id)
                    .order_by(models.Message.timestamp.desc())
                    .first()
            })
    
    return {
        "total_unread": total_unread,
        "orders_with_unread": orders_with_unread,
        "user_id": current_user.id
    }

@router.websocket("/ws/notifications")
async def websocket_notifications_endpoint(
    websocket: WebSocket,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
    """
    # Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ñ‚Ğ¾ĞºĞµĞ½Ğ°
    payload = verify_token(token)
    if not payload:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    user_id = payload.get("user_id")
    if not user_id:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user = crud.get_user_by_id(db, user_id)
    if not user or not user.is_active:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    await manager.connect_user(websocket, user_id)
    
    try:
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½ĞµĞ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
        notifications = db.query(models.Notification).filter(
            models.Notification.user_id == user_id,
            models.Notification.is_read == False
        ).order_by(models.Notification.created_at.desc()).limit(20).all()
        
        for notification in notifications:
            await websocket.send_json({
                "type": "notification",
                "data": {
                    "id": notification.id,
                    "title": notification.title,
                    "message": notification.message,
                    "type": notification.type,
                    "data": notification.data,
                    "is_read": notification.is_read,
                    "created_at": notification.created_at.isoformat()
                }
            })
        
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ» (Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ğ½Ğ¸Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ)
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ Ğ¾Ñ‚ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
            if message_data.get("type") == "mark_as_read":
                notification_id = message_data.get("notification_id")
                if notification_id:
                    notification = db.query(models.Notification).filter(
                        models.Notification.id == notification_id,
                        models.Notification.user_id == user_id
                    ).first()
                    
                    if notification:
                        notification.is_read = True
                        db.commit()
                        
                        await websocket.send_json({
                            "type": "notification_marked_read",
                            "data": {"notification_id": notification_id}
                        })
            
            elif message_data.get("type") == "mark_all_as_read":
                db.query(models.Notification).filter(
                    models.Notification.user_id == user_id,
                    models.Notification.is_read == False
                ).update({"is_read": True})
                db.commit()
                
                await websocket.send_json({
                    "type": "all_notifications_marked_read",
                    "data": {"user_id": user_id}
                })
            
    except WebSocketDisconnect:
        logger.info(f"Notification WebSocket disconnected: user {user.email}")
        manager.disconnect_user(websocket, user_id)
        
    except Exception as e:
        logger.error(f"Notification WebSocket error: {e}")
        manager.disconnect_user(websocket, user_id)
        try:
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        except:
            pass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\drivers.py                                                  â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\drivers.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑĞ¼Ğ¸
"""
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Query, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
import logging

from .. import schemas, crud, models
from ..auth import get_current_active_user, get_current_driver, get_current_admin, get_current_driver_or_admin
from ..database import get_db
from ..dependencies import PaginationParams
from ..file_storage import file_storage
from ..notifications import notification_service

router = APIRouter(prefix="/api/drivers", tags=["drivers"])
logger = logging.getLogger(__name__)

@router.post("/profile", response_model=schemas.DriverProfileResponse)
async def create_driver_profile(
    profile: schemas.DriverProfileCreate,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ
    existing_profile = crud.get_driver_profile(db, current_user.id)
    if existing_profile:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚"
        )
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ
    created_profile = crud.create_driver_profile(db, profile, current_user.id)
    
    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼
    admins = crud.get_users(db, role="admin", is_active=True)
    for admin in admins:
        await notification_service.send_notification(
            db,
            admin.id,
            "verification_required",
            {"driver_id": current_user.id, "driver_name": current_user.full_name}
        )
    
    logger.info(f"Driver profile created for user: {current_user.email}")
    
    return created_profile

@router.get("/profile", response_model=schemas.DriverProfileResponse)
async def get_my_driver_profile(
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    return profile

@router.put("/profile", response_model=schemas.DriverProfileResponse)
async def update_driver_profile(
    profile_update: schemas.DriverProfileUpdate,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    profile = crud.update_driver_profile(db, current_user.id, profile_update)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    logger.info(f"Driver profile updated for user: {current_user.email}")
    
    return profile

@router.post("/profile/online")
async def set_driver_online(
    lat: float = Query(..., ge=-90, le=90, description="Ğ¨Ğ¸Ñ€Ğ¾Ñ‚Ğ°"),
    lng: float = Query(..., ge=-180, le=180, description="Ğ”Ğ¾Ğ»Ğ³Ğ¾Ñ‚Ğ°"),
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° "Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½" Ğ´Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    profile = crud.update_driver_location(db, current_user.id, lat, lng)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    profile.is_online = True
    db.commit()
    db.refresh(profile)
    
    logger.info(f"Driver set online: {current_user.email} at ({lat}, {lng})")
    
    return {"message": "Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ² ÑĞµÑ‚Ğ¸", "location": {"lat": lat, "lng": lng}}

@router.post("/profile/offline")
async def set_driver_offline(
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° "Ğ¾Ñ„Ğ»Ğ°Ğ¹Ğ½" Ğ´Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    profile.is_online = False
    db.commit()
    db.refresh(profile)
    
    logger.info(f"Driver set offline: {current_user.email}")
    
    return {"message": "Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ² ÑĞµÑ‚Ğ¸"}

@router.get("/nearby")
async def get_nearby_drivers(
    lat: float = Query(..., ge=-90, le=90, description="Ğ¨Ğ¸Ñ€Ğ¾Ñ‚Ğ°"),
    lng: float = Query(..., ge=-180, le=180, description="Ğ”Ğ¾Ğ»Ğ³Ğ¾Ñ‚Ğ°"),
    radius_km: float = Query(50, ge=1, le=500, description="Ğ Ğ°Ğ´Ğ¸ÑƒÑ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ² ĞºĞ¼"),
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ¸ÑĞº Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ Ğ¿Ğ¾Ğ±Ğ»Ğ¸Ğ·Ğ¾ÑÑ‚Ğ¸ (ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ)
    """
    # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ğ³ĞµĞ¾Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸
    # Ğ”Ğ»Ñ ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹
    
    drivers = crud.get_driver_profiles(db, is_online=True, limit=20)
    
    # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ (ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ¾)
    nearby_drivers = []
    for driver in drivers:
        if driver.current_location_lat and driver.current_location_lng:
            distance = crud.utils.calculate_distance(
                lat, lng,
                driver.current_location_lat, driver.current_location_lng
            )
            if distance <= radius_km:
                nearby_drivers.append({
                    "driver": schemas.DriverProfileResponse.model_validate(driver),
                    "distance_km": round(distance, 2),
                    "user": schemas.UserResponse.model_validate(driver.user)
                })
    
    return {"drivers": nearby_drivers, "count": len(nearby_drivers)}

@router.get("/", response_model=List[schemas.DriverWithProfile])
async def get_drivers(
    pagination: PaginationParams = Depends(),
    verification_status: Optional[str] = Query(None, description="Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸"),
    is_online: Optional[bool] = Query(None, description="Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    profiles = crud.get_driver_profiles(
        db,
        skip=pagination.skip,
        limit=pagination.limit,
        verification_status=verification_status,
        is_online=is_online
    )
    
    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸ĞµĞ¹ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ
    result = []
    for profile in profiles:
        result.append({
            "user": schemas.UserResponse.model_validate(profile.user),
            "profile": schemas.DriverProfileResponse.model_validate(profile)
        })
    
    return result

@router.get("/{driver_id}/profile", response_model=schemas.DriverWithProfile)
async def get_driver_profile_by_id(
    driver_id: int,
    current_user: schemas.UserResponse = Depends(get_current_driver_or_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ ID
    """
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == "driver" and current_user.id != driver_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    return {
        "user": schemas.UserResponse.model_validate(profile.user),
        "profile": schemas.DriverProfileResponse.model_validate(profile)
    }

@router.post("/upload-document")
async def upload_document(
    document_type: str = Query(..., description="Ğ¢Ğ¸Ğ¿ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°: license, passport, vehicle_registration, insurance"),
    file: UploadFile = File(...),
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¸Ğ¿Ğ° Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°
    allowed_types = ["license", "passport", "vehicle_registration", "insurance"]
    if document_type not in allowed_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"ĞĞµĞ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°. Ğ”Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğµ: {', '.join(allowed_types)}"
        )
    
    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ°
    try:
        file_path = await file_storage.save_driver_document(file, current_user.id, document_type)
        
        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
        profile = crud.get_driver_profile(db, current_user.id)
        if profile:
            if document_type == "license":
                profile.license_path = file_path
            elif document_type == "passport":
                profile.passport_path = file_path
            elif document_type == "vehicle_registration":
                profile.vehicle_registration_path = file_path
            elif document_type == "insurance":
                profile.insurance_path = file_path
            
            db.commit()
        
        logger.info(f"Document uploaded: {document_type} for user: {current_user.email}")
        
        return {
            "message": "Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½",
            "document_type": document_type,
            "file_path": file_path,
            "filename": file.filename
        }
        
    except Exception as e:
        logger.error(f"Error uploading document: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°: {str(e)}"
        )

@router.get("/stats/{driver_id}")
async def get_driver_stats(
    driver_id: int,
    current_user: schemas.UserResponse = Depends(get_current_driver_or_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == "driver" and current_user.id != driver_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    orders = crud.get_orders(db, driver_id=driver_id)
    
    # Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ
    completed_orders = [o for o in orders if o.status == models.OrderStatus.COMPLETED]
    cancelled_orders = [o for o in orders if o.status == models.OrderStatus.CANCELLED]
    active_orders = [o for o in orders if o.status in [
        models.OrderStatus.DRIVER_ASSIGNED,
        models.OrderStatus.LOADING,
        models.OrderStatus.EN_ROUTE,
        models.OrderStatus.UNLOADING
    ]]
    
    total_earnings = sum(o.order_amount or 0 for o in completed_orders)
    avg_rating = profile.rating
    acceptance_rate = len(completed_orders) / max(len(orders), 1) * 100
    
    stats = {
        "total_orders": len(orders),
        "completed_orders": len(completed_orders),
        "cancelled_orders": len(cancelled_orders),
        "active_orders": len(active_orders),
        "total_earnings": total_earnings,
        "average_rating": avg_rating,
        "acceptance_rate": round(acceptance_rate, 2),
        "total_distance": profile.total_distance,
        "verification_status": profile.verification_status.value
    }
    
    return stats

@router.post("/search")
async def search_drivers(
    query: str = Query(..., description="ĞŸĞ¾Ğ¸ÑĞºĞ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ (Ğ¸Ğ¼Ñ, email, Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½, Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ¼Ğ°ÑˆĞ¸Ğ½Ñ‹)"),
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ¸ÑĞº Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    profiles = db.query(crud.models.DriverProfile).join(crud.models.User).filter(
        (crud.models.User.email.ilike(f"%{query}%")) |
        (crud.models.User.phone.ilike(f"%{query}%")) |
        (crud.models.User.full_name.ilike(f"%{query}%")) |
        (crud.models.DriverProfile.vehicle_number.ilike(f"%{query}%")) |
        (crud.models.DriverProfile.vehicle_model.ilike(f"%{query}%"))
    ).order_by(crud.models.DriverProfile.created_at.desc())\
     .offset(pagination.skip)\
     .limit(pagination.limit)\
     .all()
    
    result = []
    for profile in profiles:
        result.append({
            "user": schemas.UserResponse.model_validate(profile.user),
            "profile": schemas.DriverProfileResponse.model_validate(profile)
        })
    
    return result
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\health.py                                                   â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\health.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹
"""
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
import logging
from datetime import datetime
import psutil
import os
import sys

from ..database import get_db
from .. import crud

router = APIRouter(tags=["health"])
logger = logging.getLogger(__name__)

@router.get("/health")
async def health_check():
    """
    Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ API
    """
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "service": "CargoPro Backend",
        "version": "1.0.0"
    }

@router.get("/health/detailed")
async def detailed_health_check(db: Session = Depends(get_db)):
    """
    Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹
    """
    checks = {
        "api": {"status": "healthy", "message": "API Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½"},
        "database": {"status": "unknown", "message": "ĞĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ¾"},
        "memory": {"status": "unknown", "message": "ĞĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ¾"},
        "disk": {"status": "unknown", "message": "ĞĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ¾"}
    }
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    try:
        db.execute("SELECT 1")
        checks["database"]["status"] = "healthy"
        checks["database"]["message"] = "Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°"
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ† (Ğ´Ğ»Ñ SQLite)
        try:
            result = db.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()
            table_count = len(result)
            checks["database"]["tables"] = table_count
        except:
            checks["database"]["tables"] = "unknown"
        
    except Exception as e:
        checks["database"]["status"] = "unhealthy"
        checks["database"]["message"] = f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {str(e)}"
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
    try:
        memory = psutil.virtual_memory()
        checks["memory"]["status"] = "healthy" if memory.percent < 90 else "warning"
        checks["memory"]["message"] = f"Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¾ {memory.percent}% Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸"
        checks["memory"]["details"] = {
            "total_gb": round(memory.total / (1024**3), 2),
            "available_gb": round(memory.available / (1024**3), 2),
            "percent_used": memory.percent
        }
    except Exception as e:
        checks["memory"]["status"] = "unhealthy"
        checks["memory"]["message"] = f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸: {str(e)}"
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ¸ÑĞºĞ°
    try:
        disk = psutil.disk_usage('/')
        checks["disk"]["status"] = "healthy" if disk.percent < 90 else "warning"
        checks["disk"]["message"] = f"Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¾ {disk.percent}% Ğ´Ğ¸ÑĞºĞ°"
        checks["disk"]["details"] = {
            "total_gb": round(disk.total / (1024**3), 2),
            "free_gb": round(disk.free / (1024**3), 2),
            "percent_used": disk.percent
        }
    except Exception as e:
        checks["disk"]["status"] = "unhealthy"
        checks["disk"]["message"] = f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ´Ğ¸ÑĞºĞ°: {str(e)}"
    
    # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ±Ñ‰ĞµĞ³Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
    all_healthy = all(check["status"] in ["healthy", "warning"] for check in checks.values())
    overall_status = "healthy" if all_healthy else "unhealthy"
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ĞµÑÑ‚ÑŒ Ğ»Ğ¸ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ñ
    has_warnings = any(check["status"] == "warning" for check in checks.values())
    
    return {
        "status": overall_status,
        "has_warnings": has_warnings,
        "timestamp": datetime.utcnow().isoformat(),
        "checks": checks,
        "system_info": {
            "python_version": sys.version,
            "platform": sys.platform,
            "cpu_count": psutil.cpu_count() if hasattr(psutil, 'cpu_count') else "unknown"
        }
    }

@router.get("/health/database")
async def database_health_check(db: Session = Depends(get_db)):
    """
    ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    """
    try:
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ
        db.execute("SELECT 1")
        
        # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
        stats = {
            "connection": "ok",
            "tables": {},
            "statistics": {}
        }
        
        # ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹ Ğ² Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°Ñ…
        tables = ["users", "orders", "bids", "messages", "payments"]
        for table in tables:
            try:
                count = db.execute(f"SELECT COUNT(*) FROM {table}").scalar()
                stats["tables"][table] = count
            except:
                stats["tables"][table] = "error"
        
        # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
        try:
            user_stats = crud.get_system_stats(db)
            stats["statistics"]["users"] = user_stats
        except:
            stats["statistics"]["users"] = "error"
        
        return {
            "status": "healthy",
            "database": "connected",
            "details": stats,
            "timestamp": datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        return {
            "status": "unhealthy",
            "database": "disconnected",
            "error": str(e),
            "timestamp": datetime.utcnow().isoformat()
        }

@router.get("/health/endpoints")
async def endpoints_health_check():
    """
    ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ñ… ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ğ¾Ğ²
    """
    endpoints = [
        {"name": "API Documentation", "path": "/api/docs", "method": "GET"},
        {"name": "Authentication", "path": "/api/auth/login", "method": "POST"},
        {"name": "User Profile", "path": "/api/users/me", "method": "GET"},
        {"name": "Orders List", "path": "/api/orders", "method": "GET"},
        {"name": "Admin Statistics", "path": "/api/admin/stats", "method": "GET"}
    ]
    
    return {
        "status": "healthy",
        "endpoints": endpoints,
        "timestamp": datetime.utcnow().isoformat(),
        "note": "Ğ­Ñ‚Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿ĞµÑ€ĞµÑ‡Ğ¸ÑĞ»ÑĞµÑ‚ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ñ‹. Ğ”Ğ»Ñ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ½ÑƒĞ¶Ğ½Ñ‹ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹."
    }

@router.get("/metrics")
async def system_metrics():
    """
    ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ¸ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ°
    """
    try:
        # Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸
        cpu_percent = psutil.cpu_percent(interval=0.1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        # Ğ¡ĞµÑ‚ĞµĞ²Ñ‹Ğµ Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸
        net_io = psutil.net_io_counters()
        
        # ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ¸ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ°
        process = psutil.Process()
        process_memory = process.memory_info()
        
        metrics = {
            "timestamp": datetime.utcnow().isoformat(),
            "system": {
                "cpu": {
                    "percent": cpu_percent,
                    "cores": psutil.cpu_count(),
                    "cores_logical": psutil.cpu_count(logical=True)
                },
                "memory": {
                    "total_bytes": memory.total,
                    "available_bytes": memory.available,
                    "used_bytes": memory.used,
                    "percent": memory.percent
                },
                "disk": {
                    "total_bytes": disk.total,
                    "free_bytes": disk.free,
                    "used_bytes": disk.used,
                    "percent": disk.percent
                },
                "network": {
                    "bytes_sent": net_io.bytes_sent,
                    "bytes_recv": net_io.bytes_recv,
                    "packets_sent": net_io.packets_sent,
                    "packets_recv": net_io.packets_recv
                }
            },
            "process": {
                "pid": process.pid,
                "name": process.name(),
                "memory_rss_bytes": process_memory.rss,
                "memory_vms_bytes": process_memory.vms,
                "cpu_percent": process.cpu_percent(),
                "threads": process.num_threads()
            }
        }
        
        return metrics
    except Exception as e:
        return {
            "timestamp": datetime.utcnow().isoformat(),
            "error": str(e),
            "status": "partial"
        }

@router.get("/version")
async def version_info():
    """
    Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ²ĞµÑ€ÑĞ¸Ğ¸ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    """
    return {
        "service": "CargoPro Backend",
        "version": "1.0.0",
        "environment": os.getenv("ENVIRONMENT", "development"),
        "build_date": "2024-01-01",
        "api_version": "v1",
        "features": [
            "authentication",
            "order_management",
            "driver_tracking",
            "real_time_chat",
            "payment_processing",
            "admin_panel"
        ]
    }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\integration.py                                              â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\integration.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ğ¼Ğ¸ ÑĞµÑ€Ğ²Ğ¸ÑĞ°Ğ¼Ğ¸
"""
from fastapi import APIRouter, Depends, HTTPException, status, Header, Query
from sqlalchemy.orm import Session
from typing import Optional
import logging

from .. import schemas, crud, models
from ..auth import get_current_active_user, get_current_admin
from ..database import get_db
from ..dependencies import verify_api_key
from ..payment import payment_service

router = APIRouter(prefix="/api/integration", tags=["integration"])
logger = logging.getLogger(__name__)

# ĞŸÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸
@router.get("/public/order/{order_number}/status")
async def get_order_status_public(
    order_number: str,
    db: Session = Depends(get_db)
):
    """
    ĞŸÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¿Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€Ñƒ
    (Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ğ¼Ğ¸ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ğ¼Ğ¸)
    """
    order = crud.get_order_by_number(db, order_number)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ½ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    return {
        "order_number": order.order_number,
        "status": order.status.value,
        "from_address": order.from_address,
        "to_address": order.to_address,
        "cargo_type": order.cargo_type,
        "created_at": order.created_at.isoformat(),
        "updated_at": order.updated_at.isoformat() if order.updated_at else None,
        "estimated_delivery": order.delivery_date.isoformat() if order.delivery_date else None
    }

@router.get("/mobile/driver/{driver_id}/dashboard")
async def get_mobile_driver_dashboard(
    driver_id: int,
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """
    Ğ”Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´ Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    if api_key != "mobile_app_key":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid API key for this endpoint"
        )
    
    driver = crud.get_user_by_id(db, driver_id)
    if not driver or driver.role != models.UserRole.DRIVER:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    profile = crud.get_driver_profile(db, driver_id)
    if not profile:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
    active_orders = crud.get_orders(
        db,
        driver_id=driver_id,
        status=models.OrderStatus.DRIVER_ASSIGNED.value
    )
    
    # Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
    available_orders = crud.get_available_orders(db, driver_id=driver_id, limit=20)
    
    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    stats = {
        "total_orders": profile.total_orders,
        "total_distance": profile.total_distance,
        "rating": profile.rating,
        "balance": driver.balance,
        "is_online": profile.is_online,
        "verification_status": profile.verification_status.value
    }
    
    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
    notifications = db.query(models.Notification).filter(
        models.Notification.user_id == driver_id,
        models.Notification.is_read == False
    ).order_by(models.Notification.created_at.desc()).limit(10).all()
    
    return {
        "driver": {
            "id": driver.id,
            "name": driver.full_name,
            "email": driver.email,
            "phone": driver.phone,
            "vehicle": {
                "type": profile.vehicle_type,
                "model": profile.vehicle_model,
                "number": profile.vehicle_number,
                "capacity": profile.carrying_capacity,
                "volume": profile.volume
            }
        },
        "stats": stats,
        "active_orders": [
            {
                "id": order.id,
                "order_number": order.order_number,
                "from_address": order.from_address,
                "to_address": order.to_address,
                "status": order.status.value,
                "price": order.final_price or order.desired_price,
                "pickup_date": order.pickup_date.isoformat() if order.pickup_date else None
            }
            for order in active_orders
        ],
        "available_orders": [
            {
                "id": order.id,
                "order_number": order.order_number,
                "from_address": order.from_address,
                "to_address": order.to_address,
                "distance": order.distance_km,
                "price": order.desired_price,
                "cargo": {
                    "type": order.cargo_type,
                    "weight": order.cargo_weight,
                    "volume": order.cargo_volume,
                    "description": order.cargo_description
                },
                "created_at": order.created_at.isoformat()
            }
            for order in available_orders
        ],
        "notifications": [
            {
                "id": n.id,
                "title": n.title,
                "message": n.message,
                "type": n.type,
                "created_at": n.created_at.isoformat()
            }
            for n in notifications
        ]
    }

@router.get("/admin/dashboard")
async def get_admin_dashboard(
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """
    Ğ”Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸
    """
    if api_key != "admin_panel_key":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid API key for this endpoint"
        )
    
    stats = crud.get_system_stats(db)
    
    # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
    recent_orders = db.query(models.Order)\
        .order_by(models.Order.created_at.desc())\
        .limit(10)\
        .all()
    
    # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸
    recent_users = db.query(models.User)\
        .order_by(models.User.created_at.desc())\
        .limit(10)\
        .all()
    
    # ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
    pending_verifications = db.query(models.DriverProfile)\
        .filter(models.DriverProfile.verification_status == models.VerificationStatus.PENDING)\
        .order_by(models.DriverProfile.created_at.desc())\
        .limit(10)\
        .all()
    
    return {
        "stats": stats,
        "recent_orders": [
            {
                "id": order.id,
                "order_number": order.order_number,
                "client_email": order.client.email,
                "status": order.status.value,
                "price": order.final_price or order.desired_price,
                "created_at": order.created_at.isoformat()
            }
            for order in recent_orders
        ],
        "recent_users": [
            {
                "id": user.id,
                "email": user.email,
                "role": user.role.value,
                "created_at": user.created_at.isoformat()
            }
            for user in recent_users
        ],
        "pending_verifications": [
            {
                "driver_id": profile.user_id,
                "driver_email": profile.user.email,
                "vehicle_number": profile.vehicle_number,
                "created_at": profile.created_at.isoformat(),
                "documents": {
                    "license": bool(profile.license_path),
                    "passport": bool(profile.passport_path),
                    "registration": bool(profile.vehicle_registration_path)
                }
            }
            for profile in pending_verifications
        ]
    }

@router.get("/website/order-tracking/{order_number}")
async def get_website_order_tracking(
    order_number: str,
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """
    ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ´Ğ»Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ³Ğ¾ ÑĞ°Ğ¹Ñ‚Ğ°
    """
    if api_key != "website_key":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid API key for this endpoint"
        )
    
    order = crud.get_order_by_number(db, order_number)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğµ
    order_info = {
        "order_number": order.order_number,
        "status": order.status.value,
        "status_description": get_status_description(order.status),
        "from_address": order.from_address,
        "to_address": order.to_address,
        "cargo_type": order.cargo_type,
        "cargo_weight": order.cargo_weight,
        "cargo_volume": order.cargo_volume,
        "created_at": order.created_at.isoformat(),
        "pickup_date": order.pickup_date.isoformat() if order.pickup_date else None,
        "delivery_date": order.delivery_date.isoformat() if order.delivery_date else None,
        "distance": order.distance_km
    }
    
    # Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğµ (ĞµÑĞ»Ğ¸ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½)
    driver_info = None
    if order.driver_id:
        driver = crud.get_user_by_id(db, order.driver_id)
        driver_profile = crud.get_driver_profile(db, order.driver_id)
        
        if driver and driver_profile:
            driver_info = {
                "name": driver.full_name,
                "phone": driver.phone,
                "vehicle": {
                    "type": driver_profile.vehicle_type,
                    "model": driver_profile.vehicle_model,
                    "number": driver_profile.vehicle_number
                },
                "rating": driver_profile.rating,
                "total_orders": driver_profile.total_orders
            }
    
    # Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ)
    current_location = None
    if order.driver_id:
        location = db.query(models.LocationUpdate)\
            .filter(models.LocationUpdate.driver_id == order.driver_id)\
            .order_by(models.LocationUpdate.timestamp.desc())\
            .first()
        
        if location:
            current_location = {
                "lat": location.lat,
                "lng": location.lng,
                "timestamp": location.timestamp.isoformat(),
                "accuracy": location.accuracy
            }
    
    # Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¾Ğ²
    status_history = [
        {
            "status": "created",
            "timestamp": order.created_at.isoformat(),
            "description": "Ğ—Ğ°ĞºĞ°Ğ· ÑĞ¾Ğ·Ğ´Ğ°Ğ½"
        }
    ]
    
    if order.pickup_date:
        status_history.append({
            "status": "pickup_scheduled",
            "timestamp": order.pickup_date.isoformat(),
            "description": "Ğ—Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ¿Ğ¾Ğ³Ñ€ÑƒĞ·ĞºĞ°"
        })
    
    if order.delivery_date:
        status_history.append({
            "status": "delivery_scheduled",
            "timestamp": order.delivery_date.isoformat(),
            "description": "Ğ—Ğ°Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ°"
        })
    
    if order.completed_at:
        status_history.append({
            "status": "completed",
            "timestamp": order.completed_at.isoformat(),
            "description": "Ğ—Ğ°ĞºĞ°Ğ· Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½"
        })
    
    return {
        "order": order_info,
        "driver": driver_info,
        "current_location": current_location,
        "status_history": status_history,
        "estimated_progress": calculate_order_progress(order)
    }

@router.post("/payment/webhook")
async def payment_webhook(
    webhook_data: dict,
    x_webhook_signature: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """
    Ğ’ĞµĞ±Ñ…ÑƒĞº Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹ Ğ¾Ñ‚ Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ñ… Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ñ‹Ñ… ÑĞ¸ÑÑ‚ĞµĞ¼
    """
    # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸
    logger.info(f"Payment webhook received: {webhook_data}")
    
    try:
        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· Ğ²ĞµĞ±Ñ…ÑƒĞºĞ°
        payment_id = webhook_data.get("payment_id")
        status = webhook_data.get("status")
        metadata = webhook_data.get("metadata", {})
        
        if not payment_id or not status:
            return {"status": "error", "message": "Missing required fields"}
        
        # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²ĞµĞ±Ñ…ÑƒĞºĞ°
        success, message = await payment_service.process_payment_webhook(
            db, payment_id, status, metadata
        )
        
        if success:
            return {"status": "success", "message": message}
        else:
            return {"status": "error", "message": message}
            
    except Exception as e:
        logger.error(f"Error processing payment webhook: {e}")
        return {"status": "error", "message": str(e)}

@router.get("/payment/methods")
async def get_payment_methods_integration(
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸
    """
    methods = payment_service.get_supported_payment_methods()
    
    return {
        "methods": methods,
        "currency": "RUB",
        "platform_fee_percent": 5.0
    }

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
def get_status_description(status: models.OrderStatus) -> str:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    descriptions = {
        models.OrderStatus.DRAFT: "Ğ§ĞµÑ€Ğ½Ğ¾Ğ²Ğ¸Ğº",
        models.OrderStatus.SEARCHING: "ĞŸĞ¾Ğ¸ÑĞº Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ",
        models.OrderStatus.DRIVER_ASSIGNED: "Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½",
        models.OrderStatus.LOADING: "ĞŸĞ¾Ğ³Ñ€ÑƒĞ·ĞºĞ°",
        models.OrderStatus.EN_ROUTE: "Ğ’ Ğ¿ÑƒÑ‚Ğ¸",
        models.OrderStatus.UNLOADING: "Ğ Ğ°Ğ·Ğ³Ñ€ÑƒĞ·ĞºĞ°",
        models.OrderStatus.COMPLETED: "Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½",
        models.OrderStatus.CANCELLED: "ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½",
        models.OrderStatus.PAID: "ĞĞ¿Ğ»Ğ°Ñ‡ĞµĞ½"
    }
    return descriptions.get(status, "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ")

def calculate_order_progress(order: models.Order) -> float:
    """Ğ Ğ°ÑÑ‡ĞµÑ‚ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑĞ° Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    progress_map = {
        models.OrderStatus.DRAFT: 0,
        models.OrderStatus.SEARCHING: 10,
        models.OrderStatus.DRIVER_ASSIGNED: 30,
        models.OrderStatus.LOADING: 50,
        models.OrderStatus.EN_ROUTE: 75,
        models.OrderStatus.UNLOADING: 90,
        models.OrderStatus.COMPLETED: 100,
        models.OrderStatus.CANCELLED: 0,
        models.OrderStatus.PAID: 100
    }
    return progress_map.get(order.status, 0)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\orders.py                                                   â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\orders.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ğ¼Ğ¸
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query, UploadFile, File, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
import logging
from datetime import datetime

from .. import schemas, crud, models
from ..auth import get_current_active_user, get_current_client, get_current_admin, get_current_client_or_admin, get_current_driver
from ..database import get_db
from ..dependencies import PaginationParams, OrderFilterParams
from ..file_storage import file_storage
from ..notifications import notification_service
from ..payment import payment_service

router = APIRouter(prefix="/api/orders", tags=["orders"])
logger = logging.getLogger(__name__)

@router.post("/", response_model=schemas.OrderResponse)
async def create_order(
    order: schemas.OrderCreate,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_client),
    db: Session = Depends(get_db)
):
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    """
    try:
        created_order = crud.create_order(db, order, current_user.id)
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·Ğµ
        background_tasks.add_task(
            notify_admins_about_new_order,
            db,
            created_order.id
        )
        
        logger.info(f"Order created: {created_order.order_number} by user: {current_user.email}")
        
        return created_order
        
    except Exception as e:
        logger.error(f"Error creating order: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ°: {str(e)}"
        )

@router.get("/", response_model=List[schemas.OrderResponse])
async def get_my_orders(
    pagination: PaginationParams = Depends(),
    filters: OrderFilterParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    """
    if current_user.role == models.UserRole.CLIENT:
        orders = crud.get_orders(
            db,
            skip=pagination.skip,
            limit=pagination.limit,
            client_id=current_user.id,
            status=filters.status,
            min_price=filters.min_price,
            max_price=filters.max_price,
            cargo_type=filters.cargo_type
        )
    elif current_user.role == models.UserRole.DRIVER:
        orders = crud.get_orders(
            db,
            skip=pagination.skip,
            limit=pagination.limit,
            driver_id=current_user.id,
            status=filters.status,
            min_price=filters.min_price,
            max_price=filters.max_price,
            cargo_type=filters.cargo_type
        )
    else:  # Admin
        orders = crud.get_orders(
            db,
            skip=pagination.skip,
            limit=pagination.limit,
            status=filters.status,
            min_price=filters.min_price,
            max_price=filters.max_price,
            cargo_type=filters.cargo_type
        )
    
    return orders

@router.get("/available", response_model=List[schemas.OrderResponse])
async def get_available_orders(
    pagination: PaginationParams = Depends(),
    filters: OrderFilterParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² (Ğ´Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹)
    """
    if current_user.role != models.UserRole.DRIVER:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    profile = crud.get_driver_profile(db, current_user.id)
    if not profile or profile.verification_status != models.VerificationStatus.VERIFIED:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ½Ğµ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½"
        )
    
    orders = crud.get_available_orders(
        db,
        driver_id=current_user.id,
        skip=pagination.skip,
        limit=pagination.limit
    )
    
    # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹
    if filters.status:
        orders = [o for o in orders if o.status == filters.status]
    if filters.min_price:
        orders = [o for o in orders if o.desired_price >= filters.min_price]
    if filters.max_price:
        orders = [o for o in orders if o.desired_price <= filters.max_price]
    if filters.cargo_type:
        orders = [o for o in orders if o.cargo_type == filters.cargo_type]
    
    return orders

@router.get("/{order_id}", response_model=schemas.OrderWithRelations)
async def get_order(
    order_id: int,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğµ
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    has_access = False
    
    if current_user.role == models.UserRole.ADMIN:
        has_access = True
    elif current_user.role == models.UserRole.CLIENT and order.client_id == current_user.id:
        has_access = True
    elif current_user.role == models.UserRole.DRIVER and order.driver_id == current_user.id:
        has_access = True
    elif current_user.role == models.UserRole.DRIVER:
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ´ĞµĞ»Ğ°Ğ» Ğ»Ğ¸ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ ÑÑ‚Ğ°Ğ²ĞºÑƒ Ğ½Ğ° ÑÑ‚Ğ¾Ñ‚ Ğ·Ğ°ĞºĞ°Ğ·
        bid = db.query(models.Bid).filter(
            models.Bid.order_id == order_id,
            models.Bid.driver_id == current_user.id
        ).first()
        has_access = bool(bid)
    
    if not has_access:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    return order

@router.put("/{order_id}", response_model=schemas.OrderResponse)
async def update_order(
    order_id: int,
    order_update: schemas.OrderUpdate,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    # Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ¸Ğ»Ğ¸ ÑƒÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½ÑƒÑ Ñ†ĞµĞ½Ñƒ
    if current_user.role != models.UserRole.ADMIN:
        if "driver_id" in order_update.model_dump(exclude_unset=True):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"
            )
        if "final_price" in order_update.model_dump(exclude_unset=True):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑƒÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½ÑƒÑ Ñ†ĞµĞ½Ñƒ"
            )
    
    updated_order = crud.update_order(db, order_id, order_update)
    
    # Ğ•ÑĞ»Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ ÑÑ‚Ğ°Ñ‚ÑƒÑ, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
    if order_update.status and order_update.status != order.status:
        background_tasks.add_task(
            notify_order_status_change,
            db,
            order_id,
            order.status,
            order_update.status
        )
    
    logger.info(f"Order updated: {updated_order.order_number}")
    
    return updated_order

@router.post("/{order_id}/publish")
async def publish_order(
    order_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_client),
    db: Session = Depends(get_db)
):
    """
    ĞŸÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ° (Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´ Ğ² ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ)
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    if order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    if order.status != models.OrderStatus.DRAFT:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ğ—Ğ°ĞºĞ°Ğ· ÑƒĞ¶Ğµ Ğ¾Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ğ½"
        )
    
    # ĞŸÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
    order.status = models.OrderStatus.SEARCHING
    db.commit()
    db.refresh(order)
    
    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·Ğµ
    background_tasks.add_task(
        notification_service.notify_new_order,
        db,
        order_id
    )
    
    logger.info(f"Order published: {order.order_number}")
    
    return {"message": "Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ¾Ğ²Ğ°Ğ½", "order": order}

@router.post("/{order_id}/cancel")
async def cancel_order(
    order_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    if current_user.role == models.UserRole.DRIVER and order.driver_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    if order.status in [models.OrderStatus.COMPLETED, models.OrderStatus.CANCELLED]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ»Ğ¸ ÑƒĞ¶Ğµ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·"
        )
    
    # ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
    cancelled_order = crud.cancel_order(db, order_id)
    
    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
    background_tasks.add_task(
        notify_order_cancelled,
        db,
        order_id,
        current_user.id
    )
    
    logger.info(f"Order cancelled: {order.order_number} by user: {current_user.email}")
    
    return {"message": "Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½", "order": cancelled_order}

@router.post("/{order_id}/complete")
async def complete_order(
    order_id: int,
    background_tasks: BackgroundTasks,
    current_user: schemas.UserResponse = Depends(get_current_driver),
    db: Session = Depends(get_db)
):
    """
    Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ° (Ğ´Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹)
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    if order.driver_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    if order.status not in [models.OrderStatus.EN_ROUTE, models.OrderStatus.UNLOADING]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ· Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑĞµ"
        )
    
    # Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
    completed_order = crud.complete_order(db, order_id)
    
    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
    background_tasks.add_task(
        notification_service.notify_order_completed,
        db,
        order_id
    )
    
    logger.info(f"Order completed: {order.order_number} by driver: {current_user.email}")
    
    return {"message": "Ğ—Ğ°ĞºĞ°Ğ· Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½", "order": completed_order}

@router.post("/{order_id}/upload-image")
async def upload_order_image(
    order_id: int,
    file: UploadFile = File(...),
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == models.UserRole.CLIENT and order.client_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    if current_user.role == models.UserRole.DRIVER and order.driver_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    try:
        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»
        file_path = await file_storage.save_order_image(file, current_user.id, order_id)
        
        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğµ
        if not order.cargo_images:
            order.cargo_images = []
        
        order.cargo_images.append(file_path)
        db.commit()
        
        logger.info(f"Image uploaded for order: {order.order_number}")
        
        return {
            "message": "Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾",
            "file_path": file_path,
            "order_id": order_id
        }
        
    except Exception as e:
        logger.error(f"Error uploading image: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ: {str(e)}"
        )

@router.post("/calculate-price")
async def calculate_order_price(
    request: schemas.PriceCalculationRequest,
    current_user: schemas.UserResponse = Depends(get_current_active_user)
):
    """
    Ğ Ğ°ÑÑ‡ĞµÑ‚ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸
    """
    try:
        # Ğ Ğ°ÑÑ‡ĞµÑ‚ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
        distance_km = crud.utils.calculate_distance(
            request.from_lat, request.from_lng,
            request.to_lat, request.to_lng
        )
        
        # Ğ Ğ°ÑÑ‡ĞµÑ‚ Ñ†ĞµĞ½Ñ‹
        final_price, platform_fee, driver_amount = crud.utils.calculate_price(
            distance_km, request.weight, request.volume
        )
        
        # Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ñ€Ğ°ÑÑ‡ĞµÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸
        base_price = distance_km * 15.0
        weight_multiplier = request.weight * 10.0
        volume_multiplier = request.volume * 5.0
        
        # ĞŸÑ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ° (Ğ¶ĞµĞ»Ğ°ĞµĞ¼Ğ°Ñ Ñ†ĞµĞ½Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°)
        suggested_price = final_price * 1.1  # +10% Ğ´Ğ»Ñ Ñ‚Ğ¾Ñ€Ğ³Ğ°
        
        result = schemas.PriceCalculation(
            distance_km=round(distance_km, 2),
            base_price=round(base_price, 2),
            weight_multiplier=round(weight_multiplier, 2),
            volume_multiplier=round(volume_multiplier, 2),
            suggested_price=round(suggested_price, 2),
            platform_fee=round(platform_fee, 2),
            driver_amount=round(driver_amount, 2)
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Error calculating price: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ñ€Ğ°ÑÑ‡ĞµÑ‚Ğµ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸: {str(e)}"
        )

@router.get("/{order_number}/track")
async def track_order_by_number(
    order_number: str,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¿Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€Ñƒ (Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿)
    """
    order = crud.get_order_by_number(db, order_number)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # Ğ”Ğ»Ñ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ½ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ
    response = {
        "order_number": order.order_number,
        "status": order.status.value,
        "from_address": order.from_address,
        "to_address": order.to_address,
        "cargo_type": order.cargo_type,
        "created_at": order.created_at,
        "updated_at": order.updated_at
    }
    
    # Ğ•ÑĞ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½ Ğ¸ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿, Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸
    if current_user:
        has_access = False
        if current_user.role == models.UserRole.ADMIN:
            has_access = True
        elif current_user.role == models.UserRole.CLIENT and order.client_id == current_user.id:
            has_access = True
        elif current_user.role == models.UserRole.DRIVER and order.driver_id == current_user.id:
            has_access = True
        
        if has_access:
            response.update({
                "driver_id": order.driver_id,
                "client_id": order.client_id,
                "final_price": order.final_price,
                "distance_km": order.distance_km,
                "pickup_date": order.pickup_date,
                "delivery_date": order.delivery_date
            })
    
    return response

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
async def notify_admins_about_new_order(db: Session, order_id: int):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·Ğµ"""
    try:
        admins = crud.get_users(db, role="admin", is_active=True)
        for admin in admins:
            await notification_service.send_notification(
                db,
                admin.id,
                "new_order_created",
                {"order_id": order_id}
            )
    except Exception as e:
        logger.error(f"Error notifying admins about new order: {e}")

async def notify_order_status_change(
    db: Session,
    order_id: int,
    old_status: str,
    new_status: str
):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    try:
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
        await notification_service.send_notification(
            db,
            order.client_id,
            "order_updated",
            {
                "order_id": order_id,
                "order_number": order.order_number,
                "old_status": old_status,
                "new_status": new_status
            }
        )
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ, ĞµÑĞ»Ğ¸ Ğ¾Ğ½ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½
        if order.driver_id:
            await notification_service.send_notification(
                db,
                order.driver_id,
                "order_updated",
                {
                    "order_id": order_id,
                    "order_number": order.order_number,
                    "old_status": old_status,
                    "new_status": new_status
                }
            )
    except Exception as e:
        logger.error(f"Error notifying about order status change: {e}")

async def notify_order_cancelled(
    db: Session,
    order_id: int,
    cancelled_by_user_id: int
):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ± Ğ¾Ñ‚Ğ¼ĞµĞ½Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    try:
        order = crud.get_order(db, order_id)
        if not order:
            return
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²
        participants = [order.client_id]
        if order.driver_id:
            participants.append(order.driver_id)
        
        for user_id in participants:
            if user_id != cancelled_by_user_id:  # ĞĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ³Ğ¾, ĞºÑ‚Ğ¾ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ»
                await notification_service.send_notification(
                    db,
                    user_id,
                    "order_cancelled",
                    {
                        "order_id": order_id,
                        "order_number": order.order_number,
                        "cancelled_by": cancelled_by_user_id
                    }
                )
    except Exception as e:
        logger.error(f"Error notifying about order cancellation: {e}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\track.py                                                    â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\track.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ (WebSocket)
"""
from typing import Annotated
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, HTTPException, status
from sqlalchemy.orm import Session
import json
import logging
from datetime import datetime, timedelta

from .. import crud, schemas, models
from ..auth import verify_token, get_current_user
from ..database import get_db
from ..websocket_manager import manager
from ..utils import validate_coordinates

router = APIRouter()
logger = logging.getLogger(__name__)

@router.websocket("/ws/track/driver")
async def websocket_track_driver_endpoint(
    websocket: WebSocket,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint Ğ´Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    """
    # Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ñ‚Ğ¾ĞºĞµĞ½Ğ°
    payload = verify_token(token)
    if not payload:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    user_id = payload.get("user_id")
    user_role = payload.get("role")
    
    if not user_id or user_role != models.UserRole.DRIVER.value:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    user = crud.get_user_by_id(db, user_id)
    if not user or not user.is_active:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    profile = crud.get_driver_profile(db, user_id)
    if not profile or profile.verification_status != models.VerificationStatus.VERIFIED:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Driver not verified")
        return
    
    # ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğº Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ñƒ
    await manager.connect_driver_tracking(websocket, user_id)
    
    try:
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ» Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
        while True:
            data = await websocket.receive_text()
            location_data = json.loads(data)
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¸Ğ¿Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
            if location_data.get("type") != "location_update":
                continue
            
            lat = location_data.get("lat")
            lng = location_data.get("lng")
            
            # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚
            if not validate_coordinates(lat, lng):
                await websocket.send_json({
                    "type": "error",
                    "message": "ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ñ‹"
                })
                continue
            
            accuracy = location_data.get("accuracy")
            speed = location_data.get("speed")
            heading = location_data.get("heading")
            
            # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
            order = db.query(models.Order).filter(
                models.Order.driver_id == user_id,
                models.Order.status.in_([
                    models.OrderStatus.DRIVER_ASSIGNED,
                    models.OrderStatus.LOADING,
                    models.OrderStatus.EN_ROUTE,
                    models.OrderStatus.UNLOADING
                ])
            ).order_by(models.Order.updated_at.desc()).first()
            
            order_id = order.id if order else None
            
            # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ² Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            location_create = schemas.LocationCreate(
                lat=lat,
                lng=lng,
                order_id=order_id,
                accuracy=accuracy,
                speed=speed,
                heading=heading
            )
            
            location = crud.create_location_update(db, location_create, user_id)
            
            # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ² Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
            profile.current_location_lat = lat
            profile.current_location_lng = lng
            profile.is_online = True
            db.commit()
            
            # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ Ñ‚Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ğ¸
            broadcast_data = {
                "driver_id": user_id,
                "driver_name": user.full_name,
                "vehicle_number": profile.vehicle_number,
                "order_id": order_id,
                "order_number": order.order_number if order else None,
                "lat": lat,
                "lng": lng,
                "accuracy": accuracy,
                "speed": speed,
                "heading": heading,
                "timestamp": datetime.utcnow().isoformat()
            }
            
            # Ğ¢Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ñ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ°Ğ¼
            await manager.broadcast_location(user_id, broadcast_data)
            
            # ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
            await websocket.send_json({
                "type": "location_received",
                "data": {
                    "timestamp": datetime.utcnow().isoformat(),
                    "location_id": location.id
                }
            })
            
            logger.debug(f"Location update from driver {user.email}: ({lat}, {lng})")
            
    except WebSocketDisconnect:
        logger.info(f"Driver tracking WebSocket disconnected: driver {user.email}")
        manager.disconnect_driver_tracking(user_id)
        
    except Exception as e:
        logger.error(f"Driver tracking WebSocket error: {e}")
        manager.disconnect_driver_tracking(user_id)
        try:
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        except:
            pass

@router.websocket("/ws/track/subscribe/{driver_id}")
async def websocket_track_subscribe_endpoint(
    websocket: WebSocket,
    driver_id: int,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """
    WebSocket endpoint Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ½Ğ° Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    """
    # Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ñ‚Ğ¾ĞºĞµĞ½Ğ°
    payload = verify_token(token)
    if not payload:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    user_id = payload.get("user_id")
    user_role = payload.get("role")
    
    if not user_id:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user = crud.get_user_by_id(db, user_id)
    if not user or not user.is_active:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if user.role == models.UserRole.ADMIN:
        # ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ğ»ÑĞ±Ğ¾Ğ³Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
        await manager.connect_admin(websocket, user_id)
        
    elif user.role == models.UserRole.CLIENT:
        # ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ ÑĞ²Ğ¾Ğ¸Ñ… Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
        active_order = db.query(models.Order).filter(
            models.Order.client_id == user_id,
            models.Order.driver_id == driver_id,
            models.Order.status.in_([
                models.OrderStatus.DRIVER_ASSIGNED,
                models.OrderStatus.LOADING,
                models.OrderStatus.EN_ROUTE,
                models.OrderStatus.UNLOADING
            ])
        ).first()
        
        if not active_order:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Not authorized")
            return
        
        await manager.connect_tracking_subscriber(websocket, driver_id, user_id)
        
    else:
        # Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Not authorized")
        return
    
    try:
        # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
        driver = crud.get_user_by_id(db, driver_id)
        driver_profile = crud.get_driver_profile(db, driver_id)
        
        if not driver or not driver_profile:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Driver not found")
            return
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğµ
        await websocket.send_json({
            "type": "driver_info",
            "data": {
                "driver_id": driver_id,
                "driver_name": driver.full_name,
                "driver_email": driver.email,
                "vehicle_type": driver_profile.vehicle_type,
                "vehicle_model": driver_profile.vehicle_model,
                "vehicle_number": driver_profile.vehicle_number,
                "phone": driver.phone,
                "rating": driver_profile.rating,
                "is_online": driver_profile.is_online
            }
        })
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
        last_location = db.query(models.LocationUpdate).filter(
            models.LocationUpdate.driver_id == driver_id
        ).order_by(models.LocationUpdate.timestamp.desc()).first()
        
        if last_location:
            await websocket.send_json({
                "type": "location_update",
                "data": {
                    "driver_id": driver_id,
                    "lat": last_location.lat,
                    "lng": last_location.lng,
                    "accuracy": last_location.accuracy,
                    "speed": last_location.speed,
                    "heading": last_location.heading,
                    "order_id": last_location.order_id,
                    "timestamp": last_location.timestamp.isoformat()
                }
            })
        
        # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ° Ğ´Ğ»Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        if user.role == models.UserRole.CLIENT:
            active_order = db.query(models.Order).filter(
                models.Order.client_id == user_id,
                models.Order.driver_id == driver_id,
                models.Order.status.in_([
                    models.OrderStatus.DRIVER_ASSIGNED,
                    models.OrderStatus.LOADING,
                    models.OrderStatus.EN_ROUTE,
                    models.OrderStatus.UNLOADING
                ])
            ).first()
            
            if active_order:
                route_history = crud.get_locations_by_driver(
                    db, driver_id, active_order.id, limit=100
                )
                
                if route_history:
                    await websocket.send_json({
                        "type": "route_history",
                        "data": {
                            "order_id": active_order.id,
                            "route": [
                                {
                                    "lat": loc.lat,
                                    "lng": loc.lng,
                                    "timestamp": loc.timestamp.isoformat()
                                }
                                for loc in reversed(route_history)  # ĞÑ‚ ÑÑ‚Ğ°Ñ€Ñ‹Ñ… Ğº Ğ½Ğ¾Ğ²Ñ‹Ğ¼
                            ]
                        }
                    })
        
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ» (Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ğ½Ğ¸Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ)
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ Ğ¾Ñ‚ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
            if message_data.get("type") == "request_history":
                hours = message_data.get("hours", 24)
                from_time = datetime.utcnow() - timedelta(hours=hours)
                
                locations = db.query(models.LocationUpdate).filter(
                    models.LocationUpdate.driver_id == driver_id,
                    models.LocationUpdate.timestamp >= from_time
                ).order_by(models.LocationUpdate.timestamp.asc()).all()
                
                await websocket.send_json({
                    "type": "location_history",
                    "data": {
                        "driver_id": driver_id,
                        "locations": [
                            {
                                "lat": loc.lat,
                                "lng": loc.lng,
                                "timestamp": loc.timestamp.isoformat(),
                                "order_id": loc.order_id
                            }
                            for loc in locations
                        ]
                    }
                })
            
    except WebSocketDisconnect:
        logger.info(f"Tracking subscriber WebSocket disconnected: user {user.email}")
        if user.role == models.UserRole.ADMIN:
            manager.disconnect_admin(websocket, user_id)
        else:
            manager.disconnect_tracking_subscriber(websocket, driver_id, user_id)
            
    except Exception as e:
        logger.error(f"Tracking subscriber WebSocket error: {e}")
        if user.role == models.UserRole.ADMIN:
            manager.disconnect_admin(websocket, user_id)
        else:
            manager.disconnect_tracking_subscriber(websocket, driver_id, user_id)
        try:
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        except:
            pass

@router.get("/track/driver/{driver_id}/locations")
async def get_driver_locations(
    driver_id: int,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db),
    hours: int = Query(24, ge=1, le=168, description="ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‡Ğ°ÑĞ¾Ğ² Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸"),
    limit: int = Query(100, ge=1, le=1000, description="Ğ›Ğ¸Ğ¼Ğ¸Ñ‚ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹")
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ (HTTP endpoint)
    """
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    if current_user.role == models.UserRole.CLIENT:
        # ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹ ÑĞ²Ğ¾Ğ¸Ñ… Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
        active_order = db.query(models.Order).filter(
            models.Order.client_id == current_user.id,
            models.Order.driver_id == driver_id,
            models.Order.status.in_([
                models.OrderStatus.DRIVER_ASSIGNED,
                models.OrderStatus.LOADING,
                models.OrderStatus.EN_ROUTE,
                models.OrderStatus.UNLOADING
            ])
        ).first()
        
        if not active_order:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
            )
    
    elif current_user.role == models.UserRole.DRIVER:
        # Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞ²Ğ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
        if current_user.id != driver_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
            )
    
    # Ğ”Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½ Ğ²ÑĞµĞ³Ğ´Ğ°
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    from_time = datetime.utcnow() - timedelta(hours=hours)
    
    locations = db.query(models.LocationUpdate).filter(
        models.LocationUpdate.driver_id == driver_id,
        models.LocationUpdate.timestamp >= from_time
    ).order_by(models.LocationUpdate.timestamp.desc()).limit(limit).all()
    
    return locations

@router.get("/track/order/{order_id}/route")
async def get_order_route(
    order_id: int,
    current_user: Annotated[schemas.UserResponse, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    """
    order = crud.get_order(db, order_id)
    if not order:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ğ—Ğ°ĞºĞ°Ğ· Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    is_authorized = (
        current_user.id == order.client_id or 
        current_user.id == order.driver_id or
        current_user.role == models.UserRole.ADMIN
    )
    
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½"
        )
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ‚Ğ¾Ñ‡ĞµĞº Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ°
    route_points = []
    
    # ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ‚Ğ¾Ñ‡ĞºĞ° (Ğ¾Ñ‚ĞºÑƒĞ´Ğ°)
    route_points.append({
        "type": "pickup",
        "address": order.from_address,
        "lat": order.from_lat,
        "lng": order.from_lng,
        "timestamp": order.pickup_date.isoformat() if order.pickup_date else None
    })
    
    # ĞŸÑ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ñ‚Ğ¾Ñ‡ĞºĞ¸ (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³)
    if order.driver_id:
        locations = crud.get_locations_by_driver(db, order.driver_id, order_id, limit=200)
        for loc in locations:
            route_points.append({
                "type": "tracking",
                "lat": loc.lat,
                "lng": loc.lng,
                "timestamp": loc.timestamp.isoformat(),
                "accuracy": loc.accuracy,
                "speed": loc.speed
            })
    
    # ĞšĞ¾Ğ½ĞµÑ‡Ğ½Ğ°Ñ Ñ‚Ğ¾Ñ‡ĞºĞ° (ĞºÑƒĞ´Ğ°)
    route_points.append({
        "type": "delivery",
        "address": order.to_address,
        "lat": order.to_lat,
        "lng": order.to_lng,
        "timestamp": order.delivery_date.isoformat() if order.delivery_date else None
    })
    
    # Ğ Ğ°ÑÑ‡ĞµÑ‚ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
    total_distance = order.distance_km or 0
    estimated_time = None
    
    if len(route_points) > 2 and order.driver_id:
        # Ğ Ğ°ÑÑ‡ĞµÑ‚ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ (ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ¾)
        driver_profile = crud.get_driver_profile(db, order.driver_id)
        if driver_profile:
            estimated_time = total_distance / 60  # ĞŸÑ€ĞµĞ´Ğ¿Ğ¾Ğ»Ğ°Ğ³Ğ°ĞµĞ¼Ğ°Ñ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ 60 ĞºĞ¼/Ñ‡
    
    return {
        "order_id": order_id,
        "order_number": order.order_number,
        "status": order.status.value,
        "route_points": route_points,
        "statistics": {
            "total_distance_km": total_distance,
            "estimated_time_hours": estimated_time,
            "points_count": len(route_points)
        }
    }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\routes\users.py                                                    â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\routes\users.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional

from .. import schemas, crud
from ..auth import get_current_active_user, get_current_admin
from ..database import get_db
from ..dependencies import PaginationParams

router = APIRouter(prefix="/api/users", tags=["users"])

@router.get("/me", response_model=schemas.UserResponse)
async def read_users_me(
    current_user: schemas.UserResponse = Depends(get_current_active_user)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ
    """
    return current_user

@router.put("/me", response_model=schemas.UserResponse)
async def update_user_me(
    user_update: schemas.UserUpdate,
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    """
    updated_user = crud.update_user(db, current_user.id, user_update)
    if not updated_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    return updated_user

@router.get("/", response_model=List[schemas.UserResponse])
async def get_users(
    pagination: PaginationParams = Depends(),
    role: Optional[str] = Query(None, description="Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ Ñ€Ğ¾Ğ»Ğ¸"),
    is_active: Optional[bool] = Query(None, description="Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸"),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    users = crud.get_users(
        db,
        skip=pagination.skip,
        limit=pagination.limit,
        role=role,
        is_active=is_active
    )
    return users

@router.get("/{user_id}", response_model=schemas.UserResponse)
async def get_user_by_id(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ Ğ¿Ğ¾ ID (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    return user

@router.put("/{user_id}", response_model=schemas.UserResponse)
async def update_user(
    user_id: int,
    user_update: schemas.UserUpdate,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    updated_user = crud.update_user(db, user_id, user_update)
    if not updated_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    return updated_user

@router.delete("/{user_id}")
async def delete_user(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    success = crud.delete_user(db, user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    return {"message": "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒĞ´Ğ°Ğ»ĞµĞ½"}

@router.post("/{user_id}/activate")
async def activate_user(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    user.is_active = True
    db.commit()
    db.refresh(user)
    
    return {"message": "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½"}

@router.post("/{user_id}/deactivate")
async def deactivate_user(
    user_id: int,
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    Ğ”ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    user.is_active = False
    db.commit()
    db.refresh(user)
    
    return {"message": "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ´ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½"}

@router.get("/me/balance")
async def get_my_balance(
    current_user: schemas.UserResponse = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ° Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    """
    user = crud.get_user_by_id(db, current_user.id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"
        )
    
    return {"balance": user.balance}

@router.get("/search")
async def search_users(
    query: str = Query(..., description="ĞŸĞ¾Ğ¸ÑĞºĞ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ (email, Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½, Ğ¸Ğ¼Ñ)"),
    pagination: PaginationParams = Depends(),
    current_user: schemas.UserResponse = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """
    ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²)
    """
    users = db.query(crud.models.User).filter(
        (crud.models.User.email.ilike(f"%{query}%")) |
        (crud.models.User.phone.ilike(f"%{query}%")) |
        (crud.models.User.full_name.ilike(f"%{query}%"))
    ).order_by(crud.models.User.created_at.desc())\
     .offset(pagination.skip)\
     .limit(pagination.limit)\
     .all()
    
    return users
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\schemas.py                                                         â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\schemas.py  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Pydantic ÑÑ…ĞµĞ¼Ñ‹ Ğ´Ğ»Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
"""
from pydantic import BaseModel, EmailStr, ConfigDict, Field, field_validator
from typing import Optional, List
from datetime import datetime
from enum import Enum
from decimal import Decimal

# Enums for schemas
class UserRole(str, Enum):
    CLIENT = "client"
    DRIVER = "driver"
    ADMIN = "admin"

class VerificationStatus(str, Enum):
    PENDING = "pending"
    VERIFIED = "verified"
    REJECTED = "rejected"

class OrderStatus(str, Enum):
    DRAFT = "draft"
    SEARCHING = "searching"
    DRIVER_ASSIGNED = "driver_assigned"
    LOADING = "loading"
    EN_ROUTE = "en_route"
    UNLOADING = "unloading"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
    PAID = "paid"

class BidStatus(str, Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    REJECTED = "rejected"
    CANCELLED = "cancelled"

class PaymentStatus(str, Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"

# User schemas
class UserBase(BaseModel):
    email: EmailStr
    phone: str = Field(..., pattern=r'^\+?[1-9]\d{1,14}$')
    full_name: Optional[str] = None
    role: UserRole = UserRole.CLIENT

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, max_length=72)
    
    @field_validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        if len(v) > 72:
            raise ValueError('Password cannot be longer than 72 characters')
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not any(c.islower() for c in v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one digit')
        return v

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserUpdate(BaseModel):
    phone: Optional[str] = None
    full_name: Optional[str] = None
    password: Optional[str] = None

class UserResponse(UserBase):
    id: int
    is_active: bool
    is_verified: bool
    balance: float
    created_at: datetime
    updated_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    user: UserResponse

class TokenData(BaseModel):
    user_id: Optional[int] = None
    email: Optional[str] = None
    role: Optional[str] = None
    exp: Optional[int] = None

# Driver schemas
class DriverProfileBase(BaseModel):
    vehicle_type: str
    vehicle_model: Optional[str] = None
    vehicle_number: str
    carrying_capacity: float = Field(..., gt=0)
    volume: float = Field(..., gt=0)

class DriverProfileCreate(DriverProfileBase):
    pass

class DriverProfileUpdate(BaseModel):
    vehicle_type: Optional[str] = None
    vehicle_model: Optional[str] = None
    vehicle_number: Optional[str] = None
    carrying_capacity: Optional[float] = None
    volume: Optional[float] = None
    is_online: Optional[bool] = None
    current_location_lat: Optional[float] = None
    current_location_lng: Optional[float] = None

class DriverProfileResponse(DriverProfileBase):
    id: int
    user_id: int
    verification_status: VerificationStatus
    rating: float
    total_orders: int
    total_distance: float
    is_online: bool
    current_location_lat: Optional[float] = None
    current_location_lng: Optional[float] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class DriverWithProfile(BaseModel):
    user: UserResponse
    profile: DriverProfileResponse
    model_config = ConfigDict(from_attributes=True)

# Order schemas
class OrderBase(BaseModel):
    from_address: str = Field(..., min_length=3)
    from_lat: float = Field(..., ge=-90, le=90)
    from_lng: float = Field(..., ge=-180, le=180)
    to_address: str = Field(..., min_length=3)
    to_lat: float = Field(..., ge=-90, le=90)
    to_lng: float = Field(..., ge=-180, le=180)
    cargo_description: str = Field(..., min_length=5)
    cargo_weight: float = Field(..., gt=0)
    cargo_volume: float = Field(..., gt=0)
    cargo_type: str = Field(..., min_length=2)
    desired_price: float = Field(..., gt=0)
    pickup_date: Optional[datetime] = None

class OrderCreate(OrderBase):
    pass

class OrderUpdate(BaseModel):
    status: Optional[OrderStatus] = None
    driver_id: Optional[int] = None
    final_price: Optional[float] = None
    pickup_date: Optional[datetime] = None
    delivery_date: Optional[datetime] = None

class OrderResponse(OrderBase):
    id: int
    order_number: str
    client_id: int
    driver_id: Optional[int] = None
    status: OrderStatus
    distance_km: Optional[float] = None
    final_price: Optional[float] = None
    platform_fee: Optional[float] = None
    order_amount: Optional[float] = None
    payment_status: PaymentStatus
    delivery_date: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class OrderWithRelations(OrderResponse):
    client: Optional[UserResponse] = None
    driver: Optional[UserResponse] = None
    bids: List['BidResponse'] = []
    model_config = ConfigDict(from_attributes=True)

# Bid schemas
class BidBase(BaseModel):
    proposed_price: float = Field(..., gt=0)
    message: Optional[str] = None

class BidCreate(BidBase):
    pass

class BidResponse(BidBase):
    id: int
    order_id: int
    driver_id: int
    status: BidStatus
    created_at: datetime
    updated_at: Optional[datetime] = None
    driver: Optional[UserResponse] = None
    model_config = ConfigDict(from_attributes=True)

# Message schemas
class MessageBase(BaseModel):
    content: str = Field(..., min_length=1, max_length=1000)

class MessageCreate(MessageBase):
    pass

class MessageResponse(MessageBase):
    id: int
    order_id: int
    sender_id: int
    is_read: bool
    timestamp: datetime
    sender: Optional[UserResponse] = None
    model_config = ConfigDict(from_attributes=True)

# Location schemas
class LocationBase(BaseModel):
    lat: float = Field(..., ge=-90, le=90)
    lng: float = Field(..., ge=-180, le=180)
    accuracy: Optional[float] = None
    speed: Optional[float] = None
    heading: Optional[float] = None

class LocationCreate(LocationBase):
    order_id: Optional[int] = None

class LocationResponse(LocationBase):
    id: int
    driver_id: int
    order_id: Optional[int] = None
    timestamp: datetime
    model_config = ConfigDict(from_attributes=True)

# Payment schemas
class PaymentBase(BaseModel):
    amount: float = Field(..., gt=0)
    currency: str = "RUB"
    description: Optional[str] = None

class PaymentCreate(PaymentBase):
    order_id: int
    payment_method: str

class PaymentResponse(PaymentBase):
    id: int
    user_id: int
    order_id: Optional[int] = None
    status: PaymentStatus
    payment_method: Optional[str] = None
    payment_id: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

# Notification schemas
class NotificationBase(BaseModel):
    title: str
    message: str
    type: str
    data: Optional[dict] = None

class NotificationResponse(NotificationBase):
    id: int
    user_id: int
    is_read: bool
    created_at: datetime
    model_config = ConfigDict(from_attributes=True)

# Calculator schemas
class PriceCalculationRequest(BaseModel):
    from_lat: float
    from_lng: float
    to_lat: float
    to_lng: float
    weight: float = Field(..., gt=0)
    volume: float = Field(..., gt=0)

class PriceCalculation(BaseModel):
    distance_km: float
    base_price: float
    weight_multiplier: float
    volume_multiplier: float
    suggested_price: float
    platform_fee: float
    driver_amount: float

# Admin schemas
class AdminStats(BaseModel):
    total_users: int
    total_drivers: int
    total_clients: int
    total_orders: int
    total_revenue: float
    pending_verifications: int
    active_orders: int

class VerificationRequest(BaseModel):
    driver_id: int
    status: VerificationStatus
    notes: Optional[str] = None

# Update forward references
OrderWithRelations.model_rebuild()
BidResponse.model_rebuild()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\seed.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\seed.py     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Seed Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
"""
from sqlalchemy.orm import Session
import random
from datetime import datetime, timedelta
from . import crud, models, schemas
from .auth import get_password_hash

def seed_database(db: Session):
    """Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸"""
    print("ğŸŒ± Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸...")
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, ĞµÑÑ‚ÑŒ Ğ»Ğ¸ ÑƒĞ¶Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    existing_users = db.query(models.User).count()
    if existing_users > 0:
        print("âš ï¸  Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑƒĞ¶Ğµ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ. ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ seed.")
        return
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°
    print("ğŸ‘‘ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°...")
    try:
        admin_user = models.User(
            email="admin@cargopro.com",
            phone="+79991112233",
            full_name="ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ CargoPro",
            role=models.UserRole.ADMIN,
            is_active=True,
            is_verified=True,
            hashed_password=get_password_hash("Admin123!"),
            balance=0.0
        )
        db.add(admin_user)
        db.commit()
        db.refresh(admin_user)
        print(f"âœ… ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ ÑĞ¾Ğ·Ğ´Ğ°Ğ½: {admin_user.email}")
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°: {e}")
        return
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ²
    print("ğŸ‘¥ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ²...")
    clients_data = [
        {
            "email": "client1@example.com",
            "phone": "+79992223344",
            "full_name": "Ğ˜Ğ²Ğ°Ğ½ ĞŸĞµÑ‚Ñ€Ğ¾Ğ²",
            "password": "Client123"
        },
        {
            "email": "client2@example.com",
            "phone": "+79993334455",
            "full_name": "ĞœĞ°Ñ€Ğ¸Ñ Ğ¡Ğ¸Ğ´Ğ¾Ñ€Ğ¾Ğ²Ğ°",
            "password": "Client123"
        },
        {
            "email": "company@example.com",
            "phone": "+74951234567",
            "full_name": "ĞĞĞ 'Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº'",
            "password": "Company123"
        }
    ]
    
    clients = []
    for client_data in clients_data:
        try:
            client = models.User(
                email=client_data["email"],
                phone=client_data["phone"],
                full_name=client_data["full_name"],
                role=models.UserRole.CLIENT,
                is_active=True,
                is_verified=True,
                hashed_password=get_password_hash(client_data["password"]),
                balance=10000.0
            )
            db.add(client)
            clients.append(client)
        except Exception as e:
            print(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ° {client_data['email']}: {e}")
    
    db.commit()
    for client in clients:
        db.refresh(client)
        print(f"âœ… ĞšĞ»Ğ¸ĞµĞ½Ñ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½: {client.email}")
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹
    print("ğŸšš Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹...")
    drivers_data = [
        {
            "email": "driver1@example.com",
            "phone": "+79994445566",
            "full_name": "ĞĞ»ĞµĞºÑĞµĞ¹ Ğ’Ğ¾Ğ´Ğ¸Ğ»Ğ¾Ğ²",
            "password": "Driver123",
            "vehicle_type": "Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº",
            "vehicle_model": "Mercedes Actros",
            "vehicle_number": "Ğ123Ğ’Ğ¡777",
            "carrying_capacity": 20.0,
            "volume": 90.0,
            "verification_status": models.VerificationStatus.VERIFIED,
            "rating": 4.8,
            "total_orders": 42,
            "total_distance": 12500.5,
            "is_online": True
        },
        {
            "email": "driver2@example.com",
            "phone": "+79995556677",
            "full_name": "Ğ”Ğ¼Ğ¸Ñ‚Ñ€Ğ¸Ğ¹ Ğ¨Ğ¾Ñ„ĞµÑ€Ğ¾Ğ²",
            "password": "Driver123",
            "vehicle_type": "Ğ¤ÑƒÑ€Ğ³Ğ¾Ğ½",
            "vehicle_model": "Ford Transit",
            "vehicle_number": "Ğ’456ĞĞ 777",
            "carrying_capacity": 3.5,
            "volume": 18.0,
            "verification_status": models.VerificationStatus.VERIFIED,
            "rating": 4.5,
            "total_orders": 28,
            "total_distance": 8500.0,
            "is_online": True
        },
        {
            "email": "driver3@example.com",
            "phone": "+79996667788",
            "full_name": "Ğ¡ĞµÑ€Ğ³ĞµĞ¹ Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸ĞºĞ¾Ğ²",
            "password": "Driver123",
            "vehicle_type": "Ğ ĞµÑ„Ñ€Ğ¸Ğ¶ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€",
            "vehicle_model": "Volvo FH",
            "vehicle_number": "Ğ¡789Ğ¢Ğ£777",
            "carrying_capacity": 18.0,
            "volume": 82.0,
            "verification_status": models.VerificationStatus.PENDING,
            "rating": 4.2,
            "total_orders": 15,
            "total_distance": 6200.0,
            "is_online": False
        }
    ]
    
    drivers = []
    for driver_data in drivers_data:
        try:
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ-Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
            driver_user = models.User(
                email=driver_data["email"],
                phone=driver_data["phone"],
                full_name=driver_data["full_name"],
                role=models.UserRole.DRIVER,
                is_active=True,
                is_verified=True if driver_data["verification_status"] == models.VerificationStatus.VERIFIED else False,
                hashed_password=get_password_hash(driver_data["password"]),
                balance=5000.0
            )
            db.add(driver_user)
            db.flush()  # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
            driver_profile = models.DriverProfile(
                user_id=driver_user.id,
                vehicle_type=driver_data["vehicle_type"],
                vehicle_model=driver_data["vehicle_model"],
                vehicle_number=driver_data["vehicle_number"],
                carrying_capacity=driver_data["carrying_capacity"],
                volume=driver_data["volume"],
                verification_status=driver_data["verification_status"],
                rating=driver_data["rating"],
                total_orders=driver_data["total_orders"],
                total_distance=driver_data["total_distance"],
                is_online=driver_data["is_online"],
                current_location_lat=55.7558 + random.uniform(-0.1, 0.1) if driver_data["is_online"] else None,
                current_location_lng=37.6173 + random.uniform(-0.1, 0.1) if driver_data["is_online"] else None
            )
            db.add(driver_profile)
            drivers.append(driver_user)
            print(f"âœ… Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½: {driver_user.email}")
        except Exception as e:
            print(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ {driver_data.get('email', 'unknown')}: {e}")
    
    db.commit()
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
    print("ğŸ“¦ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²...")
    orders_data = [
        {
            "client_id": clients[0].id,
            "status": models.OrderStatus.SEARCHING,
            "from_address": "ĞœĞ¾ÑĞºĞ²Ğ°, Ğ›ĞµĞ½Ğ¸Ğ½ÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¿ĞµĞºÑ‚, 32",
            "from_lat": 55.6911,
            "from_lng": 37.5734,
            "to_address": "Ğ¡Ğ°Ğ½ĞºÑ‚-ĞŸĞµÑ‚ĞµÑ€Ğ±ÑƒÑ€Ğ³, ĞĞµĞ²ÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¿ĞµĞºÑ‚, 28",
            "to_lat": 59.9343,
            "to_lng": 30.3351,
            "cargo_description": "ĞĞ±Ğ¾Ñ€ÑƒĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ñ„Ğ¸ÑĞ°",
            "cargo_weight": 2.5,
            "cargo_volume": 12.0,
            "cargo_type": "ĞĞ±Ğ¾Ñ€ÑƒĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
            "desired_price": 35000.0,
            "pickup_date": datetime.utcnow() + timedelta(days=2)
        },
        {
            "client_id": clients[1].id,
            "driver_id": drivers[0].id,
            "status": models.OrderStatus.EN_ROUTE,
            "from_address": "Ğ•ĞºĞ°Ñ‚ĞµÑ€Ğ¸Ğ½Ğ±ÑƒÑ€Ğ³, ÑƒĞ». ĞœĞ°Ğ»Ñ‹ÑˆĞµĞ²Ğ°, 51",
            "from_lat": 56.8389,
            "from_lng": 60.6057,
            "to_address": "Ğ§ĞµĞ»ÑĞ±Ğ¸Ğ½ÑĞº, Ğ¿Ñ€. Ğ›ĞµĞ½Ğ¸Ğ½Ğ°, 54",
            "to_lat": 55.1644,
            "to_lng": 61.4368,
            "cargo_description": "ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ Ğ¾Ğ´ĞµĞ¶Ğ´Ñ‹",
            "cargo_weight": 8.0,
            "cargo_volume": 45.0,
            "cargo_type": "ĞĞ´ĞµĞ¶Ğ´Ğ°",
            "desired_price": 18000.0,
            "final_price": 17500.0,
            "platform_fee": 875.0,
            "order_amount": 16625.0,
            "payment_status": models.PaymentStatus.COMPLETED,
            "pickup_date": datetime.utcnow() - timedelta(days=1),
            "delivery_date": datetime.utcnow() + timedelta(days=1)
        }
    ]
    
    for i, order_data in enumerate(orders_data):
        try:
            # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
            order_number = crud.generate_order_number()
            
            # Ğ Ğ°ÑÑ‡ĞµÑ‚ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
            distance = crud.utils.calculate_distance(
                order_data["from_lat"], order_data["from_lng"],
                order_data["to_lat"], order_data["to_lng"]
            )
            
            order = models.Order(
                order_number=order_number,
                distance_km=distance,
                **{k: v for k, v in order_data.items() if k not in ['client_id', 'driver_id']}
            )
            order.client_id = order_data["client_id"]
            if "driver_id" in order_data:
                order.driver_id = order_data["driver_id"]
            
            db.add(order)
            db.flush()
            print(f"âœ… Ğ—Ğ°ĞºĞ°Ğ· ÑĞ¾Ğ·Ğ´Ğ°Ğ½: {order.order_number} ({order.status})")
        except Exception as e:
            print(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ° {i}: {e}")
    
    db.commit()
    
    print("ğŸ‰ Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾!")
    print("\nğŸ“‹ Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ğ²Ñ…Ğ¾Ğ´Ğ°:")
    print("=" * 50)
    print("ğŸ‘‘ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ (Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸):")
    print(f"  Email: admin@cargopro.com")
    print(f"  ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Admin123!")
    print()
    print("ğŸ‘¥ ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹ (Ñ‡ĞµÑ€ĞµĞ· API Ğ¸Ğ»Ğ¸ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ):")
    print(f"  1. Email: client1@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Client123")
    print(f"  2. Email: client2@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Client123")
    print()
    print("ğŸšš Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸ (Ñ‡ĞµÑ€ĞµĞ· Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ):")
    print(f"  1. Email: driver1@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Driver123 (Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½)")
    print(f"  2. Email: driver2@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Driver123 (Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½)")
    print(f"  3. Email: driver3@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Driver123 (Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸)")
    print("=" * 50)

def clear_database(db: Session):
    """ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²!)"""
    print("âš ï¸  ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
    
    # ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ Ğ²Ğ°Ğ¶ĞµĞ½ Ğ¸Ğ·-Ğ·Ğ° Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ñ… ĞºĞ»ÑÑ‡ĞµĞ¹
    db.query(models.Notification).delete()
    db.query(models.Payment).delete()
    db.query(models.LocationUpdate).delete()
    db.query(models.Message).delete()
    db.query(models.Bid).delete()
    db.query(models.Order).delete()
    db.query(models.DriverProfile).delete()
    db.query(models.User).delete()
    
    db.commit()
    print("âœ… Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ğ°")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\utils.py                                                           â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\utils.py    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
"""
import math
from typing import Tuple
from datetime import datetime, timedelta
import re
import secrets
import string
from pathlib import Path

def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """
    Ğ Ğ°ÑÑ‡ĞµÑ‚ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ´Ğ²ÑƒĞ¼Ñ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ°Ğ¼Ğ¸ Ğ¿Ğ¾ Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»Ğµ Ğ¥Ğ°Ğ²ĞµÑ€ÑĞ¸Ğ½Ğ°
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ² ĞºĞ¸Ğ»Ğ¾Ğ¼ĞµÑ‚Ñ€Ğ°Ñ…
    """
    R = 6371  # Ğ Ğ°Ğ´Ğ¸ÑƒÑ Ğ—ĞµĞ¼Ğ»Ğ¸ Ğ² ĞºĞ¸Ğ»Ğ¾Ğ¼ĞµÑ‚Ñ€Ğ°Ñ…
    
    # ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ³Ñ€Ğ°Ğ´ÑƒÑĞ¾Ğ² Ğ² Ñ€Ğ°Ğ´Ğ¸Ğ°Ğ½Ñ‹
    phi1 = math.radians(lat1)
    phi2 = math.radians(lat2)
    delta_phi = math.radians(lat2 - lat1)
    delta_lambda = math.radians(lon2 - lon1)
    
    # Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ° Ğ¥Ğ°Ğ²ĞµÑ€ÑĞ¸Ğ½Ğ°
    a = math.sin(delta_phi / 2) ** 2 + \
        math.cos(phi1) * math.cos(phi2) * \
        math.sin(delta_lambda / 2) ** 2
    
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c
    
    return round(distance, 2)

def calculate_price(
    distance_km: float,
    weight: float,
    volume: float,
    base_rate_per_km: float = 15.0,
    weight_rate_per_ton: float = 10.0,
    volume_rate_per_cubic: float = 5.0,
    min_price: float = 500.0
) -> Tuple[float, float, float]:
    """
    Ğ Ğ°ÑÑ‡ĞµÑ‚ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚: (Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ_Ñ†ĞµĞ½Ğ°, ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ_Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹, ÑÑƒĞ¼Ğ¼Ğ°_Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ)
    """
    # Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ñ†ĞµĞ½Ğ° Ğ·Ğ° ĞºĞ¸Ğ»Ğ¾Ğ¼ĞµÑ‚Ñ€
    base_price = max(distance_km * base_rate_per_km, 100)
    
    # ĞĞ°Ğ´Ğ±Ğ°Ğ²ĞºĞ¸ Ğ·Ğ° Ğ²ĞµÑ Ğ¸ Ğ¾Ğ±ÑŠĞµĞ¼
    weight_adjustment = weight * weight_rate_per_ton
    volume_adjustment = volume * volume_rate_per_cubic
    
    # Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ†ĞµĞ½Ğ°
    final_price = base_price + weight_adjustment + volume_adjustment
    final_price = max(final_price, min_price)
    
    # ĞšĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹ (5%)
    platform_fee = final_price * 0.05
    
    # Ğ¡ÑƒĞ¼Ğ¼Ğ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
    driver_amount = final_price - platform_fee
    
    return round(final_price, 2), round(platform_fee, 2), round(driver_amount, 2)

def validate_phone_number(phone: str) -> bool:
    """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ° Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°"""
    pattern = r'^\+?[1-9]\d{1,14}$'
    return bool(re.match(pattern, phone))

def validate_coordinates(lat: float, lng: float) -> bool:
    """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚"""
    return -90 <= lat <= 90 and -180 <= lng <= 180

def generate_verification_code(length: int = 6) -> str:
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ´Ğ° Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸"""
    return ''.join(secrets.choice(string.digits) for _ in range(length))

def format_datetime(dt: datetime) -> str:
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ°Ñ‚Ñ‹-Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸"""
    return dt.strftime("%d.%m.%Y %H:%M")

def format_price(price: float) -> str:
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹"""
    return f"{price:,.2f}".replace(",", " ").replace(".", ",") + " â‚½"

def calculate_eta(distance_km: float, avg_speed_kmh: float = 60) -> timedelta:
    """Ğ Ğ°ÑÑ‡ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ¿Ñ€Ğ¸Ğ±Ñ‹Ñ‚Ğ¸Ñ"""
    hours = distance_km / avg_speed_kmh
    return timedelta(hours=hours)

def get_file_extension(filename: str) -> str:
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    return Path(filename).suffix.lower()

def is_allowed_file(filename: str, allowed_extensions: set) -> bool:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    return get_file_extension(filename) in allowed_extensions

def calculate_rating(current_rating: float, new_rating: int, total_ratings: int) -> float:
    """Ğ Ğ°ÑÑ‡ĞµÑ‚ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ°"""
    if total_ratings == 0:
        return new_rating
    return round((current_rating * total_ratings + new_rating) / (total_ratings + 1), 1)

def truncate_text(text: str, max_length: int = 100) -> str:
    """ĞĞ±Ñ€ĞµĞ·ĞºĞ° Ñ‚ĞµĞºÑÑ‚Ğ°"""
    if len(text) <= max_length:
        return text
    return text[:max_length - 3] + "..."

def generate_password(length: int = 12) -> str:
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ"""
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def validate_password_strength(password: str) -> Tuple[bool, str]:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ"""
    if len(password) < 8:
        return False, "ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ 8 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²"
    
    if not any(c.isupper() for c in password):
        return False, "ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ½Ñƒ Ğ·Ğ°Ğ³Ğ»Ğ°Ğ²Ğ½ÑƒÑ Ğ±ÑƒĞºĞ²Ñƒ"
    
    if not any(c.islower() for c in password):
        return False, "ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ½Ñƒ ÑÑ‚Ñ€Ğ¾Ñ‡Ğ½ÑƒÑ Ğ±ÑƒĞºĞ²Ñƒ"
    
    if not any(c.isdigit() for c in password):
        return False, "ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ½Ñƒ Ñ†Ğ¸Ñ„Ñ€Ñƒ"
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² Ğ½Ğµ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°, Ğ½Ğ¾ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ
    special_chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    if not any(c in special_chars for c in password):
        # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ True, Ğ½Ğ¾ Ñ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸ĞµĞ¹
        return True, "Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ (!@#$%^&*)"
    
    return True, "ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ Ğ½Ğ°Ğ´ĞµĞ¶Ğ½Ñ‹Ğ¹"

def calculate_driver_score(
    rating: float,
    total_orders: int,
    total_distance: float,
    response_time_avg: float
) -> float:
    """Ğ Ğ°ÑÑ‡ĞµÑ‚ ÑĞºĞ¾Ñ€Ğ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ´Ğ»Ñ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¹"""
    # Ğ’ĞµÑĞ¾Ğ²Ñ‹Ğµ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ñ‹
    rating_weight = 0.4
    experience_weight = 0.3
    distance_weight = 0.2
    response_weight = 0.1
    
    # ĞĞ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹
    rating_score = rating / 5.0
    experience_score = min(total_orders / 100, 1.0)
    distance_score = min(total_distance / 10000, 1.0)
    response_score = 1.0 / (1.0 + response_time_avg / 3600)  # Ñ‡Ğ°ÑÑ‹ Ğ² ÑĞµĞºÑƒĞ½Ğ´Ğ°Ñ…
    
    # Ğ Ğ°ÑÑ‡ĞµÑ‚ Ğ¾Ğ±Ñ‰ĞµĞ³Ğ¾ ÑĞºĞ¾Ñ€Ğ°
    total_score = (
        rating_score * rating_weight +
        experience_score * experience_weight +
        distance_score * distance_weight +
        response_score * response_weight
    )
    
    return round(total_score * 100, 2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: app\websocket_manager.py                                               â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\app\websocket_manager.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹
"""
from typing import Dict, List, Set, Optional
from fastapi import WebSocket, WebSocketDisconnect
from collections import defaultdict
import json
import asyncio
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class ConnectionManager:
    def __init__(self):
        # Ğ”Ğ»Ñ Ñ‡Ğ°Ñ‚Ğ°: order_id -> ÑĞ¿Ğ¸ÑĞ¾Ğº WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹
        self.chat_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # Ğ”Ğ»Ñ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ğ°: driver_id -> ÑĞ¿Ğ¸ÑĞ¾Ğº WebSocket ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ¾Ğ²
        self.tracking_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # Ğ”Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑÑ‰Ğ¸Ñ… ÑĞ²Ğ¾Ñ Ğ³ĞµĞ¾Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        self.driver_tracking_sockets: Dict[int, WebSocket] = {}
        
        # Ğ”Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²
        self.admin_connections: List[WebSocket] = []
        
        # Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ user_id -> ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹
        self.user_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹ Ğ½Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        self.max_connections_per_user = 5

    # ĞĞ±Ñ‰Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹
    async def connect_user(self, websocket: WebSocket, user_id: int):
        """ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        await websocket.accept()
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹
        if len(self.user_connections[user_id]) >= self.max_connections_per_user:
            # Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ°Ğ¼Ğ¾Ğµ ÑÑ‚Ğ°Ñ€Ğ¾Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
            old_ws = self.user_connections[user_id].pop(0)
            try:
                await old_ws.close(code=1000)
            except:
                pass
        
        self.user_connections[user_id].append(websocket)
        logger.info(f"User {user_id} connected. Total connections: {len(self.user_connections[user_id])}")

    def disconnect_user(self, websocket: WebSocket, user_id: int):
        """ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        if user_id in self.user_connections:
            if websocket in self.user_connections[user_id]:
                self.user_connections[user_id].remove(websocket)
                logger.info(f"User {user_id} disconnected. Remaining connections: {len(self.user_connections[user_id])}")
            
            if not self.user_connections[user_id]:
                del self.user_connections[user_id]

    async def send_to_user(self, user_id: int, message: dict):
        """ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        if user_id in self.user_connections:
            disconnected = []
            for connection in self.user_connections[user_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    logger.error(f"Error sending to user {user_id}: {e}")
                    disconnected.append(connection)
            
            for connection in disconnected:
                self.disconnect_user(connection, user_id)

    # ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ´Ğ»Ñ Ñ‡Ğ°Ñ‚Ğ°
    async def connect_chat(self, websocket: WebSocket, order_id: int, user_id: int):
        """ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº Ñ‡Ğ°Ñ‚Ñƒ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
        await self.connect_user(websocket, user_id)
        
        if order_id not in self.chat_connections:
            self.chat_connections[order_id] = []
        
        self.chat_connections[order_id].append(websocket)
        logger.info(f"User {user_id} connected to chat for order {order_id}")

    def disconnect_chat(self, websocket: WebSocket, order_id: int, user_id: int):
        """ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ Ñ‡Ğ°Ñ‚Ğ°"""
        self.disconnect_user(websocket, user_id)
        
        if order_id in self.chat_connections:
            if websocket in self.chat_connections[order_id]:
                self.chat_connections[order_id].remove(websocket)
            
            if not self.chat_connections[order_id]:
                del self.chat_connections[order_id]

    async def broadcast_chat_message(self, order_id: int, message: dict, exclude_user_id: Optional[int] = None):
        """Ğ¢Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ² Ñ‡Ğ°Ñ‚"""
        if order_id in self.chat_connections:
            disconnected = []
            for connection in self.chat_connections[order_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    logger.error(f"Error broadcasting chat message: {e}")
                    disconnected.append(connection)
            
            for connection in disconnected:
                # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ user_id Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ
                for uid, connections in self.user_connections.items():
                    if connection in connections:
                        self.disconnect_chat(connection, order_id, uid)
                        break

    # ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ´Ğ»Ñ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ğ° (Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸)
    async def connect_driver_tracking(self, websocket: WebSocket, driver_id: int):
        """ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ³ĞµĞ¾Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸"""
        await websocket.accept()
        self.driver_tracking_sockets[driver_id] = websocket
        logger.info(f"Driver {driver_id} connected for location updates")

    def disconnect_driver_tracking(self, driver_id: int):
        """ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ¾Ñ‚ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ğ°"""
        if driver_id in self.driver_tracking_sockets:
            del self.driver_tracking_sockets[driver_id]
            logger.info(f"Driver {driver_id} disconnected from location updates")

    # ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ´Ğ»Ñ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ğ° (Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ¸)
    async def connect_tracking_subscriber(self, websocket: WebSocket, driver_id: int, user_id: int):
        """ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ° Ğº Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ñƒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
        await self.connect_user(websocket, user_id)
        
        if driver_id not in self.tracking_connections:
            self.tracking_connections[driver_id] = []
        
        self.tracking_connections[driver_id].append(websocket)
        logger.info(f"User {user_id} subscribed to tracking for driver {driver_id}")

    def disconnect_tracking_subscriber(self, websocket: WebSocket, driver_id: int, user_id: int):
        """ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ° Ğ¾Ñ‚ Ñ‚Ñ€ĞµĞºĞ¸Ğ½Ğ³Ğ°"""
        self.disconnect_user(websocket, user_id)
        
        if driver_id in self.tracking_connections:
            if websocket in self.tracking_connections[driver_id]:
                self.tracking_connections[driver_id].remove(websocket)
            
            if not self.tracking_connections[driver_id]:
                del self.tracking_connections[driver_id]

    async def broadcast_location(self, driver_id: int, location_data: dict):
        """Ğ¢Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ñ Ğ¼ĞµÑÑ‚Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ°Ğ¼"""
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸ĞºĞ°Ğ¼
        if driver_id in self.tracking_connections:
            disconnected = []
            for connection in self.tracking_connections[driver_id]:
                try:
                    await connection.send_json({
                        "type": "location_update",
                        "driver_id": driver_id,
                        "data": location_data,
                        "timestamp": datetime.utcnow().isoformat()
                    })
                except Exception as e:
                    logger.error(f"Error broadcasting location to subscriber: {e}")
                    disconnected.append(connection)
            
            for connection in disconnected:
                # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ user_id Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ
                for uid, connections in self.user_connections.items():
                    if connection in connections:
                        self.disconnect_tracking_subscriber(connection, driver_id, uid)
                        break
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼
        disconnected_admins = []
        for connection in self.admin_connections:
            try:
                await connection.send_json({
                    "type": "admin_location_update",
                    "driver_id": driver_id,
                    "data": location_data,
                    "timestamp": datetime.utcnow().isoformat()
                })
            except Exception as e:
                logger.error(f"Error broadcasting location to admin: {e}")
                disconnected_admins.append(connection)
        
        for connection in disconnected_admins:
            if connection in self.admin_connections:
                self.admin_connections.remove(connection)

    # ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²
    async def connect_admin(self, websocket: WebSocket, admin_id: int):
        """ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°"""
        await self.connect_user(websocket, admin_id)
        self.admin_connections.append(websocket)
        logger.info(f"Admin {admin_id} connected")

    def disconnect_admin(self, websocket: WebSocket, admin_id: int):
        """ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°"""
        self.disconnect_user(websocket, admin_id)
        if websocket in self.admin_connections:
            self.admin_connections.remove(websocket)

    async def broadcast_admin_notification(self, notification: dict):
        """Ğ¢Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼"""
        disconnected = []
        for connection in self.admin_connections:
            try:
                await connection.send_json({
                    "type": "admin_notification",
                    "data": notification,
                    "timestamp": datetime.utcnow().isoformat()
                })
            except Exception as e:
                logger.error(f"Error broadcasting admin notification: {e}")
                disconnected.append(connection)
        
        for connection in disconnected:
            if connection in self.admin_connections:
                self.admin_connections.remove(connection)

    async def broadcast_system_message(self, message: dict, user_ids: Optional[List[int]] = None):
        """Ğ¢Ñ€Ğ°Ğ½ÑĞ»ÑÑ†Ğ¸Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ"""
        if user_ids:
            # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼
            for user_id in user_ids:
                await self.send_to_user(user_id, {
                    "type": "system_message",
                    "data": message,
                    "timestamp": datetime.utcnow().isoformat()
                })
        else:
            # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼
            for user_id in list(self.user_connections.keys()):
                await self.send_to_user(user_id, {
                    "type": "system_message",
                    "data": message,
                    "timestamp": datetime.utcnow().isoformat()
                })

    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    def get_stats(self) -> dict:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹"""
        return {
            "total_users_connected": len(self.user_connections),
            "total_connections": sum(len(conns) for conns in self.user_connections.values()),
            "active_chats": len(self.chat_connections),
            "drivers_tracking": len(self.driver_tracking_sockets),
            "tracking_subscriptions": len(self.tracking_connections),
            "admins_connected": len(self.admin_connections)
        }

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€Ğ°
manager = ConnectionManager()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: check_db.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\check_db.py     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# check_db.py
"""
ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
"""
import os
import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.database import engine, Base
from app.config import settings

print("ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
print(f"Database URL: {settings.DATABASE_URL}")

# ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ„Ğ°Ğ¹Ğ» SQLite
if settings.DATABASE_URL.startswith("sqlite"):
    db_path = settings.DATABASE_URL.replace("sqlite:///", "")
    print(f"SQLite Ñ„Ğ°Ğ¹Ğ»: {db_path}")
    
    if os.path.exists(db_path):
        print(f"Ğ¤Ğ°Ğ¹Ğ» Ğ‘Ğ” ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚, Ñ€Ğ°Ğ·Ğ¼ĞµÑ€: {os.path.getsize(db_path)} Ğ±Ğ°Ğ¹Ñ‚")
    else:
        print("Ğ¤Ğ°Ğ¹Ğ» Ğ‘Ğ” Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚")

# ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
try:
    print("\nĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹...")
    Base.metadata.create_all(bind=engine)
    print("Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹!")
except Exception as e:
    print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†: {e}")
    print(f"Ğ¢Ğ¸Ğ¿ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸: {type(e)}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: code.py                                                                â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\code.py         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import os
import argparse
from pathlib import Path

def should_skip_directory(dir_name):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ‚ÑŒ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ"""
    skip_dirs = {
        'node_modules', '.git', 'build', 'dist', 'coverage', 
        '.next', '.nuxt', '.cache', 'assets', 'static',
        'public', '.vscode', '.idea', '__pycache__', 'cache',
        'logs', 'temp', 'tmp', 'vendor', 'bin', 'obj'
    }
    return dir_name in skip_dirs or dir_name.startswith('.')

def should_skip_file(file_name):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»"""
    skip_files = {
        'package.json', 'package-lock.json', 'yarn.lock',
        'tsconfig.json', 'webpack.config.js', '.eslintrc.js',
        '.prettierrc', 'babel.config.js', 'next.config.js',
        'jest.config.js', 'vue.config.js', 'nuxt.config.js',
        '.gitignore', '.env', '.env.local', 'README.md'
    }
    return file_name in skip_files

def is_target_file(file_name):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ»Ğ¸ Ñ„Ğ°Ğ¹Ğ» Ñ†ĞµĞ»ĞµĞ²Ñ‹Ğ¼ (JS/JSX/TS/TSX Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹)"""
    target_extensions = {
        '.js', '.jsx', '.ts', '.tsx', '.vue', '.svelte',
        '.css', '.scss', '.less', '.html', '.htm', '.json',
        '.py', '.java', '.cpp', '.c', '.h', '.cs', '.php',
        '.rb', '.go', '.rs', '.swift', '.kt', '.dart'
    }
    return any(file_name.endswith(ext) for ext in target_extensions)

def get_file_category(file_extension):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ´Ğ»Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸"""
    categories = {
        '.js': 'JavaScript',
        '.jsx': 'React JSX',
        '.ts': 'TypeScript', 
        '.tsx': 'React TypeScript',
        '.vue': 'Vue',
        '.svelte': 'Svelte',
        '.py': 'Python',
        '.html': 'HTML',
        '.css': 'CSS',
        '.scss': 'SCSS',
        '.less': 'LESS',
        '.json': 'JSON',
        '.java': 'Java',
        '.cpp': 'C++',
        '.c': 'C',
        '.cs': 'C#',
        '.php': 'PHP',
        '.rb': 'Ruby',
        '.go': 'Go',
        '.rs': 'Rust',
        '.swift': 'Swift',
        '.kt': 'Kotlin',
        '.dart': 'Dart'
    }
    return categories.get(file_extension, 'Other')

def format_file_header(file_path, relative_path, category):
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    header = []
    header.append("â•”" + "â•" * 78 + "â•—")
    header.append(f"â•‘ Ğ¤ĞĞ™Ğ›: {relative_path:<70} â•‘")
    header.append(f"â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: {category:<65} â•‘")
    header.append(f"â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: {file_path:<64} â•‘")
    header.append("â•š" + "â•" * 78 + "â•")
    return '\n'.join(header)

def format_file_footer():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ²Ğ°Ğ» Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    return "\n" + "â”€" * 80 + "\n"

def collect_source_files(root_dir, output_file):
    """Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾ ÑĞ¾Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµÑ‚ Ğ¸Ñ… Ğ² output_file"""
    
    root_path = Path(root_dir)
    files_by_category = {}
    total_files = 0
    
    print("ğŸ” Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°...")
    
    # Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑĞ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ²ÑĞµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¿Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼
    for root, dirs, files in os.walk(root_dir):
        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ¸, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ
        dirs[:] = [d for d in dirs if not should_skip_directory(d)]
        
        for file in files:
            if should_skip_file(file):
                continue
                
            if is_target_file(file):
                file_path = Path(root) / file
                relative_path = file_path.relative_to(root_path)
                file_extension = file_path.suffix.lower()
                category = get_file_category(file_extension)
                
                if category not in files_by_category:
                    files_by_category[category] = []
                
                files_by_category[category].append((file_path, relative_path))
                total_files += 1
    
    print(f"ğŸ“ ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ {total_files} Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ² {len(files_by_category)} ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑÑ…")
    
    # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ² Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ„Ğ°Ğ¹Ğ», ÑĞ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼
    with open(output_file, 'w', encoding='utf-8') as out_f:
        # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°
        out_f.write("=" * 80 + "\n")
        out_f.write(f"Ğ˜Ğ¡Ğ¥ĞĞ”ĞĞ«Ğ™ ĞšĞĞ” ĞŸĞ ĞĞ•ĞšĞ¢Ğ\n")
        out_f.write(f"Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ: {root_dir}\n")
        out_f.write(f"Ğ’ÑĞµĞ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: {total_files}\n")
        out_f.write("=" * 80 + "\n\n")
        
        # ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼ Ğ² Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ
        for category in sorted(files_by_category.keys()):
            files_in_category = files_by_category[category]
            
            # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
            out_f.write("\n" + "â– " * 80 + "\n")
            out_f.write(f"ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: {category} ({len(files_in_category)} Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²)\n")
            out_f.write("â– " * 80 + "\n\n")
            
            # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¿Ğ¾ Ğ¿ÑƒÑ‚Ğ¸
            for file_path, relative_path in sorted(files_in_category, key=lambda x: str(x[1])):
                try:
                    # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ñ„Ğ°Ğ¹Ğ»Ğ°
                    out_f.write(format_file_header(str(file_path), str(relative_path), category))
                    out_f.write("\n\n")
                    
                    # Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ°
                    with open(file_path, 'r', encoding='utf-8') as in_f:
                        content = in_f.read().rstrip()  # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ»Ğ¸ÑˆĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹ Ğ² ĞºĞ¾Ğ½Ñ†Ğµ
                        out_f.write(content)
                    
                    # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ²Ğ°Ğ» Ñ„Ğ°Ğ¹Ğ»Ğ°
                    out_f.write(format_file_footer())
                    
                    print(f"âœ… ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½: {relative_path}")
                    
                except UnicodeDecodeError:
                    try:
                        # ĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ´Ñ€ÑƒĞ³ÑƒÑ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºÑƒ
                        with open(file_path, 'r', encoding='cp1251') as in_f:
                            content = in_f.read().rstrip()
                            out_f.write(content)
                        out_f.write(format_file_footer())
                        print(f"âœ… ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½ (Windows-1251): {relative_path}")
                    except Exception as e:
                        out_f.write(f"// âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°: {e}\n")
                        out_f.write(format_file_footer())
                        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {relative_path} - {e}")
                        
                except Exception as e:
                    out_f.write(f"// âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°: {e}\n")
                    out_f.write(format_file_footer())
                    print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {relative_path} - {e}")

def main():
    parser = argparse.ArgumentParser(
        description='ğŸ“ Ğ¡Ğ±Ğ¾Ñ€Ñ‰Ğ¸Ğº Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° - ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ» ÑĞ¾ Ğ²ÑĞµĞ¼ ĞºĞ¾Ğ´Ğ¾Ğ¼',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('--input', '-i', default='.', 
                       help='Ğ’Ñ…Ğ¾Ğ´Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ (Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ)')
    parser.add_argument('--output', '-o', default='project_code.txt',
                       help='Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ„Ğ°Ğ¹Ğ» (Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ project_code.txt)')
    
    args = parser.parse_args()
    
    input_dir = os.path.abspath(args.input)
    output_file = args.output
    
    if not os.path.exists(input_dir):
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ {input_dir} Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚!")
        return
    
    print("ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº ÑĞ±Ğ¾Ñ€Ñ‰Ğ¸ĞºĞ° Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°...")
    print(f"ğŸ“‚ Ğ˜ÑÑ…Ğ¾Ğ´Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ: {input_dir}")
    print(f"ğŸ’¾ Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ„Ğ°Ğ¹Ğ»: {output_file}")
    print("-" * 60)
    
    collect_source_files(input_dir, output_file)
    
    print("-" * 60)
    print(f"ğŸ‰ Ğ¡Ğ±Ğ¾Ñ€ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾!")
    print(f"ğŸ“„ Ğ’ÑĞµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹ Ğ²: {output_file}")

if __name__ == "__main__":
    main()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: init_db.py                                                             â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\init_db.py      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# init_db.py
"""
Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¹ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¾Ğ¹
"""
import os
import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.database import engine, Base
import sqlalchemy
import traceback

print("Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")

try:
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ñ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¸ĞµĞ¼ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸
    Base.metadata.create_all(bind=engine)
    print("Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°!")
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
    with engine.connect() as conn:
        result = conn.execute("SELECT 1").scalar()
        print(f"ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ: {result}")
        
except Exception as e:
    print(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
    traceback.print_exc()
    
    # ĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ°Ğ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´
    print("\nĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ°Ğ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´...")
    try:
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ´Ğ²Ğ¸Ğ¶Ğ¾Ğº Ñ ÑĞ²Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¾Ğ¹
        from sqlalchemy import create_engine
        from app.config import settings
        
        new_engine = create_engine(
            settings.DATABASE_URL,
            connect_args={"check_same_thread": False},
            echo=True
        )
        
        Base.metadata.create_all(bind=new_engine)
        print("Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ° Ñ Ğ°Ğ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼ Ğ´Ğ²Ğ¸Ğ¶ĞºĞ¾Ğ¼!")
        
    except Exception as e2:
        print(f"ĞĞ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ Ñ‚Ğ°ĞºĞ¶Ğµ Ğ½Ğµ ÑÑ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ»: {e2}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: run.py                                                                 â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\run.py          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#!/usr/bin/env python3
"""
Ğ—Ğ°Ğ¿ÑƒÑĞº ÑĞµÑ€Ğ²ĞµÑ€Ğ° CargoPro
"""
import uvicorn
import os
from dotenv import load_dotenv

load_dotenv()

if __name__ == "__main__":
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", 8000))
    reload = os.getenv("DEBUG", "True").lower() == "true"
    
    print(f"ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº CargoPro Backend Ğ½Ğ° {host}:{port}")
    print(f"ğŸ“Š Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ API: http://{host}:{port}/api/docs")
    print(f"ğŸ”§ Ğ ĞµĞ¶Ğ¸Ğ¼ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸: {reload}")
    
    uvicorn.run(
        "app.main:app",
        host=host,
        port=port,
        reload=reload,
        log_level="info"
    )
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: run_simple.py                                                          â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\run_simple.py   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# run_simple.py
import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(title="CargoPro Test")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://127.0.0.1:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    return {"message": "CargoPro API Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚!"}

@app.post("/api/auth/login")
async def login(username: str, password: str):
    # ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ Ñ‚ĞµÑÑ‚ Ğ»Ğ¾Ğ³Ğ¸Ğ½Ğ°
    if username == "admin@cargopro.com" and password == "admin123":
        return {
            "access_token": "test_token_123",
            "token_type": "bearer",
            "user": {
                "id": 1,
                "email": "admin@cargopro.com",
                "role": "admin",
                "full_name": "ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€"
            }
        }
    return {"error": "Invalid credentials"}

if __name__ == "__main__":
    print("ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ÑĞµÑ€Ğ²ĞµÑ€Ğ° Ğ½Ğ° http://localhost:8000")
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: seed_data.py                                                           â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\seed_data.py    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#!/usr/bin/env python3
"""
Ğ¡ĞºÑ€Ğ¸Ğ¿Ñ‚ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
"""
import sys
import os

# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿ÑƒÑ‚ÑŒ Ğº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.database import SessionLocal, engine
from app.models import Base
from app.seed import seed_database, clear_database

def main():
    """ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ"""
    print("ğŸŒ± Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ CargoPro")
    print("=" * 50)
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ ĞµÑĞ»Ğ¸ Ğ¸Ñ… Ğ½ĞµÑ‚
    try:
        Base.metadata.create_all(bind=engine)
        print("âœ… Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹")
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†: {e}")
        return
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞµÑÑĞ¸Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    db = SessionLocal()
    
    try:
        # ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)
        if len(sys.argv) > 1 and sys.argv[1] == "--clear":
            print("ğŸ§¹ ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
            clear_database(db)
        
        # Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
        seed_database(db)
        
        print("=" * 50)
        print("ğŸ‰ Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹!")
        print("\nğŸ“‹ Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ ÑƒÑ‡ĞµÑ‚Ğ½Ñ‹Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸:")
        print("-" * 40)
        print("ğŸ‘‘ ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€:")
        print("  Email: admin@cargopro.com")
        print("  ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Admin123!")
        print()
        print("ğŸ‘¥ ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹:")
        print("  1. Email: client1@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Client123!")
        print("  2. Email: client2@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Client123!")
        print("  3. Email: company@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Company123!")
        print()
        print("ğŸšš Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ğ¸:")
        print("  1. Email: driver1@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Driver123!")
        print("  2. Email: driver2@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Driver123!")
        print("  3. Email: driver3@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Driver123!")
        print("  4. Email: driver4@example.com, ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: Driver123!")
        print("-" * 40)
        print("\nğŸš€ Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ ÑĞµÑ€Ğ²ĞµÑ€ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹: python run.py")
        print("ğŸ“š Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ API: http://localhost:8000/api/docs")
        
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    main()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: setup_db.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\setup_db.py     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#!/usr/bin/env python3
"""
Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ - Ğ ĞĞ‘ĞĞ§ĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯
"""
import sys
import os
import hashlib
from datetime import datetime, timedelta
import random

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.database import SessionLocal, engine
from app.models import Base
from app import models

def get_password_hash(password: str) -> str:
    """Ğ¥ĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ - SHA256"""
    return hashlib.sha256(password.encode()).hexdigest()

def create_database():
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸"""
    print("=" * 60)
    print("ğŸš€ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… CargoPro")
    print("=" * 60)
    
    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€ÑƒÑ Ğ±Ğ°Ğ·Ñƒ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
    db_file = "./cargopro.db"
    if os.path.exists(db_file):
        print(f"ğŸ—‘ï¸  Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ€Ğ¾Ğ¹ Ğ±Ğ°Ğ·Ñ‹: {db_file}")
        os.remove(db_file)
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
    print("ğŸ“Š Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†...")
    try:
        Base.metadata.create_all(bind=engine)
        print("âœ… Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾")
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†: {e}")
        return
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞµÑÑĞ¸Ñ
    db = SessionLocal()
    
    try:
        # 1. Ğ¡ĞĞ—Ğ”ĞĞ•Ğœ ĞĞ”ĞœĞ˜ĞĞ˜Ğ¡Ğ¢Ğ ĞĞ¢ĞĞ Ğ
        print("\nğŸ‘‘ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°...")
        admin_password = "Admin123!"
        admin_hash = get_password_hash(admin_password)
        
        admin_user = models.User(
            email="admin@cargopro.com",
            phone="+79991112233",
            full_name="ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ñ‹",
            role=models.UserRole.ADMIN,
            is_active=True,
            is_verified=True,
            hashed_password=admin_hash,
            balance=0.0
        )
        db.add(admin_user)
        print(f"âœ… ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€: admin@cargopro.com / {admin_password}")
        print(f"   Ğ¥ÑÑˆ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ: {admin_hash[:30]}...")
        
        # 2. Ğ¡ĞĞ—Ğ”ĞĞ•Ğœ ĞšĞ›Ğ˜Ğ•ĞĞ¢ĞĞ’
        print("\nğŸ‘¥ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ²...")
        clients_data = [
            {
                "email": "client1@example.com",
                "phone": "+79992223344",
                "name": "Ğ˜Ğ²Ğ°Ğ½ Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ²",
                "password": "Client1!",
                "balance": 50000.0
            },
            {
                "email": "client2@example.com", 
                "phone": "+79993334455",
                "name": "ĞœĞ°Ñ€Ğ¸Ñ ĞŸĞµÑ‚Ñ€Ğ¾Ğ²Ğ°",
                "password": "Client2!",
                "balance": 75000.0
            },
            {
                "email": "company@example.com",
                "phone": "+74951234567",
                "name": "ĞĞĞ 'Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº'",
                "password": "Company1!",
                "balance": 150000.0
            }
        ]
        
        clients = []
        for client in clients_data:
            user = models.User(
                email=client["email"],
                phone=client["phone"],
                full_name=client["name"],
                role=models.UserRole.CLIENT,
                is_active=True,
                is_verified=True,
                hashed_password=get_password_hash(client["password"]),
                balance=client["balance"]
            )
            db.add(user)
            clients.append(user)
            print(f"âœ… ĞšĞ»Ğ¸ĞµĞ½Ñ‚: {client['email']} / {client['password']}")
        
        # 3. Ğ¡ĞĞ—Ğ”ĞĞ•Ğœ Ğ’ĞĞ”Ğ˜Ğ¢Ğ•Ğ›Ğ•Ğ™
        print("\nğŸšš Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹...")
        drivers_data = [
            {
                "email": "driver1@example.com",
                "phone": "+79994445566",
                "name": "ĞĞ»ĞµĞºÑĞµĞ¹ Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ²",
                "password": "Driver1!",
                "verified": True,
                "vehicle": "Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸Ğº",
                "model": "Mercedes Actros",
                "plate": "Ğ123Ğ’Ğ¡777"
            },
            {
                "email": "driver2@example.com",
                "phone": "+79995556677",
                "name": "Ğ”Ğ¼Ğ¸Ñ‚Ñ€Ğ¸Ğ¹ Ğ¨Ğ¾Ñ„ĞµÑ€Ğ¾Ğ²",
                "password": "Driver2!",
                "verified": True,
                "vehicle": "Ğ¤ÑƒÑ€Ğ³Ğ¾Ğ½",
                "model": "Ford Transit",
                "plate": "Ğ’456ĞĞ 777"
            },
            {
                "email": "driver3@example.com",
                "phone": "+79996667788",
                "name": "Ğ¡ĞµÑ€Ğ³ĞµĞ¹ Ğ“Ñ€ÑƒĞ·Ğ¾Ğ²Ğ¸ĞºĞ¾Ğ²",
                "password": "Driver3!",
                "verified": False,
                "vehicle": "Ğ ĞµÑ„Ñ€Ğ¸Ğ¶ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€",
                "model": "Volvo FH",
                "plate": "Ğ¡789Ğ¢Ğ£777"
            }
        ]
        
        drivers = []
        for driver in drivers_data:
            # ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ-Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ
            driver_user = models.User(
                email=driver["email"],
                phone=driver["phone"],
                full_name=driver["name"],
                role=models.UserRole.DRIVER,
                is_active=True,
                is_verified=driver["verified"],
                hashed_password=get_password_hash(driver["password"]),
                balance=25000.0
            )
            db.add(driver_user)
            db.flush()  # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ID
            
            # ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
            driver_profile = models.DriverProfile(
                user_id=driver_user.id,
                vehicle_type=driver["vehicle"],
                vehicle_model=driver["model"],
                vehicle_number=driver["plate"],
                carrying_capacity=random.uniform(3.5, 20.0),
                volume=random.uniform(15.0, 90.0),
                verification_status=models.VerificationStatus.VERIFIED if driver["verified"] else models.VerificationStatus.PENDING,
                rating=round(random.uniform(4.0, 5.0), 1),
                total_orders=random.randint(10, 50),
                total_distance=random.uniform(5000, 15000),
                is_online=driver["verified"],
                current_location_lat=55.7558 + random.uniform(-0.1, 0.1) if driver["verified"] else None,
                current_location_lng=37.6173 + random.uniform(-0.1, 0.1) if driver["verified"] else None
            )
            db.add(driver_profile)
            drivers.append(driver_user)
            
            status = "Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ âœ…" if driver["verified"] else "Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ â³"
            print(f"âœ… Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ: {driver['email']} / {driver['password']} ({status})")
        
        # 4. Ğ¡ĞĞ—Ğ”ĞĞ•Ğœ Ğ—ĞĞšĞĞ—Ğ«
        print("\nğŸ“¦ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²...")
        
        # Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        def generate_order_number():
            return f"ORD{datetime.now().strftime('%Y%m%d')}{random.randint(1000, 9999)}"
        
        # Ğ—Ğ°ĞºĞ°Ğ· 1: ĞŸĞ¾Ğ¸ÑĞº Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ
        order1 = models.Order(
            order_number=generate_order_number(),
            client_id=clients[0].id,
            status=models.OrderStatus.SEARCHING,
            from_address="ĞœĞ¾ÑĞºĞ²Ğ°, ÑƒĞ». Ğ¢Ğ²ĞµÑ€ÑĞºĞ°Ñ, 1",
            from_lat=55.7558,
            from_lng=37.6173,
            to_address="Ğ¡Ğ°Ğ½ĞºÑ‚-ĞŸĞµÑ‚ĞµÑ€Ğ±ÑƒÑ€Ğ³, ĞĞµĞ²ÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¿ĞµĞºÑ‚, 28",
            to_lat=59.9343,
            to_lng=30.3351,
            distance_km=634.0,
            cargo_description="ĞÑ„Ğ¸ÑĞ½Ğ°Ñ Ğ¼ĞµĞ±ĞµĞ»ÑŒ",
            cargo_weight=2.5,
            cargo_volume=12.0,
            cargo_type="ĞœĞµĞ±ĞµĞ»ÑŒ",
            desired_price=35000.0,
            pickup_date=datetime.utcnow() + timedelta(days=2)
        )
        db.add(order1)
        print(f"âœ… Ğ—Ğ°ĞºĞ°Ğ· 1: {order1.order_number} (Ğ¿Ğ¾Ğ¸ÑĞº Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ)")
        
        # Ğ—Ğ°ĞºĞ°Ğ· 2: Ğ’ Ğ¿ÑƒÑ‚Ğ¸
        order2 = models.Order(
            order_number=generate_order_number(),
            client_id=clients[1].id,
            driver_id=drivers[0].id,
            status=models.OrderStatus.EN_ROUTE,
            from_address="Ğ•ĞºĞ°Ñ‚ĞµÑ€Ğ¸Ğ½Ğ±ÑƒÑ€Ğ³, ÑƒĞ». ĞœĞ°Ğ»Ñ‹ÑˆĞµĞ²Ğ°, 51",
            from_lat=56.8389,
            from_lng=60.6057,
            to_address="Ğ§ĞµĞ»ÑĞ±Ğ¸Ğ½ÑĞº, Ğ¿Ñ€. Ğ›ĞµĞ½Ğ¸Ğ½Ğ°, 54",
            to_lat=55.1644,
            to_lng=61.4368,
            distance_km=198.0,
            cargo_description="ĞŸÑ€Ğ¾Ğ¼Ñ‹ÑˆĞ»ĞµĞ½Ğ½Ğ¾Ğµ Ğ¾Ğ±Ğ¾Ñ€ÑƒĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
            cargo_weight=15.0,
            cargo_volume=60.0,
            cargo_type="ĞĞ±Ğ¾Ñ€ÑƒĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
            desired_price=85000.0,
            final_price=82000.0,
            platform_fee=4100.0,
            order_amount=77900.0,
            payment_status=models.PaymentStatus.COMPLETED,
            pickup_date=datetime.utcnow() - timedelta(hours=12),
            delivery_date=datetime.utcnow() + timedelta(hours=36)
        )
        db.add(order2)
        print(f"âœ… Ğ—Ğ°ĞºĞ°Ğ· 2: {order2.order_number} (Ğ² Ğ¿ÑƒÑ‚Ğ¸)")
        
        # Ğ—Ğ°ĞºĞ°Ğ· 3: Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½
        order3 = models.Order(
            order_number=generate_order_number(),
            client_id=clients[2].id,
            driver_id=drivers[1].id,
            status=models.OrderStatus.COMPLETED,
            from_address="ĞĞ¾Ğ²Ğ¾ÑĞ¸Ğ±Ğ¸Ñ€ÑĞº, ĞšÑ€Ğ°ÑĞ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¿ĞµĞºÑ‚, 28",
            from_lat=55.0302,
            from_lng=82.9204,
            to_address="ĞšĞµĞ¼ĞµÑ€Ğ¾Ğ²Ğ¾, ÑƒĞ». Ğ’ĞµÑĞµĞ½Ğ½ÑÑ, 15",
            to_lat=55.3547,
            to_lng=86.0863,
            distance_km=248.0,
            cargo_description="Ğ¡Ñ‚Ñ€Ğ¾Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸Ğ°Ğ»Ñ‹",
            cargo_weight=25.0,
            cargo_volume=90.0,
            cargo_type="Ğ¡Ñ‚Ñ€Ğ¾Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸Ğ°Ğ»Ñ‹",
            desired_price=120000.0,
            final_price=115000.0,
            platform_fee=5750.0,
            order_amount=109250.0,
            payment_status=models.PaymentStatus.COMPLETED,
            pickup_date=datetime.utcnow() - timedelta(days=3),
            delivery_date=datetime.utcnow() - timedelta(days=1),
            completed_at=datetime.utcnow() - timedelta(days=1)
        )
        db.add(order3)
        print(f"âœ… Ğ—Ğ°ĞºĞ°Ğ· 3: {order3.order_number} (Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½)")
        
        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ²ÑĞµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
        db.commit()
        
        print("\n" + "=" * 60)
        print("ğŸ‰ Ğ‘ĞĞ—Ğ Ğ”ĞĞĞĞ«Ğ¥ Ğ£Ğ¡ĞŸĞ•Ğ¨ĞĞ Ğ¡ĞĞ—Ğ”ĞĞĞ!")
        print("=" * 60)
        
        print("\nğŸ“‹ Ğ£Ğ§Ğ•Ğ¢ĞĞ«Ğ• Ğ—ĞĞŸĞ˜Ğ¡Ğ˜ Ğ”Ğ›Ğ¯ Ğ¢Ğ•Ğ¡Ğ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯:")
        print("-" * 50)
        print("ğŸ‘‘ ĞĞ”ĞœĞ˜ĞĞ˜Ğ¡Ğ¢Ğ ĞĞ¢ĞĞ  (Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ):")
        print(f"  Email:    admin@cargopro.com")
        print(f"  ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ:   Admin123!")
        print()
        print("ğŸ‘¥ ĞšĞ›Ğ˜Ğ•ĞĞ¢Ğ« (ÑĞ°Ğ¹Ñ‚/Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ):")
        print(f"  1. Email:    client1@example.com")
        print(f"     ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ:   Client1!")
        print(f"     Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ:   50 000 â‚½")
        print()
        print(f"  2. Email:    client2@example.com")
        print(f"     ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ:   Client2!")
        print(f"     Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ:   75 000 â‚½")
        print()
        print(f"  3. Email:    company@example.com")
        print(f"     ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ:   Company1!")
        print(f"     Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ:   150 000 â‚½")
        print()
        print("ğŸšš Ğ’ĞĞ”Ğ˜Ğ¢Ğ•Ğ›Ğ˜ (Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ):")
        print(f"  1. Email:    driver1@example.com")
        print(f"     ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ:   Driver1!")
        print(f"     Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:   Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ âœ…")
        print()
        print(f"  2. Email:    driver2@example.com")
        print(f"     ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ:   Driver2!")
        print(f"     Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:   Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ âœ…")
        print()
        print(f"  3. Email:    driver3@example.com")
        print(f"     ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ:   Driver3!")
        print(f"     Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:   Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ â³")
        print("-" * 50)
        
        print("\nğŸš€ Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ®Ğ©Ğ˜Ğ• Ğ¨ĞĞ“Ğ˜:")
        print("1. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ ÑĞµÑ€Ğ²ĞµÑ€: python run.py")
        print("2. ĞÑ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ API Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ: http://localhost:8000/api/docs")
        print("3. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ Ñ„Ñ€Ğ¾Ğ½Ñ‚ĞµĞ½Ğ´ (Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ)")
        print("4. Ğ’Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°")
        print("\nâš¡ Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‡ĞµÑ€ĞµĞ· curl:")
        print('curl -X POST http://localhost:8000/api/auth/login \\')
        print('  -H "Content-Type: application/x-www-form-urlencoded" \\')
        print('  -d "username=admin@cargopro.com&password=Admin123!"')
        
    except Exception as e:
        print(f"\nâŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ ĞŸĞ Ğ˜ Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ˜ Ğ‘ĞĞ—Ğ« Ğ”ĞĞĞĞ«Ğ¥: {e}")
        import traceback
        traceback.print_exc()
        db.rollback()
    finally:
        db.close()

if __name__ == "__main__":
    create_database()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: test_cargopro_api.py                                                   â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\test_cargopro_api.py â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# test_cargopro_api.py
"""
Ğ¢ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ²ÑĞµÑ… ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ğ¾Ğ² CargoPro API
IP Ğ°Ğ´Ñ€ĞµÑ: 192.168.10.102
"""

import requests
import json
import time
import os
import sys
from datetime import datetime
import logging

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ³ĞµÑ€Ğ°
logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)

# ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ
BASE_URL = "http://192.168.10.102:8000"
API_URL = f"{BASE_URL}/api"

# Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
TEST_ADMIN = {
    "username": "admin@cargopro.com",
    "password": "Admin123!"
}

TEST_CLIENT = {
    "username": "client1@example.com",
    "password": "Client123!"
}

TEST_DRIVER = {
    "username": "driver1@example.com",
    "password": "Driver123!"
}

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² Ğ¸ ID
tokens = {}
user_ids = {}
order_id = None
bid_id = None

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
def get_auth_headers(user_type="admin"):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¾Ğ² Ñ Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ¼ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸"""
    token = tokens.get(user_type)
    if not token:
        return {}
    return {"Authorization": f"Bearer {token}"}

def make_request(method, endpoint, data=None, headers=None, user_type="admin", expected_status=200):
    """Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²"""
    url = f"{API_URL}{endpoint}"
    
    if headers is None:
        headers = get_auth_headers(user_type)
    
    if data and method in ["POST", "PUT"]:
        headers["Content-Type"] = "application/json"
    
    logger.info(f"Making {method} request to {endpoint}")
    
    try:
        if method == "GET":
            if data:
                response = requests.get(url, headers=headers, params=data)
            else:
                response = requests.get(url, headers=headers)
        elif method == "POST":
            response = requests.post(url, json=data, headers=headers)
        elif method == "PUT":
            response = requests.put(url, json=data, headers=headers)
        elif method == "DELETE":
            response = requests.delete(url, headers=headers)
        else:
            raise ValueError(f"Unsupported method: {method}")
        
        logger.info(f"Response status: {response.status_code}")
        
        if response.status_code != expected_status:
            logger.error(f"Request failed: {response.status_code} - {response.text}")
        
        assert response.status_code == expected_status, f"Expected {expected_status}, got {response.status_code}: {response.text}"
        
        return response
    except Exception as e:
        logger.error(f"Request error: {e}")
        raise

def login_user(user_data, user_type):
    """Ğ’Ñ…Ğ¾Ğ´ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    response = requests.post(f"{API_URL}/auth/login", 
                           data=user_data,
                           headers={"Content-Type": "application/x-www-form-urlencoded"})
    
    if response.status_code == 200:
        data = response.json()
        tokens[user_type] = data["access_token"]
        user_ids[user_type] = data["user"]["id"]
        logger.info(f"{user_type.capitalize()} logged in: {user_data['username']}")
        return True
    else:
        logger.error(f"Login failed for {user_type}: {response.status_code} - {response.text}")
        return False

# ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ‚ĞµÑÑ‚Ñ‹
class TestAuthAPI:
    """Ğ¢ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ğ¾Ğ² Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸"""
    
    def test_health_check(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ API"""
        response = requests.get(BASE_URL)
        assert response.status_code == 200
        data = response.json()
        assert "message" in data
        logger.info(f"Health check: {data['message']}")
        return True
    
    def test_register_new_user(self):
        """Ğ¢ĞµÑÑ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        timestamp = int(time.time())
        new_user = {
            "email": f"testuser{timestamp}@example.com",
            "phone": f"+7999{timestamp % 10000000:07d}",
            "full_name": f"Test User {timestamp}",
            "role": "client",
            "password": "Test123!"
        }
        
        response = requests.post(f"{API_URL}/auth/register", json=new_user)
        
        if response.status_code in [200, 400]:
            # 400 - Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚, ÑÑ‚Ğ¾ Ñ‚Ğ¾Ğ¶Ğµ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
            logger.info(f"User registration attempt: {response.status_code}")
            return True
        
        assert response.status_code == 200
        data = response.json()
        assert "email" in data
        logger.info(f"New user registered: {data['email']}")
        return True
    
    def test_login_admin(self):
        """Ğ¢ĞµÑÑ‚ Ğ²Ñ…Ğ¾Ğ´Ğ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°"""
        return login_user(TEST_ADMIN, "admin")
    
    def test_login_client(self):
        """Ğ¢ĞµÑÑ‚ Ğ²Ñ…Ğ¾Ğ´Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°"""
        return login_user(TEST_CLIENT, "client")
    
    def test_login_driver(self):
        """Ğ¢ĞµÑÑ‚ Ğ²Ñ…Ğ¾Ğ´Ğ° Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»Ñ"""
        return login_user(TEST_DRIVER, "driver")
    
    def test_get_current_user(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ"""
        response = make_request("GET", "/auth/me", user_type="admin")
        data = response.json()
        assert "email" in data
        assert data["email"] == TEST_ADMIN["username"]
        logger.info(f"Current user: {data['email']}")
        return True
    
    def test_refresh_token(self):
        """Ğ¢ĞµÑÑ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ‚Ğ¾ĞºĞµĞ½Ğ°"""
        # Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ refresh Ñ‚Ğ¾ĞºĞµĞ½
        login_response = requests.post(f"{API_URL}/auth/login", 
                                     data=TEST_ADMIN,
                                     headers={"Content-Type": "application/x-www-form-urlencoded"})
        
        if login_response.status_code != 200:
            logger.warning("Skipping refresh token test - login failed")
            return True
        
        refresh_token = login_response.json()["refresh_token"]
        
        response = requests.post(f"{API_URL}/auth/refresh", 
                               json={"refresh_token": refresh_token})
        
        if response.status_code == 200:
            data = response.json()
            assert "access_token" in data
            logger.info("Token refreshed successfully")
        else:
            logger.warning(f"Refresh token test failed: {response.status_code}")
        
        return True

class TestUsersAPI:
    """Ğ¢ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""
    
    def test_get_user_profile(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        response = make_request("GET", "/users/me", user_type="client")
        data = response.json()
        assert "email" in data
        assert data["email"] == TEST_CLIENT["username"]
        logger.info(f"User profile retrieved: {data['email']}")
        return True
    
    def test_update_user_profile(self):
        """Ğ¢ĞµÑÑ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        update_data = {
            "full_name": "Updated Test User",
            "phone": "+79991112233"
        }
        
        response = make_request("PUT", "/users/me", update_data, user_type="client")
        data = response.json()
        assert data["full_name"] == update_data["full_name"]
        logger.info(f"User profile updated: {data['full_name']}")
        return True
    
    def test_get_all_users_admin(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½)"""
        if not tokens.get("admin"):
            logger.warning("Skipping test - admin not logged in")
            return True
        
        response = make_request("GET", "/users/", user_type="admin")
        data = response.json()
        assert isinstance(data, list)
        logger.info(f"Retrieved {len(data)} users")
        return True
    
    def test_get_user_by_id(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ ID (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½)"""
        if not tokens.get("admin") or not user_ids.get("client"):
            logger.warning("Skipping test - admin or client ID not available")
            return True
        
        response = make_request("GET", f"/users/{user_ids['client']}", user_type="admin")
        data = response.json()
        assert data["id"] == user_ids["client"]
        logger.info(f"User retrieved by ID: {data['email']}")
        return True
    
    def test_get_user_balance(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        response = make_request("GET", "/users/me/balance", user_type="client")
        data = response.json()
        assert "balance" in data
        logger.info(f"User balance: {data['balance']}")
        return True

class TestOrdersAPI:
    """Ğ¢ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚Ğ¾Ğ² Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²"""
    
    def test_create_order(self):
        """Ğ¢ĞµÑÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
        global order_id
        
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        order_data = {
            "from_address": "ĞœĞ¾ÑĞºĞ²Ğ°, Ğ›ĞµĞ½Ğ¸Ğ½ÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¿ĞµĞºÑ‚, 32",
            "from_lat": 55.6911,
            "from_lng": 37.5734,
            "to_address": "Ğ¡Ğ°Ğ½ĞºÑ‚-ĞŸĞµÑ‚ĞµÑ€Ğ±ÑƒÑ€Ğ³, ĞĞµĞ²ÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¾ÑĞ¿ĞµĞºÑ‚, 28",
            "to_lat": 59.9343,
            "to_lng": 30.3351,
            "cargo_description": "Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ³Ñ€ÑƒĞ· Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ API",
            "cargo_weight": 2.5,
            "cargo_volume": 12.0,
            "cargo_type": "ĞĞ±Ğ¾Ñ€ÑƒĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
            "desired_price": 35000.0
        }
        
        response = make_request("POST", "/orders/", order_data, user_type="client")
        data = response.json()
        
        assert "order_number" in data
        assert "id" in data
        order_id = data["id"]
        
        logger.info(f"Order created: {data['order_number']} (ID: {order_id})")
        return True
    
    def test_get_my_orders(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ÑĞ¿Ğ¸ÑĞºĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        response = make_request("GET", "/orders/", user_type="client")
        data = response.json()
        assert isinstance(data, list)
        logger.info(f"Retrieved {len(data)} orders for client")
        return True
    
    def test_get_order_by_id(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¿Ğ¾ ID"""
        if not tokens.get("client") or not order_id:
            logger.warning("Skipping test - client not logged in or no order created")
            return True
        
        response = make_request("GET", f"/orders/{order_id}", user_type="client")
        data = response.json()
        assert data["id"] == order_id
        logger.info(f"Order retrieved: {data['order_number']}")
        return True
    
    def test_publish_order(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
        if not tokens.get("client") or not order_id:
            logger.warning("Skipping test - client not logged in or no order created")
            return True
        
        response = make_request("POST", f"/orders/{order_id}/publish", user_type="client")
        data = response.json()
        assert "message" in data
        logger.info(f"Order published: {data['message']}")
        return True
    
    def test_get_available_orders(self):
        """Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² (Ğ´Ğ»Ñ Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹)"""
        if not tokens.get("driver"):
            logger.warning("Skipping test - driver not logged in")
            return True
        
        response = make_request("GET", "/orders/available", user_type="driver")
        data = response.json()
        assert isinstance(data, list)
        logger.info(f"Retrieved {len(data)} available orders")
        return True
    
    def test_calculate_price(self):
        """Ğ¢ĞµÑÑ‚ Ñ€Ğ°ÑÑ‡ĞµÑ‚Ğ° ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ·ĞºĞ¸"""
        if not tokens.get("client"):
            logger.warning("Skipping test - client not logged in")
            return True
        
        calc_data = {
            "from_lat": 55.7558,
            "from_lng": 37.6173,
            "to_lat": 59.9343,
            "to_lng": 30.3351,
            "weight": 2.5,
            "volume": 12.0
        }
        
        response = make_request("POST", "/orders/calculate-price", calc_data, user_type="client")
        data = response.json()
        assert "suggested_price" in data
        logger.info(f"Price calculated: {data['suggested_price']}")
        return True

# Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ²ÑĞµÑ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²
def run_all_tests():
    """Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ²ÑĞµÑ… Ñ‚ĞµÑÑ‚Ğ¾Ğ² Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾"""
    test_classes = [
        TestAuthAPI(),
        TestUsersAPI(),
        TestOrdersAPI()
    ]
    
    total_tests = 0
    passed_tests = 0
    failed_tests = []
    
    logger.info("=" * 80)
    logger.info("ĞĞĞ§ĞĞ›Ğ Ğ¢Ğ•Ğ¡Ğ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯ CARGO PRO API - Ğ‘ĞĞ—ĞĞ’Ğ«Ğ• Ğ¢Ğ•Ğ¡Ğ¢Ğ«")
    logger.info("=" * 80)
    
    for test_class in test_classes:
        class_name = test_class.__class__.__name__
        logger.info(f"\nĞ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼: {class_name}")
        logger.info("-" * 60)
        
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¸Ğ· ĞºĞ»Ğ°ÑÑĞ°
        test_methods = [method for method in dir(test_class) 
                       if method.startswith('test_') and callable(getattr(test_class, method))]
        
        for method_name in test_methods:
            total_tests += 1
            method = getattr(test_class, method_name)
            
            try:
                result = method()
                if result:
                    logger.info(f"âœ“ {method_name}: PASSED")
                    passed_tests += 1
                else:
                    logger.warning(f"âš  {method_name}: SKIPPED")
                    passed_tests += 0.5  # ĞŸĞ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ğ° Ğ±Ğ°Ğ»Ğ»Ğ° Ğ·Ğ° Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ½Ñ‹Ğµ Ñ‚ĞµÑÑ‚Ñ‹
            except AssertionError as e:
                logger.error(f"âœ— {method_name}: FAILED - Assertion Error: {str(e)}")
                failed_tests.append(f"{class_name}.{method_name}: {str(e)}")
            except Exception as e:
                logger.error(f"âœ— {method_name}: FAILED - {str(e)}")
                failed_tests.append(f"{class_name}.{method_name}: {str(e)}")
    
    # Ğ’Ñ‹Ğ²Ğ¾Ğ´ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ²
    logger.info("\n" + "=" * 80)
    logger.info("Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢Ğ« Ğ¢Ğ•Ğ¡Ğ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯")
    logger.info("=" * 80)
    logger.info(f"Ğ’ÑĞµĞ³Ğ¾ Ñ‚ĞµÑÑ‚Ğ¾Ğ²: {total_tests}")
    logger.info(f"ĞŸÑ€Ğ¾Ğ¹Ğ´ĞµĞ½Ğ¾: {passed_tests:.1f}")
    logger.info(f"Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ÑÑ‚ÑŒ: {(passed_tests/total_tests*100):.1f}%")
    
    if failed_tests:
        logger.info("\nĞŸĞ ĞĞ’ĞĞ›Ğ•ĞĞĞ«Ğ• Ğ¢Ğ•Ğ¡Ğ¢Ğ«:")
        for failed_test in failed_tests:
            logger.info(f"  - {failed_test}")
    else:
        logger.info("\nĞ’Ğ¡Ğ• Ğ¢Ğ•Ğ¡Ğ¢Ğ« ĞŸĞ ĞĞ™Ğ”Ğ•ĞĞ« Ğ£Ğ¡ĞŸĞ•Ğ¨ĞĞ!")
    
    return passed_tests >= total_tests * 0.8  # 80% ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ÑÑ‚Ğ¸

def main():
    """ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ"""
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ÑÑ‚Ğ¸ ÑĞµÑ€Ğ²ĞµÑ€Ğ°
    try:
        logger.info(f"ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑÑ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ÑÑ‚ÑŒ ÑĞµÑ€Ğ²ĞµÑ€Ğ° {BASE_URL}...")
        response = requests.get(BASE_URL, timeout=10)
        if response.status_code == 200:
            logger.info(f"âœ“ Ğ¡ĞµÑ€Ğ²ĞµÑ€ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ¿Ğ¾ Ğ°Ğ´Ñ€ĞµÑÑƒ {BASE_URL}")
            
            # Ğ—Ğ°Ğ¿ÑƒÑĞº Ñ‚ĞµÑÑ‚Ğ¾Ğ²
            success = run_all_tests()
            
            if success:
                logger.info("\nâœ… ĞĞ¡ĞĞĞ’ĞĞ«Ğ• Ğ­ĞĞ”ĞŸĞĞ˜ĞĞ¢Ğ« Ğ ĞĞ‘ĞĞ¢ĞĞ®Ğ¢ ĞšĞĞ Ğ Ğ•ĞšĞ¢ĞĞ!")
                logger.info("\nĞ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ ÑˆĞ°Ğ³Ğ¸:")
                logger.info("1. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ: python seed_data.py")
                logger.info("2. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğµ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ‘Ğ”")
                exit(0)
            else:
                logger.info("\nâš  ĞĞ•ĞšĞĞ¢ĞĞ Ğ«Ğ• Ğ¢Ğ•Ğ¡Ğ¢Ğ« ĞŸĞ ĞĞ’ĞĞ›Ğ˜Ğ›Ğ˜Ğ¡Ğ¬!")
                logger.info("\nĞ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸:")
                logger.info("1. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ: python seed_data.py Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ‘Ğ”")
                logger.info("2. Ğ£Ğ±ĞµĞ´Ğ¸Ñ‚ĞµÑÑŒ, Ñ‡Ñ‚Ğ¾ ÑĞµÑ€Ğ²ĞµÑ€ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½: python run.py")
                logger.info("3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ñ„Ğ°Ğ¹Ğ» .env Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ğ¼Ğ¸")
                exit(1)
        else:
            logger.error(f"âœ— Ğ¡ĞµÑ€Ğ²ĞµÑ€ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ¸Ğ»Ğ¸ Ğ²ĞµÑ€Ğ½ÑƒĞ» Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ: {response.status_code}")
            exit(1)
    except requests.exceptions.ConnectionError:
        logger.error(f"âœ— ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº ÑĞµÑ€Ğ²ĞµÑ€Ñƒ {BASE_URL}")
        logger.info("\nĞ£Ğ±ĞµĞ´Ğ¸Ñ‚ĞµÑÑŒ, Ñ‡Ñ‚Ğ¾:")
        logger.info("1. Ğ¡ĞµÑ€Ğ²ĞµÑ€ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ (python run.py)")
        logger.info("2. IP Ğ°Ğ´Ñ€ĞµÑ Ğ²ĞµÑ€Ğ½Ñ‹Ğ¹ (192.168.10.102)")
        logger.info("3. ĞŸĞ¾Ñ€Ñ‚ 8000 Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚")
        logger.info("4. Ğ¤Ğ°Ğ¹Ñ€Ğ²Ğ¾Ğ» Ğ½Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ")
        exit(1)
    except Exception as e:
        logger.error(f"âœ— ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¸: {str(e)}")
        exit(1)

if __name__ == "__main__":
    main()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: test_login.py                                                          â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\cargopro\arrowcargo_backend\test_login.py   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# test_login.py
import requests

def test_login():
    """Ğ¢ĞµÑÑ‚ Ğ»Ğ¾Ğ³Ğ¸Ğ½Ğ° Ñ‡ĞµÑ€ĞµĞ· API"""
    print("ğŸ” Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸Ğ½Ğ° Ñ‡ĞµÑ€ĞµĞ· API...")
    
    test_cases = [
        ("admin@cargopro.com", "admin123", "ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€"),
        ("client1@example.com", "client1", "ĞšĞ»Ğ¸ĞµĞ½Ñ‚"),
        ("driver1@example.com", "driver1", "Ğ’Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ"),
    ]
    
    for email, password, role in test_cases:
        print(f"\nĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ²Ñ…Ğ¾Ğ´Ğ°: {email} ({role})")
        
        try:
            response = requests.post(
                'http://localhost:8000/api/auth/login',
                data={'username': email, 'password': password},
                headers={'Content-Type': 'application/x-www-form-urlencoded'},
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                print(f"âœ… Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾!")
                print(f"   Ğ¢Ğ¾ĞºĞµĞ½: {data['access_token'][:50]}...")
                print(f"   Ğ Ğ¾Ğ»ÑŒ: {data['user']['role']}")
                print(f"   Email: {data['user']['email']}")
            else:
                print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° {response.status_code}")
                print(f"   ĞÑ‚Ğ²ĞµÑ‚: {response.text}")
                
        except Exception as e:
            print(f"âŒ Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ: {e}")

if __name__ == "__main__":
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ÑÑ‚ÑŒ ÑĞµÑ€Ğ²ĞµÑ€Ğ°
    try:
        response = requests.get('http://localhost:8000/', timeout=5)
        print(f"ğŸŒ Ğ¡ĞµÑ€Ğ²ĞµÑ€ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½: {response.status_code}")
        test_login()
    except:
        print("âŒ Ğ¡ĞµÑ€Ğ²ĞµÑ€ Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½. Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ: python run.py")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
